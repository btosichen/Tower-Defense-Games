<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Bomber Arena - Boss Battle</title>
    <style>
        :root {
            --bg-color: #2c2c54; 
            --ui-bg: #40407a;
            --text-color: #ffffff;
            --accent: #ffda79;
            --danger: #ff5252;
            --success: #33d9b2;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            user-select: none;
            overscroll-behavior: none;
        }

        /* âœ… æ·¡ç¶ è‰²èƒŒæ™¯ -> æ·¡è—è‰²èƒŒæ™¯ */
        #game-container {
            position: relative;
            background-color: #7ed6df; /* light blue */
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            width: auto;
            height: 90vh;
            aspect-ratio: 13/11;
            border: 4px solid #f7f1e3;
        }

        @media (max-width: 900px) {
            #game-container {
                border: none;
                height: 100vh;
                width: auto;
                max-width: 100%;
                aspect-ratio: 13/11;
            }
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(44, 44, 84, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 3rem;
            color: var(--accent);
            text-shadow: 4px 4px #222;
            margin-bottom: 10px;
            font-family: 'Verdana', sans-serif;
            font-style: italic;
        }
        
        @media (max-width: 600px) {
            h1 { font-size: 2rem; }
        }

        .btn {
            background: var(--ui-bg);
            color: #fff;
            border: 2px solid #fff;
            padding: 12px 25px;
            font-size: 1.1rem;
            margin: 8px;
            cursor: pointer;
            font-family: inherit;
            transition: transform 0.1s, background 0.2s;
            min-width: 200px;
            -webkit-tap-highlight-color: transparent;
            border-radius: 8px;
            box-shadow: 0 4px 0 #222;
        }

        .btn:active { transform: scale(0.95) translateY(4px); box-shadow: 0 0 0 #222; }

        .btn:hover {
            background: #706fd3;
            border-color: var(--accent);
            color: var(--accent);
        }

        .btn-small {
            padding: 5px 15px;
            font-size: 0.9rem;
            min-width: auto;
            margin: 5px;
        }

        .settings-box {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 280px;
        }
        
        @media (max-width: 400px) {
            .setting-row { width: 100%; }
        }

        .toggle-btn {
            background: #555;
            border: 1px solid #888;
            color: #bbb;
        }
        .toggle-btn.active {
            background: var(--accent);
            color: #2c2c54;
            border-color: #fff;
            font-weight: bold;
        }

        #editor-ui {
            z-index: 30;
            background: rgba(44, 44, 84, 0.98);
        }

        #editor-grid {
            display: grid;
            grid-template-columns: repeat(13, 1fr);
            grid-template-rows: repeat(11, 1fr);
            gap: 1px;
            background: #222;
            padding: 5px;
            border: 2px solid #666;
            margin-bottom: 10px;
            width: 90%;
            max-width: 600px;
            aspect-ratio: 13/11;
        }

        /* âœ… ç·¨è¼¯å™¨æ·¡ç¶  -> æ·¡è— */
        .editor-cell {
            background: #7ed6df;
            border: 1px solid rgba(0,0,0,0.1);
            cursor: pointer;
        }
        .cell-wall { background-color: #718093; }
        .cell-soft { background-color: #e1b12c; }
        .cell-floor { background-color: #7ed6df; }
        .cell-spawn { 
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10"><text y="8" font-size="8">ğŸš©</text></svg>'); 
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.7;
        }

        .controls-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 10px;
            text-align: left;
            font-size: 0.85rem;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
        }

        .key {
            display: inline-block;
            background: #ddd;
            color: #000;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8rem;
            box-shadow: 0 2px 0 #888;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 15;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.5);
            font-weight: bold;
            font-size: 1.1rem;
            font-family: 'Verdana', sans-serif;
        }

        .player-stat {
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.4);
            padding: 5px 12px;
            border-radius: 20px;
            align-items: center;
            border: 2px solid rgba(255,255,255,0.2);
        }

        #level-info {
            color: var(--accent);
            font-size: 1.8rem;
            text-shadow: 3px 3px 0 #2c2c54;
            font-style: italic;
        }

        #game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: bold;
            color: #ffda79;
            text-shadow: 4px 4px 0 #2c2c54, -2px -2px 0 #ff5252;
            pointer-events: none;
            z-index: 15;
            white-space: nowrap;
            text-align: center;
        }
        
        .p1-color { color: #ff5252; }
        .p2-color { color: #34ace0; }

        /* Mobile Controls */
        #mobile-controls {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 50;
            pointer-events: none;
        }

        @media (hover: none) and (pointer: coarse) {
            #mobile-controls { display: block; }
            .controls-info { display: none; }
        }

        .control-group {
            position: absolute;
            bottom: 40px; 
            pointer-events: auto;
            padding-bottom: env(safe-area-inset-bottom); 
        }

        .d-pad-container {
            left: 40px;
            padding-left: env(safe-area-inset-left);
        }

        .action-container {
            right: 110px; 
            bottom: 160px; 
            padding-right: env(safe-area-inset-right);
        }

        .d-pad {
            position: relative;
            width: 160px;
            height: 160px;
            background: rgba(0,0,0,0.15);
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .touch-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            user-select: none;
            -webkit-user-select: none;
            color: rgba(255,255,255,1);
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
        }

        .touch-btn:active, .touch-btn.active {
            background: var(--accent);
            color: #2c2c54;
            transform: scale(0.95) translateY(4px);
            box-shadow: none;
        }

        .btn-up { top: 5px; left: 55px; }
        .btn-down { bottom: 5px; left: 55px; }
        .btn-left { top: 55px; left: 5px; }
        .btn-right { top: 55px; right: 5px; }

        .btn-bomb-touch {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: rgba(255, 82, 82, 0.6);
            border: 4px solid rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: white;
            box-shadow: 0 6px 0 rgba(180, 0, 0, 0.5);
        }
        .btn-bomb-touch:active, .btn-bomb-touch.active {
            background: #ff5252;
            transform: scale(0.95) translateY(4px);
            box-shadow: none;
        }

        #rotate-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #2c2c54;
            z-index: 100;
            color: white;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        #rotate-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: rotate-anim 2s infinite;
        }

        @keyframes rotate-anim {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(90deg); }
            75% { transform: rotate(0deg); }
            100% { transform: rotate(0deg); }
        }

        @media screen and (orientation: portrait) and (max-width: 900px) {
            #rotate-overlay { display: flex; }
            #mobile-controls { display: none; }
        }

    </style>
</head>
<body>

    <div id="rotate-overlay">
        <div id="rotate-icon">ğŸ“±â¡ï¸</div>
        <h2>è«‹å°‡æ‰‹æ©Ÿè½‰ç‚ºæ©«å‘<br>ä»¥ç²å¾—æœ€ä½³é«”é©—</h2>
    </div>

    <div id="game-container">
        
        <div id="hud">
            <div class="player-stat" id="p1-stats">
                <span class="p1-color">P1</span>
                <span>â™¥ <span id="p1-lives">3</span></span>
                <span>ğŸ’£ <span id="p1-bombs">1</span></span>
            </div>
            <div id="level-info">ç¬¬ 1 é—œ</div>
            <div class="player-stat" id="p2-stats" style="opacity: 0;">
                <span class="p2-color">P2</span>
                <span>â™¥ <span id="p2-lives">3</span></span>
                <span>ğŸ’£ <span id="p2-bombs">1</span></span>
            </div>
        </div>

        <canvas id="gameCanvas" width="832" height="704"></canvas>
        
        <div id="game-message"></div>

        <div id="main-menu" class="overlay">
            <h1>BOMBER ARENA</h1>
            <h3 style="color:#ffda79; margin-top:-10px; font-family:sans-serif;">BOSS BATTLE</h3>
            
            <div class="settings-box">
                <div class="setting-row">
                    <span>é›£åº¦ (AI):</span>
                    <button id="btn-diff" class="btn btn-small" onclick="toggleDifficulty()">æ™®é€š</button>
                </div>
                <div class="setting-row">
                    <span>é“å…·ç˜‹ç‹‚æ¨¡å¼:</span>
                    <button id="btn-frenzy" class="btn btn-small toggle-btn" onclick="toggleFrenzy()">OFF</button>
                </div>
            </div>

            <button class="btn" onclick="startGame('single')">å–®äººé—–é—œ (Story)</button>
            <button class="btn" onclick="startGame('versus')">é›™äººå°æˆ° (Vs)</button>
            <button class="btn" onclick="requestFullScreen()">å…¨è¢å¹• (Fullscreen)</button>
            <button class="btn" style="border-color: #aaa; color: #aaa;" onclick="openEditor()">é—œå¡ç·¨è¼¯å™¨ (Editor)</button>
            
            <div class="controls-info">
                <div>
                    <strong class="p1-color">PLAYER 1</strong><br>
                    ç§»å‹•: <span class="key">â†‘</span> <span class="key">â†“</span> <span class="key">â†</span> <span class="key">â†’</span><br>
                    ç‚¸å½ˆ: <span class="key">SPACE</span>
                </div>
                <div>
                    <strong class="p2-color">PLAYER 2</strong><br>
                    ç§»å‹•: <span class="key">W</span> <span class="key">S</span> <span class="key">A</span> <span class="key">D</span><br>
                    ç‚¸å½ˆ: <span class="key">SHIFT</span>
                </div>
            </div>
        </div>

        <div id="editor-ui" class="hidden overlay">
            <h2 style="color: var(--accent);">CUSTOM MAP EDITOR</h2>
            <div id="editor-grid"></div>
            <div>
                <button class="btn" onclick="saveAndCloseEditor()">å„²å­˜</button>
                <button class="btn btn-small" style="background: #444;" onclick="clearEditorMap()">æ¸…ç©º</button>
                <button class="btn btn-small" style="background: #444;" onclick="cancelEditor()">å–æ¶ˆ</button>
            </div>
        </div>

        <div id="game-over" class="overlay hidden">
            <h1 id="go-title">GAME OVER</h1>
            <h2 id="go-reason">Reason</h2>
            <div id="next-level-btn-container" class="hidden">
                <p style="color: #ccc;">èƒ½åŠ›ä¿ç•™è‡³ä¸‹ä¸€é—œï¼</p>
                <button class="btn" onclick="gameInstance.nextLevel()">ä¸‹ä¸€é—œ</button>
            </div>
            <button id="return-menu-btn" class="btn" onclick="returnToMenu()">å›åˆ°é¸å–®</button>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="control-group d-pad-container">
            <div class="d-pad">
                <div class="touch-btn btn-up" data-key="ArrowUp">â†‘</div>
                <div class="touch-btn btn-left" data-key="ArrowLeft">â†</div>
                <div class="touch-btn btn-right" data-key="ArrowRight">â†’</div>
                <div class="touch-btn btn-down" data-key="ArrowDown">â†“</div>
            </div>
        </div>
        <div class="control-group action-container">
            <div class="touch-btn btn-bomb-touch" data-key="Space">ğŸ’£</div>
        </div>
    </div>

    <script>
        const TILE_SIZE = 64; 
        const ROWS = 11;
        const COLS = 13;
        const CANVAS_WIDTH = COLS * TILE_SIZE;
        const CANVAS_HEIGHT = ROWS * TILE_SIZE;

        // âœ… æ·¡è—åœ°æ¿è‰²ï¼ˆåŒæ™‚ç”¨æ–¼ç•«å¸ƒåº•è‰²/ç·¨è¼¯å™¨åœ°æ¿ï¼‰
        const FLOOR_COLOR = '#7ed6df';
        
        const TILE_FLOOR = 0;
        const TILE_WALL = 1;
        const TILE_SOFT = 2;

        // âœ… ä¸‰éš»å‹•ç‰©ï¼ˆæ¯å±€éš¨æ©ŸæŠ½ä¸‰ç¨®ï¼ŒæŠ½åˆ°å¾Œå›ºå®šä¸è®Šï¼‰
        const ANIMAL_POOL = ['ğŸ›','ğŸ','ğŸœ','ğŸª²','ğŸ¦—','ğŸ'];
        // ğŸ = ç‚¸å½ˆèŸ²ï¼ˆæœƒä¸Ÿç‚¸å½ˆï¼‰ï½œğŸ› = èœèŸ²ï¼ˆæ™®é€šï¼‰
        // ç¬¬ä¸‰éš»ï¼ˆä¾‹å¦‚ ğŸœï¼‰åªæ˜¯å¤–è§€ï¼Œç”¨ä¾†æ»¿è¶³ã€Œ3éš»å‹•ç‰©éš¨æ©Ÿå›ºå®šã€
        
        let currentDifficulty = 'normal'; 
        let frenzyMode = false;
        let customMapData = null;

        function requestFullScreen() {
            const el = document.documentElement;
            if (el.requestFullscreen) el.requestFullscreen();
            else if (el.mozRequestFullScreen) el.mozRequestFullScreen();
            else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            else if (el.msRequestFullscreen) el.msRequestFullscreen();
        }

        const AudioEngine = {
            ctx: null,
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playBombPlant: function() { this.playTone(600, 'sine', 0.1); },
            playExplosion: function() { 
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                noise.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            },
            playPowerup: function() { 
                this.playTone(1200, 'square', 0.1, 0.05); 
                setTimeout(() => this.playTone(1600, 'square', 0.1, 0.05), 100);
            },
            playDie: function() {
                this.playTone(300, 'sawtooth', 0.5, 0.2);
                setTimeout(() => this.playTone(150, 'sawtooth', 0.5, 0.2), 200);
            },
            playBossHit: function() {
                this.playTone(100, 'sawtooth', 0.3, 0.5);
                setTimeout(() => this.playTone(80, 'sawtooth', 0.3, 0.5), 100);
            },
            playWin: function() {
                this.playTone(400, 'sine', 0.1);
                setTimeout(() => this.playTone(600, 'sine', 0.1), 150);
                setTimeout(() => this.playTone(800, 'sine', 0.3), 300);
            }
        };

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.lastTime = 0;
                this.map = [];
                this.entities = [];
                this.bombs = [];
                this.explosions = [];
                this.powerups = [];
                this.mode = 'single';
                this.isRunning = false;
                this.isPaused = false;
                this.roundOver = false;
                this.level = 1;
                this.savedStats = null; 

                // âœ… æ¯å±€éš¨æ©Ÿå›ºå®šçš„ä¸‰éš»å‹•ç‰©ï¼ˆå¤–è§€ç”¨ï¼‰
                this.animalSet = null;
                
                this.keys = {};
                window.addEventListener('keydown', e => this.keys[e.code] = true);
                window.addEventListener('keyup', e => this.keys[e.code] = false);

                this.setupTouchControls();
            }

            setupTouchControls() {
                const touchBtns = document.querySelectorAll('.touch-btn, .btn-bomb-touch');
                
                const handleTouch = (e, state) => {
                    e.preventDefault(); 
                    const key = e.currentTarget.getAttribute('data-key');
                    if (key) {
                        this.keys[key] = state;
                        if(state) e.currentTarget.classList.add('active');
                        else e.currentTarget.classList.remove('active');
                    }
                };

                touchBtns.forEach(btn => {
                    btn.addEventListener('touchstart', (e) => handleTouch(e, true), {passive: false});
                    btn.addEventListener('touchend', (e) => handleTouch(e, false), {passive: false});
                    btn.addEventListener('mousedown', (e) => handleTouch(e, true));
                    btn.addEventListener('mouseup', (e) => handleTouch(e, false));
                    btn.addEventListener('mouseleave', (e) => handleTouch(e, false));
                });
            }

            reset(mode, keepProgress = false) {
                this.mode = mode;
                this.map = [];
                this.entities = [];
                this.bombs = [];
                this.explosions = [];
                this.powerups = [];
                this.roundOver = false;
                this.isRunning = true;

                // âœ… æ¯æ¬¡é–‹å±€ï¼ˆæˆ–ä¸‹ä¸€é—œï¼‰éƒ½ã€Œéš¨æ©Ÿä¸€æ¬¡ã€ä½†è©²å±€å›ºå®š
                this.animalSet = this.pickThreeAnimals();

                if (!keepProgress) {
                    this.level = 1;
                    this.savedStats = null;
                }

                const lvlText = (mode === 'single') ? `ç¬¬ ${this.level} é—œ` : 'å°æˆ°æ¨¡å¼';
                document.getElementById('level-info').innerText = lvlText;

                this.generateMap();
                
                this.p1 = new Player(1, 1, 1, 'Red'); 
                if (this.savedStats) {
                    this.p1.maxBombs = this.savedStats.maxBombs;
                    this.p1.bombRange = this.savedStats.bombRange;
                    this.p1.speed = this.savedStats.speed;
                } else if (frenzyMode) {
                    this.p1.maxBombs = 3;
                    this.p1.bombRange = 3;
                    this.p1.speed += 20;
                }
                this.entities.push(this.p1);

                if (mode === 'versus') {
                    this.p2 = new Player(COLS - 2, ROWS - 2, 2, 'Blue');
                    if (frenzyMode) {
                        this.p2.maxBombs = 3;
                        this.p2.bombRange = 3;
                        this.p2.speed += 20;
                    }
                    this.entities.push(this.p2);
                    document.getElementById('p2-stats').style.opacity = 1;
                } else {
                    let enemyCount = 2 + this.level;
                    if (currentDifficulty === 'hard') enemyCount += 2;
                    enemyCount = Math.min(enemyCount, 12);
                    this.spawnEnemies(enemyCount);
                    document.getElementById('p2-stats').style.opacity = 0;
                }

                const msg = (mode === 'single') ? `ç¬¬ ${this.level} é—œ` : "READY?";
                const msgEl = document.getElementById('game-message');
                if(msgEl) msgEl.innerText = msg;
                setTimeout(() => {
                    if(msgEl) msgEl.innerText = "";
                }, 2000);
                
                requestAnimationFrame(t => this.loop(t));
            }

            pickThreeAnimals() {
                const pool = [...ANIMAL_POOL];
                for (let i = pool.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [pool[i], pool[j]] = [pool[j], pool[i]];
                }
                // å›ºå®šä¸‰ç¨®ï¼šindex 0=èœèŸ²å¤–è§€ã€1=ç‚¸å½ˆèŸ²å¤–è§€ã€2=ç¬¬ä¸‰ç¨®å¤–è§€
                // ä½†æˆ‘å€‘ä»ä¿ç•™ã€ŒğŸ›/ğŸã€èªæ„ï¼šé¡¯ç¤ºä¸Šç”¨æŠ½åˆ°çš„ä¸‰å€‹ï¼Œä¸å½±éŸ¿åŠŸèƒ½
                return [pool[0], pool[1], pool[2]];
            }

            generateMap() {
                if (customMapData) {
                    this.map = JSON.parse(JSON.stringify(customMapData));
                    return;
                }

                for (let r = 0; r < ROWS; r++) {
                    const row = [];
                    for (let c = 0; c < COLS; c++) {
                        if (r === 0 || c === 0 || r === ROWS - 1 || c === COLS - 1) {
                            row.push(TILE_WALL);
                        } else if (r % 2 === 0 && c % 2 === 0) {
                            row.push(TILE_WALL);
                        } else {
                            const isP1Safe = (r < 3 && c < 3);
                            const isP2Safe = (r > ROWS - 4 && c > COLS - 4);
                            if (!isP1Safe && !isP2Safe && Math.random() < 0.1) {
                                row.push(TILE_SOFT);
                            } else {
                                row.push(TILE_FLOOR);
                            }
                        }
                    }
                    this.map.push(row);
                }
            }

            spawnEnemies(count) {
                let spawned = 0;
                let attempts = 0;
                const speedMultiplier = 1 + (this.level - 1) * 0.05;

                // âœ… Spawn 1 Bossï¼ˆåŸè¨­å®šä¿ç•™ï¼‰
                let bossSpawned = false;

                // âœ… éBossæ•µäººï¼šç‚¸å½ˆèŸ² vs èœèŸ² = 1:1
                // é€™è£¡çš„ count æ˜¯ã€Œç¸½æ•µäººæ•¸ï¼ˆå«Bossï¼‰ã€
                // æˆ‘å€‘ç¶­æŒã€Œå…ˆå¡ä¸€éš»Bossã€ï¼Œå‰©ä¸‹çš„å† 1:1 åˆ†é…
                const nonBossTotal = Math.max(0, count - 1);
                const bombBugTarget = Math.floor(nonBossTotal / 2);
                const vegBugTarget  = nonBossTotal - bombBugTarget; // ç¢ºä¿ç¸½æ•¸ä¸€è‡´ï¼ˆå·®ä¸€éš»æ™‚çµ¦èœèŸ²ï¼‰

                let bombBugMade = 0;
                let vegBugMade = 0;

                while (spawned < count && attempts < 200) {
                    let r = Math.floor(Math.random() * ROWS);
                    let c = Math.floor(Math.random() * COLS);
                    
                    if (this.map[r][c] === TILE_FLOOR && r > 4 && c > 4) {
                        let diffType = 'normal';
                        if (currentDifficulty === 'easy') diffType = 'easy';
                        else if (currentDifficulty === 'hard') diffType = 'hard';
                        
                        let isBoss = false;
                        if (!bossSpawned) {
                            isBoss = true;
                            bossSpawned = true;
                        }

                        // âœ… ä¸‰éš»å‹•ç‰©å¤–è§€éš¨æ©Ÿå›ºå®šï¼ˆæ¯å±€å›ºå®šï¼‰
                        let species = 'veg'; // èœèŸ²
                        if (!isBoss) {
                            // å…ˆåšæ»¿ 1:1
                            if (bombBugMade < bombBugTarget) {
                                species = 'bomb'; // ç‚¸å½ˆèŸ²
                            } else {
                                species = 'veg';
                            }
                        } else {
                            species = 'boss';
                        }

                        const enemy = new Enemy(c, r, diffType, isBoss, species, this.animalSet);

                        // âœ… èª¿æ•´é€Ÿåº¦ï¼šç‚¸å½ˆèŸ²ã€Œçˆ¬è¡Œé€Ÿåº¦è®Šæ…¢ä¸€é»ã€
                        // ï¼ˆBoss çš„é€Ÿåº¦ä»ç¶­æŒåŸé‚è¼¯ï¼‰
                        if (!isBoss) {
                            enemy.speed *= speedMultiplier;
                        } else {
                            enemy.speed = 130 + (this.level * 5); 
                        }
                        
                        this.entities.push(enemy);
                        spawned++;

                        if (!isBoss) {
                            if (species === 'bomb') bombBugMade++;
                            else vegBugMade++;
                        }
                    }
                    attempts++;
                }
            }

            loop(timestamp) {
                if (!this.isRunning) return;
                const dt = (timestamp - this.lastTime) / 1000;
                this.lastTime = timestamp;

                if (!this.isPaused && !this.roundOver) {
                    this.update(dt);
                }
                this.draw();
                requestAnimationFrame(t => this.loop(t));
            }

            update(dt) {
                this.entities = this.entities.filter(e => e.alive);
                this.entities.forEach(e => e.update(dt, this));

                this.bombs = this.bombs.filter(b => !b.exploded);
                this.bombs.forEach(b => b.update(dt, this));

                this.explosions = this.explosions.filter(e => e.active);
                this.explosions.forEach(e => e.update(dt));

                if (this.mode === 'versus') {
                    const p1Alive = this.entities.find(e => e.id === 1 && e.alive);
                    const p2Alive = this.entities.find(e => e.id === 2 && e.alive);
                    if (!p1Alive || !p2Alive) {
                        this.endGame(p1Alive ? "Player 1 Wins!" : (p2Alive ? "Player 2 Wins!" : "Draw!"), false);
                    }
                } else {
                    const p1 = this.entities.find(e => e.id === 1);
                    const enemies = this.entities.filter(e => e.type === 'enemy');
                    
                    if (!p1 || !p1.alive) {
                        this.endGame("Game Over!", false);
                    } else if (enemies.length === 0) {
                        this.levelCleared();
                    }
                }
                this.updateHUD();
            }

            updateHUD() {
                if (this.p1) {
                    document.getElementById('p1-lives').innerText = this.p1.lives;
                    document.getElementById('p1-bombs').innerText = this.p1.maxBombs;
                }
                if (this.p2) {
                    document.getElementById('p2-lives').innerText = this.p2.lives;
                    document.getElementById('p2-bombs').innerText = this.p2.maxBombs;
                }
            }

            draw() {
                // âœ… æ·¡ç¶  -> æ·¡è—
                this.ctx.fillStyle = FLOOR_COLOR;
                this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const tile = this.map[r][c];
                        const x = c * TILE_SIZE;
                        const y = r * TILE_SIZE;

                        if (tile === TILE_WALL) {
                            this.ctx.fillStyle = '#718093';
                            this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            this.ctx.fillStyle = '#a4b0be';
                            this.ctx.fillRect(x+2, y+2, TILE_SIZE-4, 10);
                            this.ctx.fillRect(x+2, y+2, 10, TILE_SIZE-4);
                            this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                            this.ctx.fillRect(x+5, y+55, TILE_SIZE-10, 5);
                        } else if (tile === TILE_SOFT) {
                            this.ctx.fillStyle = '#e1b12c';
                            this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            this.ctx.fillStyle = '#fbc531';
                            this.ctx.fillRect(x+4, y+4, TILE_SIZE-8, TILE_SIZE-8);
                            this.ctx.fillStyle = '#c23616'; 
                            this.ctx.fillRect(x, y+30, TILE_SIZE, 4);
                            this.ctx.fillRect(x+30, y, 4, 30);
                            this.ctx.fillRect(x+10, y+30, 4, 34);
                        }
                    }
                }

                this.powerups.forEach(p => {
                    const x = p.c * TILE_SIZE + TILE_SIZE/2;
                    const y = p.r * TILE_SIZE + TILE_SIZE/2;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 18, 0, Math.PI*2);
                    if (p.type === 'range') {
                        this.ctx.fillStyle = '#fbc531'; 
                        this.ctx.fill();
                        this.ctx.fillStyle = 'black';
                        this.ctx.font = '20px Arial';
                        this.ctx.fillText('ğŸ”¥', x-10, y+7);
                    } else if (p.type === 'speed') {
                        this.ctx.fillStyle = '#00a8ff'; 
                        this.ctx.fill();
                        this.ctx.fillStyle = 'black';
                        this.ctx.font = '20px Arial';
                        this.ctx.fillText('âš¡', x-10, y+7);
                    } else if (p.type === 'bomb') {
                        this.ctx.fillStyle = '#2f3640'; 
                        this.ctx.fill();
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = '20px Arial';
                        this.ctx.fillText('ğŸ’£', x-10, y+7);
                    }
                });

                this.bombs.forEach(b => {
                    const x = b.c * TILE_SIZE + TILE_SIZE/2;
                    const y = b.r * TILE_SIZE + TILE_SIZE/2;
                    const scale = 1 + Math.sin(Date.now() / 100) * 0.15; 
                    this.ctx.fillStyle = '#2f3542';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 22 * scale, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#57606f';
                    this.ctx.beginPath();
                    this.ctx.arc(x-5, y-5, 6 * scale, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#ff6b6b';
                    this.ctx.lineWidth = 4;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, y-15);
                    this.ctx.lineTo(x+10, y-25);
                    this.ctx.stroke();
                });

                this.entities.forEach(e => e.draw(this.ctx));

                this.explosions.forEach(e => {
                    const x = e.c * TILE_SIZE;
                    const y = e.r * TILE_SIZE;
                    this.ctx.fillStyle = Math.random() > 0.5 ? '#ff9f43' : '#ee5253';
                    this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.globalAlpha = 0.7;
                    this.ctx.fillRect(x+10, y+10, TILE_SIZE-20, TILE_SIZE-20);
                    this.ctx.globalAlpha = 1.0;
                });
            }

            levelCleared() {
                this.roundOver = true;
                AudioEngine.playWin();
                
                this.savedStats = {
                    maxBombs: this.p1.maxBombs,
                    bombRange: this.p1.bombRange,
                    speed: this.p1.speed
                };

                setTimeout(() => {
                    document.getElementById('game-over').classList.remove('hidden');
                    document.getElementById('go-title').innerText = "é—œå¡é€šéï¼";
                    document.getElementById('go-title').style.color = "#44bd32";
                    document.getElementById('go-reason').innerText = `å®Œæˆç¬¬ ${this.level} é—œ`;
                    
                    document.getElementById('next-level-btn-container').classList.remove('hidden');
                    document.getElementById('return-menu-btn').classList.add('hidden');
                    
                    this.isRunning = false;
                }, 1000);
            }

            nextLevel() {
                this.level++;
                document.getElementById('game-over').classList.add('hidden');
                this.reset('single', true); 
            }

            endGame(reason, win) {
                this.roundOver = true;
                setTimeout(() => {
                    document.getElementById('game-over').classList.remove('hidden');
                    document.getElementById('go-title').innerText = "GAME OVER";
                    document.getElementById('go-title').style.color = "#c23616";
                    document.getElementById('go-reason').innerText = reason;
                    
                    document.getElementById('next-level-btn-container').classList.add('hidden');
                    document.getElementById('return-menu-btn').classList.remove('hidden');
                    
                    this.isRunning = false;
                }, 1000);
            }
        }

        class Entity {
            constructor(c, r, type) {
                this.x = c * TILE_SIZE;
                this.y = r * TILE_SIZE;
                this.w = TILE_SIZE - 20;
                this.h = TILE_SIZE - 20;
                this.type = type;
                this.alive = true;
                this.speed = 200;
                this.offX = (TILE_SIZE - this.w) / 2;
                this.offY = (TILE_SIZE - this.h) / 2;
            }

            getGridPos() {
                return {
                    c: Math.floor((this.x + TILE_SIZE/2) / TILE_SIZE),
                    r: Math.floor((this.y + TILE_SIZE/2) / TILE_SIZE)
                };
            }

            checkCollision(newX, newY, game) {
                const points = [
                    {x: newX + this.offX, y: newY + this.offY},
                    {x: newX + this.offX + this.w, y: newY + this.offY},
                    {x: newX + this.offX, y: newY + this.offY + this.h},
                    {x: newX + this.offX + this.w, y: newY + this.offY + this.h}
                ];

                for (let p of points) {
                    const c = Math.floor(p.x / TILE_SIZE);
                    const r = Math.floor(p.y / TILE_SIZE);
                    if (r < 0 || c < 0 || r >= ROWS || c >= COLS) return {collided: true, type: 'bounds'};
                    if (game.map[r][c] === TILE_WALL) return {collided: true, type: 'wall'};
                    if (game.map[r][c] === TILE_SOFT) return {collided: true, type: 'soft'};

                    const bomb = game.bombs.find(b => b.r === r && b.c === c && !b.exploded);
                    if (bomb) {
                        if (bomb.passableEntities.includes(this)) continue; 
                        return {collided: true, type: 'bomb'};
                    }
                }
                return {collided: false};
            }
        }

        class Player extends Entity {
            constructor(c, r, id, colorName) {
                super(c, r, 'player');
                this.id = id;
                this.color = colorName === 'Red' ? '#ff6b6b' : '#48dbfb';
                this.maxBombs = 1;
                this.bombRange = 2;
                this.placedBombs = 0;
                this.lives = 3;
                this.invincible = 0;
            }

            update(dt, game) {
                if (this.invincible > 0) this.invincible -= dt;
                let dx = 0, dy = 0;

                if (this.id === 1) {
                    if (game.keys['ArrowUp']) dy = -1;
                    if (game.keys['ArrowDown']) dy = 1;
                    if (game.keys['ArrowLeft']) dx = -1;
                    if (game.keys['ArrowRight']) dx = 1;
                    if (game.keys['Space']) this.placeBomb(game);
                } else {
                    if (game.keys['KeyW']) dy = -1;
                    if (game.keys['KeyS']) dy = 1;
                    if (game.keys['KeyA']) dx = -1;
                    if (game.keys['KeyD']) dx = 1;
                    if (game.keys['ShiftLeft']) this.placeBomb(game);
                }

                if (dx !== 0 || dy !== 0) {
                    if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }
                    const nextX = this.x + dx * this.speed * dt;
                    const nextY = this.y + dy * this.speed * dt;
                    if (!this.checkCollision(nextX, this.y, game).collided) this.x = nextX;
                    if (!this.checkCollision(this.x, nextY, game).collided) this.y = nextY;
                }

                const center = this.getGridPos();
                const pIndex = game.powerups.findIndex(p => p.c === center.c && p.r === center.r);
                if (pIndex !== -1) {
                    this.collectPowerup(game.powerups[pIndex]);
                    game.powerups.splice(pIndex, 1);
                    AudioEngine.playPowerup();
                }

                if (this.invincible <= 0) {
                    const hit = game.explosions.some(e => e.c === center.c && e.r === center.r);
                    const enemyHit = game.entities.some(e => e.type === 'enemy' && Math.abs(e.x - this.x) < 30 && Math.abs(e.y - this.y) < 30);
                    if (hit || enemyHit) this.die();
                }
            }

            collectPowerup(p) {
                if (p.type === 'range') this.bombRange++;
                if (p.type === 'speed') this.speed = Math.min(this.speed + 50, 450); 
                if (p.type === 'bomb') this.maxBombs++;
            }

            placeBomb(game) {
                if (this.placedBombs >= this.maxBombs) return;
                const pos = this.getGridPos();
                if (game.bombs.some(b => b.c === pos.c && b.r === pos.r)) return;
                const bomb = new Bomb(pos.c, pos.r, this.bombRange, this, game);
                game.bombs.push(bomb);
                this.placedBombs++;
                AudioEngine.playBombPlant();
            }

            die() {
                if (this.lives > 0) {
                    this.lives--;
                    this.invincible = 2;
                    AudioEngine.playDie();
                    if (this.lives <= 0) this.alive = false;
                }
            }

            draw(ctx) {
                if (this.invincible > 0 && Math.floor(Date.now() / 100) % 2 === 0) return;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2, this.w/2, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x + 15, this.y + 15, 10, 10);
                ctx.fillRect(this.x + 35, this.y + 15, 10, 10);
            }
        }

        class Enemy extends Entity {
            constructor(c, r, difficulty, isBoss = false, species = 'veg', animalSet = ['ğŸ›','ğŸ','ğŸœ']) {
                super(c, r, 'enemy');
                this.difficulty = difficulty;
                this.dir = {x: 1, y: 0};
                this.isBoss = isBoss;

                // âœ… ç‰©ç¨®ï¼šveg=èœèŸ²ï½œbomb=ç‚¸å½ˆèŸ²ï½œboss=Boss
                this.species = species;

                // âœ… æ¯å±€å›ºå®šçš„ä¸‰éš»å‹•ç‰©å¤–è§€
                this.animalSet = animalSet;

                // --- åŸæœ¬ Boss è¨­å®šä¿ç•™ ---
                this.maxBombs = isBoss ? 2 : 0;
                this.placedBombs = 0;
                this.bombRange = (difficulty === 'hard' || isBoss) ? 3 : 2; 
                this.bombCooldown = 0; 
                this.escapeTime = 0;
                this.lives = isBoss ? 3 : 1;
                this.invincible = 0;
                
                if (this.difficulty === 'easy') this.speed = 80;
                else if (this.difficulty === 'normal') this.speed = 120;
                else this.speed = 170;
                
                if (this.isBoss) {
                    this.canBomb = true;
                    this.speed = 140;
                } else {
                    // âœ… ç‚¸å½ˆèŸ²å¯ä¸Ÿç‚¸å½ˆï¼ŒèœèŸ²ä¸ä¸Ÿ
                    this.canBomb = (this.species === 'bomb');

                    // âœ… ç‚¸å½ˆèŸ²æ•¸é‡å·²åœ¨ spawnEnemies åšåˆ° 1:1
                    // âœ… ç‚¸å½ˆèŸ²ã€Œçˆ¬è¡Œé€Ÿåº¦è®Šæ…¢ä¸€é»ã€
                    if (this.species === 'bomb') {
                        this.speed *= 0.75;  // è®Šæ…¢ï¼ˆä½ ä¹Ÿå¯ä»¥æ”¹æˆ 0.7 æ›´æ…¢ï¼‰
                        this.maxBombs = 1;
                    }
                }
            }

            update(dt, game) {
                if (this.invincible > 0) this.invincible -= dt;
                if (this.bombCooldown > 0) this.bombCooldown -= dt;
                if (this.escapeTime > 0) this.escapeTime -= dt;

                // Boss Rage Modeï¼ˆåŸæ¨£ä¿ç•™ï¼‰
                if (this.isBoss && this.lives < 3) {
                    this.speed = 220; 
                }

                if (this.escapeTime <= 0) {
                    if (this.isBoss || this.difficulty === 'hard') {
                        const p1 = game.entities.find(e => e.id === 1 && e.alive);
                        if (p1 && Math.random() < 0.05) {
                            if (Math.abs(p1.x - this.x) > Math.abs(p1.y - this.y)) {
                                this.dir = (p1.x > this.x) ? {x:1, y:0} : {x:-1, y:0};
                            } else {
                                this.dir = (p1.y > this.y) ? {x:0, y:1} : {x:0, y:-1};
                            }
                        }
                    } else if (Math.random() < 0.02) {
                        this.pickRandomDirection();
                    }
                }

                const nextX = this.x + this.dir.x * this.speed * dt;
                const nextY = this.y + this.dir.y * this.speed * dt;
                const collision = this.checkCollision(nextX, nextY, game);

                if (collision.collided) {
                    this.pickRandomDirection();
                } else {
                    this.x = nextX;
                    this.y = nextY;

                    // âœ… ç‚¸å½ˆèŸ²ï¼ˆ+Bossï¼‰ç‚¸å½ˆé‚è¼¯
                    if (this.canBomb && this.bombCooldown <= 0 && this.escapeTime <= 0) {
                        const p1 = game.entities.find(e => e.id === 1 && e.alive);
                        if (p1) {
                            const dist = Math.abs(p1.x - this.x) + Math.abs(p1.y - this.y);
                            let bombChance = 0;

                            if (this.isBoss) {
                                bombChance = this.lives < 3 ? 0.08 : 0.03;
                            } else if (this.species === 'bomb') {
                                // ç‚¸å½ˆèŸ²ï¼šæ¯” Boss å°ä¸€é»é»ï¼Œä½†æœ‰å­˜åœ¨æ„Ÿ
                                bombChance = 0.025;
                            }

                            if (dist < TILE_SIZE * 4 && Math.random() < bombChance) {
                                const gridPos = this.getGridPos();
                                const openPaths = this.countOpenPaths(game, gridPos);
                                if (openPaths > 0) this.placeBomb(game);
                            }
                        }
                    }
                }

                if (this.isBoss) {
                    const center = this.getGridPos();
                    const pIndex = game.powerups.findIndex(p => p.c === center.c && p.r === center.r);
                    if (pIndex !== -1) {
                        this.collectPowerup(game.powerups[pIndex]);
                        game.powerups.splice(pIndex, 1);
                        AudioEngine.playPowerup();
                    }
                }

                if (this.invincible <= 0) {
                    const pos = this.getGridPos();
                    if (game.explosions.some(e => e.c === pos.c && e.r === pos.r)) {
                        this.takeDamage();
                    }
                }
            }

            takeDamage() {
                if (this.lives > 0) {
                    this.lives--;
                    this.invincible = 2;
                    AudioEngine.playBossHit();
                    if (this.lives <= 0) {
                        this.alive = false;
                        AudioEngine.playDie();
                    }
                }
            }

            collectPowerup(p) {
                if (p.type === 'range') this.bombRange++;
                if (p.type === 'speed') this.speed = Math.min(this.speed + 30, 400); 
                if (p.type === 'bomb') this.maxBombs++;
            }

            pickRandomDirection() {
                const dirs = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
                this.dir = dirs[Math.floor(Math.random() * dirs.length)];
            }

            countOpenPaths(game, pos) {
                let count = 0;
                const dirs = [{r:0, c:1}, {r:0, c:-1}, {r:1, c:0}, {r:-1, c:0}];
                dirs.forEach(d => {
                    const nr = pos.r + d.r;
                    const nc = pos.c + d.c;
                    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && 
                        game.map[nr][nc] === TILE_FLOOR &&
                        !game.bombs.some(b => b.r === nr && b.c === nc)) {
                        count++;
                    }
                });
                return count;
            }

            placeBomb(game) {
                // éBossçš„ç‚¸å½ˆèŸ²ä¹Ÿæœƒç‚¸ï¼ˆä½†å¼±ä¸€äº›ï¼‰
                if (!this.isBoss && this.species === 'bomb') {
                    if (this.placedBombs >= this.maxBombs) return;
                }

                const pos = this.getGridPos();
                if (game.bombs.some(b => b.c === pos.c && b.r === pos.r)) return;
                
                const bomb = new Bomb(pos.c, pos.r, this.bombRange, this, game);
                game.bombs.push(bomb);
                this.placedBombs++;

                // cooldownï¼šç‚¸å½ˆèŸ²æ…¢ä¸€é»ï¼ˆæ›´åƒã€Œçˆ¬è¡Œï¼‹å¶çˆ¾çˆ†ã€ï¼‰
                if (this.isBoss) this.bombCooldown = this.lives < 3 ? 1.5 : 3;
                else this.bombCooldown = 3.5;

                AudioEngine.playBombPlant();
                
                const neighbors = [
                    {x: 1, y: 0, r: pos.r, c: pos.c + 1},
                    {x: -1, y: 0, r: pos.r, c: pos.c - 1},
                    {x: 0, y: 1, r: pos.r + 1, c: pos.c},
                    {x: 0, y: -1, r: pos.r - 1, c: pos.c}
                ];
                
                const validEscapes = neighbors.filter(n => 
                    n.r >= 0 && n.r < ROWS && n.c >= 0 && n.c < COLS && 
                    game.map[n.r][n.c] === TILE_FLOOR &&
                    !game.bombs.some(b => b.r === n.r && b.c === n.c)
                );

                if (validEscapes.length > 0) {
                    const escape = validEscapes[Math.floor(Math.random() * validEscapes.length)];
                    this.dir = {x: escape.x, y: escape.y};
                    this.escapeTime = 1.0; 
                } else {
                    this.dir.x *= -1;
                    this.dir.y *= -1;
                }
            }

            draw(ctx) {
                if (this.invincible > 0 && Math.floor(Date.now() / 50) % 2 === 0) return;

                // âœ… é¡è‰²ï¼ˆä¿ç•™åŸæœ¬é¢¨æ ¼ï¼‰ï¼‹ å¤–è§€ emojiï¼ˆæ–°å¢ï¼Œä¸ç ´å£åŸè¨­å®šï¼‰
                if (this.isBoss) {
                    ctx.fillStyle = this.lives < 3 ? '#e056fd' : '#8e44ad';
                } else {
                    if (this.difficulty === 'easy') ctx.fillStyle = '#1dd1a1'; 
                    else if (this.difficulty === 'normal') ctx.fillStyle = '#ff9f43'; 
                    else ctx.fillStyle = '#ee5253'; 
                }

                ctx.beginPath();
                const sizeMod = this.isBoss ? 4 : 0;
                const w = Math.sin(Date.now() / 100) * 2;
                ctx.arc(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2, (this.w/2) + sizeMod - 2 + w, 0, Math.PI*2);
                ctx.fill();

                // Angry eyebrows
                if (this.difficulty === 'hard' || (this.isBoss && this.lives < 3)) {
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.moveTo(this.x + 15 - sizeMod, this.y + 25 - sizeMod);
                    ctx.lineTo(this.x + 25 - sizeMod, this.y + 30 - sizeMod);
                    ctx.moveTo(this.x + 45 + sizeMod, this.y + 25 - sizeMod);
                    ctx.lineTo(this.x + 35 + sizeMod, this.y + 30 - sizeMod);
                    ctx.stroke();
                }

                // Draw Crown for Boss
                if (this.isBoss) {
                    ctx.fillStyle = 'gold';
                    ctx.beginPath();
                    ctx.moveTo(this.x + 20, this.y + 10);
                    ctx.lineTo(this.x + 32, this.y + 20);
                    ctx.lineTo(this.x + 44, this.y + 10);
                    ctx.lineTo(this.x + 44, this.y + 25);
                    ctx.lineTo(this.x + 20, this.y + 25);
                    ctx.fill();
                }

                ctx.fillStyle = '#000';
                ctx.fillRect(this.x + 20, this.y + 25, 5, 5);
                ctx.fillRect(this.x + 40, this.y + 25, 5, 5);

                // âœ… ç”¨ emoji å°æ¨™è¨˜ï¼ˆä¸å½±éŸ¿ç¢°æ’/å°ºå¯¸ï¼‰
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                let emoji = this.animalSet[2]; // ç¬¬ä¸‰ç¨®
                if (this.isBoss) emoji = 'ğŸ‘‘';
                else if (this.species === 'veg') emoji = this.animalSet[0];
                else if (this.species === 'bomb') emoji = this.animalSet[1];
                ctx.fillText(emoji, this.x + TILE_SIZE/2, this.y + TILE_SIZE/2 + 2);
            }
        }

        class Bomb {
            constructor(c, r, range, owner, game) {
                this.c = c;
                this.r = r;
                this.range = range;
                this.owner = owner;
                this.timer = 2.0;
                this.exploded = false;
                this.passableEntities = [];
                if (game) {
                    this.passableEntities = game.entities.filter(e => {
                        const ex = e.x + e.offX, ey = e.y + e.offY;
                        const bx = c * TILE_SIZE, by = r * TILE_SIZE;
                        return (ex < bx + TILE_SIZE && ex + e.w > bx && ey < by + TILE_SIZE && ey + e.h > by);
                    });
                }
            }

            update(dt, game) {
                this.timer -= dt;
                if (this.passableEntities.length > 0) {
                    const bx = this.c * TILE_SIZE, by = this.r * TILE_SIZE;
                    this.passableEntities = this.passableEntities.filter(e => {
                        const ex = e.x + e.offX, ey = e.y + e.offY;
                        return (ex < bx + TILE_SIZE && ex + e.w > bx && ey < by + TILE_SIZE && ey + e.h > by);
                    });
                }
                if (game.explosions.some(e => e.c === this.c && e.r === this.r)) this.timer = 0;
                if (this.timer <= 0) this.explode(game);
            }

            explode(game) {
                this.exploded = true;
                this.owner.placedBombs--;
                AudioEngine.playExplosion();
                game.explosions.push(new Explosion(this.c, this.r));
                const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
                
                dirs.forEach(d => {
                    for (let i = 1; i <= this.range; i++) {
                        const nc = this.c + (d.x * i);
                        const nr = this.r + (d.y * i);
                        if (nc < 0 || nc >= COLS || nr < 0 || nr >= ROWS) break;
                        if (game.map[nr][nc] === TILE_WALL) break;
                        game.explosions.push(new Explosion(nc, nr));
                        
                        if (game.map[nr][nc] === TILE_SOFT) {
                            game.map[nr][nc] = TILE_FLOOR;
                            const dropChance = frenzyMode ? 0.9 : 0.5; 
                            if (Math.random() < dropChance) {
                                const types = ['range', 'speed', 'bomb'];
                                const type = types[Math.floor(Math.random() * types.length)];
                                game.powerups.push({c: nc, r: nr, type: type});
                            }
                            break;
                        }
                    }
                });
            }
        }

        class Explosion {
            constructor(c, r) {
                this.c = c;
                this.r = r;
                this.timer = 0.5;
                this.active = true;
            }
            update(dt) {
                this.timer -= dt;
                if (this.timer <= 0) this.active = false;
            }
        }

        const gameInstance = new Game();

        const diffLabels = { 'easy': 'ç°¡å–®', 'normal': 'æ™®é€š', 'hard': 'å›°é›£' };
        document.getElementById('btn-diff').innerText = diffLabels[currentDifficulty];

        function toggleDifficulty() {
            if (currentDifficulty === 'easy') currentDifficulty = 'normal';
            else if (currentDifficulty === 'normal') currentDifficulty = 'hard';
            else currentDifficulty = 'easy';
            
            const btn = document.getElementById('btn-diff');
            btn.innerText = diffLabels[currentDifficulty];
            btn.style.color = currentDifficulty === 'hard' ? '#ff5252' : '#fff';
        }

        function toggleFrenzy() {
            frenzyMode = !frenzyMode;
            const btn = document.getElementById('btn-frenzy');
            if (frenzyMode) {
                btn.innerText = "ON";
                btn.classList.add('active');
            } else {
                btn.innerText = "OFF";
                btn.classList.remove('active');
            }
        }

        function startGame(mode) {
            AudioEngine.init();
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('game-over').classList.add('hidden');
            gameInstance.reset(mode);
        }

        function returnToMenu() {
            document.getElementById('game-over').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
            gameInstance.isRunning = false;
        }

        let editorMap = [];

        function openEditor() {
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('editor-ui').classList.remove('hidden');
            initEditorGrid();
        }

        function initEditorGrid() {
            const grid = document.getElementById('editor-grid');
            grid.innerHTML = '';
            
            if (customMapData) {
                editorMap = JSON.parse(JSON.stringify(customMapData));
            } else {
                editorMap = [];
                for (let r = 0; r < ROWS; r++) {
                    const row = [];
                    for (let c = 0; c < COLS; c++) {
                        if (r === 0 || c === 0 || r === ROWS - 1 || c === COLS - 1) row.push(TILE_WALL);
                        else if (r % 2 === 0 && c % 2 === 0) row.push(TILE_WALL);
                        else row.push(TILE_FLOOR);
                    }
                    editorMap.push(row);
                }
            }

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('editor-cell');
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    
                    const isSpawn = (r===1 && c===1) || (r===ROWS-2 && c===COLS-2);
                    if(isSpawn) cell.classList.add('cell-spawn');

                    cell.onclick = () => {
                        if (isSpawn) return;
                        toggleEditorTile(r, c, cell);
                    };
                    
                    updateCellVisual(cell, editorMap[r][c]);
                    grid.appendChild(cell);
                }
            }
        }

        function toggleEditorTile(r, c, cell) {
            let val = editorMap[r][c];
            val = (val + 1) % 3;
            editorMap[r][c] = val;
            updateCellVisual(cell, val);
        }

        function updateCellVisual(cell, val) {
            cell.classList.remove('cell-floor', 'cell-wall', 'cell-soft');
            if (val === TILE_FLOOR) cell.classList.add('cell-floor');
            else if (val === TILE_WALL) cell.classList.add('cell-wall');
            else if (val === TILE_SOFT) cell.classList.add('cell-soft');
        }

        function saveAndCloseEditor() {
            customMapData = JSON.parse(JSON.stringify(editorMap));
            document.getElementById('editor-ui').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
        }

        function clearEditorMap() {
             for (let r = 1; r < ROWS - 1; r++) {
                for (let c = 1; c < COLS - 1; c++) {
                     if (!((r===1 && c===1) || (r===ROWS-2 && c===COLS-2))) {
                         editorMap[r][c] = TILE_FLOOR;
                     }
                }
            }
            initEditorGrid(); 
        }

        function cancelEditor() {
            document.getElementById('editor-ui').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
        }

    </script>
</body>
</html>
