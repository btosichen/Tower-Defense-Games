<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ¥µé™å¡”é˜² - å¸åœ‹æ“´å¼µç‰ˆ</title>
    <title>3D æ¥µé™å¡”é˜² - å¸åœ‹æ“´å¼µç‰ˆ (æ—¥å¤œæ¨¡å¼)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --accent: #ff6d00;
            --bg-ui: rgba(255, 255, 255, 0.95);
            --text-color: #333;
        }
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #4fc3f7; color: var(--text-color); }
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #4fc3f7; color: var(--text-color); user-select: none; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
@@ -47,6 +47,11 @@
        #pause-btn { background: #ffeb3b; color: #f57f17; }
        #pause-btn:hover { background: #fdd835; }
        #pause-btn.paused { background: #ff9800; color: white; animation: pulse 1s infinite; }
        
        #daynight-btn { background: #90caf9; color: #fff; }
        #daynight-btn.night { background: #283593; color: #ffeb3b; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        .heal-cost { font-size: 0.6em; color: #666; margin-left: 2px; margin-right: 10px; }

@@ -135,7 +140,6 @@
        .float-text.wood { color: #795548; font-size: 1.8em; }
        @keyframes floatUp { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-50px); opacity: 0; } }

        /* æš«åœé®ç½© */
        #pause-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.3); pointer-events: none; display: none;
@@ -148,13 +152,20 @@
            background: rgba(0,0,0,0.9); display: none; z-index: 950;
            justify-content: center; align-items: center; flex-direction: column; color: white;
        }
        
        /* æ‹–æ›³æç¤º */
        #drag-hint {
            position: absolute; bottom: 20px; left: 20px; color: rgba(255,255,255,0.7); 
            font-size: 0.9em; pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="diff-tag">ä»»å‹™: å®ˆè­·æœ¨æ(æœ‰å°å·!) | åœ°åœ–æ“´å¼µ | æŠ“èœèŸ²</div>
    <div id="tower-destroyed-msg">âš ï¸ å¡”è¢«æ‘§æ¯€ï¼</div>
    <div id="pause-overlay">å·²æš«åœ</div>
    <div id="drag-hint">ğŸ’¡ æç¤º: æŒ‰ä½æ»‘é¼ å·¦éµå¯æ‹–æ›³åœ°åœ–</div>

    <div id="level-up-overlay">
        <h1 style="color:#76ff03">é—œå¡å®Œæˆ!</h1>
@@ -176,6 +187,7 @@
            <div class="stat" style="margin-left: 10px;">ğŸŒŠ <span id="wave-txt">1</span> / 2</div>
            <div class="stat">ğŸ‘¾ <span id="enemies-txt">0</span></div>
            <div style="flex:1;"></div>
            <button id="daynight-btn" class="icon-btn" onclick="game.toggleDayNight()" title="åˆ‡æ›æ—¥å¤œ">â˜€ï¸</button>
            <button id="pause-btn" class="icon-btn" onclick="game.togglePause()" title="æš«åœéŠæˆ²">â¸ï¸</button>
            <button id="bgm-toggle" class="icon-btn" onclick="AudioSys.toggleBGM()" title="é–‹é—œéŸ³æ¨‚">ğŸµ</button>
        </div>
@@ -250,79 +262,34 @@
    <script>
        const AudioSys = {
            ctx: new (window.AudioContext || window.webkitAudioContext)(),
            bgmInterval: null,
            isBgmMuted: true, 
            bgmNoteIdx: 0,
            
            bgmInterval: null, isBgmMuted: true, bgmNoteIdx: 0,
            play(type, freq, dur, vol=0.1, type2='sine') {
                if(this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if(type2 === 'slide') {
                    osc.frequency.exponentialRampToValueAtTime(freq/2, this.ctx.currentTime + dur);
                }
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + dur);
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if(type2 === 'slide') osc.frequency.exponentialRampToValueAtTime(freq/2, this.ctx.currentTime + dur);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                osc.connect(gain); gain.connect(this.ctx.destination); osc.start(); osc.stop(this.ctx.currentTime + dur);
            },
            
            shoot() { this.play('square', 800, 0.1, 0.05, 'slide'); },
            laser() { this.play('sawtooth', 1200, 0.15, 0.05, 'slide'); },
            build() { this.play('sine', 600, 0.1, 0.1); },
            boom() { this.play('sawtooth', 100, 0.3, 0.15); },
            error() { this.play('triangle', 150, 0.2, 0.1); },
            animalDie() { this.play('sawtooth', 50, 0.8, 0.2); },
            enemyShoot() { this.play('square', 400, 0.1, 0.05); }, 
            towerDestroy() { this.play('sawtooth', 80, 0.5, 0.3); }, 
            shoot() { this.play('square', 800, 0.1, 0.05, 'slide'); }, laser() { this.play('sawtooth', 1200, 0.15, 0.05, 'slide'); },
            build() { this.play('sine', 600, 0.1, 0.1); }, boom() { this.play('sawtooth', 100, 0.3, 0.15); },
            error() { this.play('triangle', 150, 0.2, 0.1); }, animalDie() { this.play('sawtooth', 50, 0.8, 0.2); },
            enemyShoot() { this.play('square', 400, 0.1, 0.05); }, towerDestroy() { this.play('sawtooth', 80, 0.5, 0.3); }, 
            heal() { this.play('sine', 400, 0.1, 0.1); setTimeout(()=>this.play('sine', 600, 0.2, 0.1), 100); },
            harvest() { this.play('sine', 1000, 0.1, 0.1); setTimeout(()=>this.play('sine', 1500, 0.2, 0.1), 100); }, 
            teleport() { this.play('sawtooth', 800, 0.3, 0.1, 'slide'); }, 
            squish() { this.play('square', 200, 0.1, 0.1, 'slide'); }, 
            chop() { this.play('sawtooth', 100, 0.05, 0.1); }, 
            steal() { this.play('triangle', 600, 0.1, 0.1, 'slide'); }, // å°å·éŸ³æ•ˆ

            teleport() { this.play('sawtooth', 800, 0.3, 0.1, 'slide'); }, squish() { this.play('square', 200, 0.1, 0.1, 'slide'); }, 
            chop() { this.play('sawtooth', 100, 0.05, 0.1); }, steal() { this.play('triangle', 600, 0.1, 0.1, 'slide'); }, 
            toggleBGM() {
                this.isBgmMuted = !this.isBgmMuted;
                const btn = document.getElementById('bgm-toggle');
                if (!this.isBgmMuted) {
                    if (this.ctx.state === 'suspended') this.ctx.resume();
                    this.startBGM();
                    btn.classList.add('active');
                } else {
                    this.stopBGM();
                    btn.classList.remove('active');
                }
                this.isBgmMuted = !this.isBgmMuted; const btn = document.getElementById('bgm-toggle');
                if (!this.isBgmMuted) { if (this.ctx.state === 'suspended') this.ctx.resume(); this.startBGM(); btn.classList.add('active'); } else { this.stopBGM(); btn.classList.remove('active'); }
            },
            
            startBGM() {
                if (this.bgmInterval) return;
                const melody = [523,0,523,0,783,0,783,0,880,0,880,0,783,0,0,0,698,0,698,0,659,0,659,0,587,0,587,0,523,0,0,0];
                const bass = [261,261,392,392,440,440,392,392,349,349,329,329,293,293,261,261];
                const tempo = 160; 

                this.bgmInterval = setInterval(() => {
                    if (this.isBgmMuted) return;
                    const note = melody[this.bgmNoteIdx % melody.length];
                    if (note > 0) this.play('triangle', note, 0.1, 0.05, 'sine');
                    if (this.bgmNoteIdx % 4 === 0) {
                        const bassNote = bass[Math.floor((this.bgmNoteIdx % (bass.length*4)) / 4)];
                        this.play('sine', bassNote, 0.3, 0.08, 'sine');
                    }
                    this.bgmNoteIdx++;
                }, tempo);
                const bass = [261,261,392,392,440,440,392,392,349,349,329,329,293,293,261,261]; const tempo = 160; 
                this.bgmInterval = setInterval(() => { if (this.isBgmMuted) return; const note = melody[this.bgmNoteIdx % melody.length]; if (note > 0) this.play('triangle', note, 0.1, 0.05, 'sine'); if (this.bgmNoteIdx % 4 === 0) { const bassNote = bass[Math.floor((this.bgmNoteIdx % (bass.length*4)) / 4)]; this.play('sine', bassNote, 0.3, 0.08, 'sine'); } this.bgmNoteIdx++; }, tempo);
            },

            stopBGM() {
                if (this.bgmInterval) {
                    clearInterval(this.bgmInterval);
                    this.bgmInterval = null;
                }
            }
            stopBGM() { if (this.bgmInterval) { clearInterval(this.bgmInterval); this.bgmInterval = null; } }
        };

        const TILE_SIZE = 5; 
@@ -341,34 +308,17 @@

        class Game3D {
            constructor() {
                this.lives = 20;
                this.money = 900; 
                this.level = 1;
                this.wave = 1;
                
                this.gridW = 20;
                this.gridH = 15;

                this.enemies = [];
                this.worms = []; 
                this.loggers = [];
                this.woodPiles = []; // æœ¨æå †
                this.thieves = []; // å°å·
                this.towers = [];
                this.plants = []; 
                this.projectiles = [];
                this.particles = [];
                this.animals = []; 
                this.decorations = []; 
                this.waveActive = false;
                this.spawnQueue = [];
                this.clock = new THREE.Clock();
                this.isPaused = false; 
                this.bossesRemainingInWave = 0; 
                this.lives = 20; this.money = 900; this.level = 1; this.wave = 1;
                this.gridW = 20; this.gridH = 15;
                this.enemies = []; this.worms = []; this.loggers = []; this.woodPiles = []; this.thieves = [];
                this.towers = []; this.plants = []; this.projectiles = []; this.particles = [];
                this.animals = []; this.decorations = []; this.waveActive = false; this.spawnQueue = [];
                this.clock = new THREE.Clock(); this.isPaused = false; this.bossesRemainingInWave = 0; 
                this.isNight = false; // æ—¥å¤œç‹€æ…‹

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x4fc3f7); 
                this.scene.fog = new THREE.Fog(0x4fc3f7, 60, 250);
                this.scene.background = new THREE.Color(0x87CEEB); // é è¨­ç™½å¤©
                this.scene.fog = new THREE.Fog(0x87CEEB, 60, 250);

                const aspect = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 800);
@@ -380,17 +330,23 @@
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
                dirLight.position.set(50, 100, 50);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                this.scene.add(dirLight);
                const spotLight = new THREE.SpotLight(0xffeb3b, 0.4);
                spotLight.position.set(0, 50, 0);
                this.scene.add(spotLight);
                // Lights
                this.lights = {};
                this.lights.ambient = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(this.lights.ambient);
                
                this.lights.sun = new THREE.DirectionalLight(0xffffff, 0.9);
                this.lights.sun.position.set(50, 100, 50);
                this.lights.sun.castShadow = true;
                this.lights.sun.shadow.mapSize.width = 2048;
                this.lights.sun.shadow.mapSize.height = 2048;
                this.scene.add(this.lights.sun);

                // æ‹–æ›³ç‹€æ…‹
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.hasDragged = false; // ç”¨ä¾†å€åˆ†é»æ“Šå’Œæ‹–æ›³

                this.grid = []; 
                this.createMap(); 
@@ -403,39 +359,152 @@
                this.selectedTower = null;

                this.ghostMesh = new THREE.Group();
                const gBox = new THREE.Mesh(
                    new THREE.BoxGeometry(TILE_SIZE*0.8, TILE_SIZE, TILE_SIZE*0.8),
                    new THREE.MeshBasicMaterial({ color: 0x76ff03, transparent: true, opacity: 0.5 })
                );
                const gBox = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE*0.8, TILE_SIZE, TILE_SIZE*0.8), new THREE.MeshBasicMaterial({ color: 0x76ff03, transparent: true, opacity: 0.5 }));
                this.ghostMesh.add(gBox);
                this.ghostMesh.visible = false;
                this.scene.add(this.ghostMesh);

                this.rangeCircle = new THREE.Mesh(
                    new THREE.RingGeometry(0.1, 0.2, 64),
                    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
                );
                this.rangeCircle = new THREE.Mesh(new THREE.RingGeometry(0.1, 0.2, 64), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, side: THREE.DoubleSide }));
                this.rangeCircle.rotation.x = -Math.PI / 2;
                this.rangeCircle.visible = false;
                this.scene.add(this.rangeCircle);

                window.addEventListener('resize', () => this.onResize());
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mousedown', (e) => this.onClick(e));
                
                // æ»‘é¼ äº‹ä»¶ (ç”¨æ–¼æ‹–æ›³)
                document.addEventListener('mousedown', (e) => this.onMouseDown(e));
                document.addEventListener('mousemove', (e) => this.onMouseMove(e));
                document.addEventListener('mouseup', (e) => this.onMouseUp(e));

                window.addEventListener('click', () => { if (AudioSys.isBgmMuted) AudioSys.toggleBGM(); }, { once: true });

                this.updateUI();
                this.animate();
            }

            toggleDayNight() {
                this.isNight = !this.isNight;
                const btn = document.getElementById('daynight-btn');
                if (this.isNight) {
                    // æ™šä¸Š
                    this.scene.background = new THREE.Color(0x0d1b2a); // æ·±è—é»‘
                    this.scene.fog.color = new THREE.Color(0x0d1b2a);
                    this.lights.ambient.intensity = 0.2;
                    this.lights.sun.intensity = 0.3; // æœˆå…‰
                    this.lights.sun.color = new THREE.Color(0xaaccff);
                    btn.classList.add('night');
                    btn.innerText = "ğŸŒ™";
                } else {
                    // ç™½å¤©
                    this.scene.background = new THREE.Color(0x87CEEB);
                    this.scene.fog.color = new THREE.Color(0x87CEEB);
                    this.lights.ambient.intensity = 0.6;
                    this.lights.sun.intensity = 0.9;
                    this.lights.sun.color = new THREE.Color(0xffffff);
                    btn.classList.remove('night');
                    btn.innerText = "â˜€ï¸";
                }
            }

            updateCameraPos() {
                const cx = this.gridW * TILE_SIZE / 2;
                const cz = this.gridH * TILE_SIZE / 2;
                const zoom = Math.max(this.gridW, this.gridH) * 3.5;
                this.camera.position.set(cx, zoom, cz + zoom * 0.5); 
                // é©ç•¶çš„é è¨­ä½ç½®
                this.camera.position.set(cx, 80, cz + 80); 
                this.camera.lookAt(cx, 0, cz);
            }

            onMouseDown(e) {
                if (e.target.closest('button') || e.target.closest('.tower-card')) return;
                this.isDragging = true;
                this.hasDragged = false;
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            }

            onMouseMove(e) {
                // æ‹–æ›³é‚è¼¯
                if (this.isDragging) {
                    const dx = e.clientX - this.lastMouseX;
                    const dy = e.clientY - this.lastMouseY;
                    
                    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) this.hasDragged = true;

                    // ç§»å‹•ç›¸æ©Ÿ (åå‘)
                    // æ³¨æ„ï¼š3Dç©ºé–“ä¸­ï¼Œæ»‘é¼ Yå°æ‡‰çš„æ˜¯Zè»¸ç§»å‹•
                    const moveSpeed = 0.1;
                    this.camera.position.x -= dx * moveSpeed;
                    this.camera.position.z -= dy * moveSpeed;
                    
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                }

                // åŸæœ‰çš„ Ghost é‚è¼¯
                const pos = this.getGridPos(e);
                if (pos && pos.x >= 0 && pos.x < this.gridW && pos.z >= 0 && pos.z < this.gridH) {
                    if (this.buildType) {
                        this.ghostMesh.position.set(pos.worldX, 1, pos.worldZ);
                        this.ghostMesh.visible = true;
                        const cell = this.grid[pos.x][pos.z];
                        const canBuild = cell.type === 0 && cell.tower === null && cell.plant === null && !cell.hasDecoration;
                        this.ghostMesh.children[0].material.color.setHex(canBuild ? 0x76ff03 : 0xff1744);
                        if (TOWER_DATA[this.buildType]) {
                            this.rangeCircle.position.set(pos.worldX, 1, pos.worldZ);
                        }
                    }
                } else {
                    this.ghostMesh.visible = false;
                }
            }

            onMouseUp(e) {
                this.isDragging = false;
                if (this.hasDragged) return; // å¦‚æœæ˜¯æ‹–æ›³ï¼Œä¸è§¸ç™¼é»æ“Š

                // ä»¥ä¸‹ç‚ºåŸ onClick é‚è¼¯
                if (e.target.closest('button') || e.target.closest('.tower-card')) return;
                
                this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.camera);

                // æª¢æ¸¬é»æ“Šç‰©ä»¶
                const checkIntersects = (arr, cb) => {
                    const intersects = this.raycaster.intersectObjects(arr.map(o => o.mesh), true);
                    if (intersects.length > 0) {
                        const hit = intersects[0].object.parent;
                        const obj = arr.find(o => o.mesh === hit || o.mesh.children.includes(hit));
                        if(obj) cb(obj);
                        return true;
                    }
                    return false;
                };

                if (checkIntersects(this.worms, w => this.catchWorm(w))) return;
                if (checkIntersects(this.woodPiles, p => this.collectWood(p))) return;

                const pos = this.getGridPos(e);
                if (!pos || pos.x < 0 || pos.x >= this.gridW || pos.z < 0 || pos.z >= this.gridH) return;
                const cell = this.grid[pos.x][pos.z];

                if (this.buildType) {
                    if (cell.type === 0 && cell.tower === null && cell.plant === null && !cell.hasDecoration) {
                        if (FARM_DATA[this.buildType]) {
                            if (this.money >= FARM_DATA[this.buildType].cost) this.buildPlant(pos.x, pos.z, this.buildType);
                            else AudioSys.error();
                        } else {
                            if (this.money >= TOWER_DATA[this.buildType].cost) this.buildTower(pos.x, pos.z, this.buildType);
                            else AudioSys.error();
                        }
                    }
                } else {
                    if (cell.plant) cell.plant.tryHarvest();
                    else if (cell.tower) this.selectTower(cell.tower);
                    else this.closePanel();
                }
            }

            getPaths() {
                const W = this.gridW;
                const H = this.gridH;
@@ -476,16 +545,18 @@
                    }
                }

                // åœ°æ¿é¡è‰²åŠ æ·±
                const floorGeo = new THREE.PlaneGeometry(this.gridW * TILE_SIZE * 2, this.gridH * TILE_SIZE * 2);
                const floorMat = new THREE.MeshLambertMaterial({ color: 0x8bc34a }); 
                const floorMat = new THREE.MeshLambertMaterial({ color: 0x1b5e20 }); // æ·±æ£®æ—ç¶ 
                this.floorMesh = new THREE.Mesh(floorGeo, floorMat);
                this.floorMesh.rotation.x = -Math.PI / 2;
                this.floorMesh.position.set(this.gridW*TILE_SIZE/2 - TILE_SIZE/2, -0.2, this.gridH*TILE_SIZE/2 - TILE_SIZE/2);
                this.floorMesh.receiveShadow = true;
                this.scene.add(this.floorMesh);

                const matEmpty = new THREE.MeshLambertMaterial({ color: 0xc5e1a5 });
                const matPath = new THREE.MeshLambertMaterial({ color: 0xffe0b2 });
                // é™¸åœ°èˆ‡é“è·¯é¡è‰²å°æ¯”
                const matEmpty = new THREE.MeshLambertMaterial({ color: 0x2e7d32 }); // æ·±ç¶ è‰²é™¸åœ°
                const matPath = new THREE.MeshLambertMaterial({ color: 0xffe0b2 }); // äº®æ²™è‰²é“è·¯

                const paths = this.getPaths();

@@ -682,28 +753,21 @@
                this.scene.add(logger.mesh);
            }

            // æ–°å¢ï¼šç”Ÿæˆæœ¨æå † (Lumberjack å®Œæˆæ™‚å‘¼å«)
            spawnWoodPile(x, z) {
                const pile = new WoodPile(x, z);
                this.woodPiles.push(pile);
                this.scene.add(pile.mesh);
                
                // ç”Ÿæˆå°å·
                this.spawnThief(pile);
            }

            // æ–°å¢ï¼šç”Ÿæˆå°å·
            spawnThief(targetPile) {
                // å¾éš¨æ©Ÿé‚Šç·£ç”Ÿæˆ
                const startX = Math.random() > 0.5 ? 0 : (this.gridW-1)*TILE_SIZE;
                const startZ = Math.random() * (this.gridH-1)*TILE_SIZE;
                
                const thief = new Thief(startX, startZ, targetPile);
                this.thieves.push(thief);
                this.scene.add(thief.mesh);
            }

            // æ–°å¢ï¼šå›æ”¶æœ¨æ
            collectWood(pile) {
                this.scene.remove(pile.mesh);
                this.woodPiles = this.woodPiles.filter(p => p !== pile);
@@ -725,7 +789,6 @@
                document.body.appendChild(text);
                setTimeout(() => text.remove(), 1000);

                // å°å·å¦‚æœç›®æ¨™æ˜¯é€™å€‹ï¼Œå°±å¤±æ•—é€ƒè·‘
                this.thieves.forEach(t => {
                    if (t.target === pile) {
                        t.state = 'ESCAPED';
@@ -737,13 +800,11 @@
            startNextLevel() {
                document.getElementById('level-up-overlay').style.display = 'none';

                // åœ°åœ–æ“´å¼µ 33%
                this.gridW = Math.floor(this.gridW * 1.33);
                this.gridH = Math.floor(this.gridH * 1.33);
                this.level++;
                this.wave = 1;

                // æ¸…ç†æ‰€æœ‰å‹•æ…‹ç‰©ä»¶
                const removeAll = (arr) => { arr.forEach(o => this.scene.remove(o.mesh)); return []; };
                this.enemies = removeAll(this.enemies);
                this.towers = removeAll(this.towers);
@@ -805,7 +866,6 @@

            spawnBossSequence(baseDelay = 0) {
                if (this.bossesRemainingInWave <= 0) return;
                
                this.bossesRemainingInWave--; 

                const activePaths = this.getPaths();
@@ -991,6 +1051,22 @@
            }

            onMouseMove(e) {
                // æ‹–æ›³é‚è¼¯
                if (this.isDragging) {
                    const dx = e.clientX - this.lastMouseX;
                    const dy = e.clientY - this.lastMouseY;
                    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) this.hasDragged = true;

                    const moveSpeed = 0.1;
                    // Yè»¸æ»‘é¼ å°æ‡‰ Zè»¸ä¸–ç•Œ
                    this.camera.position.x -= dx * moveSpeed;
                    this.camera.position.z -= dy * moveSpeed;
                    
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    return;
                }

                const pos = this.getGridPos(e);
                if (pos && pos.x >= 0 && pos.x < this.gridW && pos.z >= 0 && pos.z < this.gridH) {
                    if (this.buildType) {
@@ -1007,23 +1083,31 @@
                    this.ghostMesh.visible = false;
                }
            }

            onClick(e) {
            
            onMouseDown(e) {
                if (e.target.closest('button') || e.target.closest('.tower-card')) return;
                
                this.isDragging = true;
                this.hasDragged = false;
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            }

            onMouseUp(e) {
                this.isDragging = false;
                if (this.hasDragged) return; // å¦‚æœæ˜¯æ‹–æ›³ï¼Œä¸è§¸ç™¼é»æ“Š

                // åŸæœ‰çš„é»æ“Šé‚è¼¯
                this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.camera);

                // å„ªå…ˆæª¢æ¸¬èœèŸ²
                const wormIntersects = this.raycaster.intersectObjects(this.worms.map(w => w.mesh), true);
                if (wormIntersects.length > 0) {
                    const clickedMesh = wormIntersects[0].object.parent; 
                    const worm = this.worms.find(w => w.mesh === clickedMesh || w.mesh.children.includes(clickedMesh));
                    if (worm) { this.catchWorm(worm); return; }
                }

                // æª¢æ¸¬æœ¨æå †
                const pileIntersects = this.raycaster.intersectObjects(this.woodPiles.map(p => p.mesh), true);
                if (pileIntersects.length > 0) {
                     const clickedMesh = pileIntersects[0].object.parent;
@@ -1052,6 +1136,10 @@
                }
            }

            onClick(e) {
                // å·²æ•´åˆåˆ° onMouseUp
            }

            buildTower(gx, gz, type) {
                this.money -= TOWER_DATA[type].cost;
                const t = new Tower(gx, gz, type);
@@ -1097,6 +1185,7 @@
                document.getElementById('up-range').innerText = t.getRange();
                document.getElementById('btn-upgrade').innerText = `å‡ç´š ($${cost})`;
                document.getElementById('btn-upgrade').disabled = this.money < cost;
                
                document.getElementById('up-hp').innerText = Math.floor(t.hp);
                document.getElementById('up-max-hp').innerText = t.maxHp;
                document.getElementById('up-hp-bar').style.width = (t.hp / t.maxHp * 100) + '%';
@@ -1168,7 +1257,7 @@
        }

        // ==========================================
        // ä¼æœ¨å·¥
        // ä¼æœ¨å·¥ (New)
        // ==========================================
        class Lumberjack {
            constructor(x, z) {
@@ -1227,7 +1316,6 @@
                game.grid[this.targetTree.x][this.targetTree.z].hasDecoration = false; 
                game.decorations = game.decorations.filter(d => d !== this.targetTree);

                // Spawn Wood Pile instead of direct money
                game.spawnWoodPile(this.mesh.position.x, this.mesh.position.z);

                AudioSys.chop();
@@ -1237,9 +1325,6 @@
            }
        }

        // ==========================================
        // Wood Pile (New)
        // ==========================================
        class WoodPile {
            constructor(x, z) {
                this.mesh = new THREE.Group();
@@ -1254,14 +1339,10 @@
            }
        }

        // ==========================================
        // Thief (New)
        // ==========================================
        class Thief {
            constructor(x, z, target) {
                this.target = target;
                this.mesh = new THREE.Group();
                // Ninja-like appearance
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.5), new THREE.MeshLambertMaterial({color: 0x212121}));
                body.position.y = 0.75;
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshLambertMaterial({color: 0x212121}));
@@ -1270,60 +1351,28 @@
                eyes.position.set(0, 1.6, 0.4);
                this.mesh.add(body, head, eyes);
                this.mesh.position.set(x, 0, z);
                
                this.speed = 0.15; // fast
                this.state = 'RUNNING';
                this.timer = 0;
                this.speed = 0.15; this.state = 'RUNNING'; this.timer = 0;
            }
            update() {
                if (this.state === 'ESCAPED') {
                    this.mesh.translateZ(this.speed);
                    if (this.mesh.position.length() > 200) { // far away
                        game.scene.remove(this.mesh);
                        game.thieves = game.thieves.filter(t => t !== this);
                    }
                    if (this.mesh.position.length() > 200) { game.scene.remove(this.mesh); game.thieves = game.thieves.filter(t => t !== this); }
                    return;
                }
                
                if (!this.target || !game.woodPiles.includes(this.target)) {
                    // Target gone, escape
                    this.state = 'ESCAPED';
                    return;
                }
                
                if (!this.target || !game.woodPiles.includes(this.target)) { this.state = 'ESCAPED'; return; }
                const dist = this.mesh.position.distanceTo(this.target.mesh.position);
                if (this.state === 'RUNNING') {
                    if (dist > 1.5) {
                        this.mesh.lookAt(this.target.mesh.position);
                        this.mesh.translateZ(this.speed);
                    } else {
                        this.state = 'STEALING';
                        // Alert icon
                        const alert = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color: 0xff0000}));
                        alert.position.y = 2.5;
                        this.mesh.add(alert);
                    }
                    if (dist > 1.5) { this.mesh.lookAt(this.target.mesh.position); this.mesh.translateZ(this.speed); }
                    else { this.state = 'STEALING'; const alert = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color: 0xff0000})); alert.position.y = 2.5; this.mesh.add(alert); }
                } else if (this.state === 'STEALING') {
                    this.timer++;
                    if (this.timer > 120) { // 2 seconds (60fps)
                        // Steal!
                        game.scene.remove(this.target.mesh);
                        game.woodPiles = game.woodPiles.filter(p => p !== this.target);
                    if (this.timer > 120) {
                        game.scene.remove(this.target.mesh); game.woodPiles = game.woodPiles.filter(p => p !== this.target);
                        AudioSys.steal();
                        
                        const text = document.createElement('div');
                        text.className = 'float-text bad';
                        text.innerText = `è¢«å·äº†!`;
                        const vec = this.mesh.position.clone();
                        vec.y += 3;
                        vec.project(game.camera);
                        const x = (vec.x * .5 + .5) * window.innerWidth;
                        const y = (-(vec.y * .5) + .5) * window.innerHeight;
                        text.style.left = `${x}px`;
                        text.style.top = `${y}px`;
                        document.body.appendChild(text);
                        setTimeout(() => text.remove(), 1000);
                        
                        const text = document.createElement('div'); text.className = 'float-text bad'; text.innerText = `è¢«å·äº†!`;
                        const vec = this.mesh.position.clone(); vec.y += 3; vec.project(game.camera);
                        const x = (vec.x * .5 + .5) * window.innerWidth; const y = (-(vec.y * .5) + .5) * window.innerHeight;
                        text.style.left = `${x}px`; text.style.top = `${y}px`; document.body.appendChild(text); setTimeout(() => text.remove(), 1000);
                        this.state = 'ESCAPED';
                    }
                }
@@ -1422,101 +1471,32 @@

        class Animal {
            constructor(gx, gz) {
                this.hpMax = 200; 
                this.hp = this.hpMax;
                
                // 3D è¨­ç½®
                this.mesh = new THREE.Group();
                this.mesh.position.set(gx * TILE_SIZE, 0, gz * TILE_SIZE);

                // èº«é«”
                const body = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 2), new THREE.MeshLambertMaterial({color: 0xffccbc})); 
                body.position.y = 0.75; body.castShadow = true;
                
                // è€³æœµ
                const earGeo = new THREE.BoxGeometry(0.5, 1, 0.5);
                const earL = new THREE.Mesh(earGeo, new THREE.MeshLambertMaterial({color: 0xffab91})); earL.position.set(-0.6, 1.8, 0);
                const earR = new THREE.Mesh(earGeo, new THREE.MeshLambertMaterial({color: 0xffab91})); earR.position.set(0.6, 1.8, 0);
                
                // é¼»å­
                this.hpMax = 200; this.hp = this.hpMax;
                this.mesh = new THREE.Group(); this.mesh.position.set(gx * TILE_SIZE, 0, gz * TILE_SIZE);
                const body = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 2), new THREE.MeshLambertMaterial({color: 0xffccbc})); body.position.y = 0.75; body.castShadow = true;
                const earGeo = new THREE.BoxGeometry(0.5, 1, 0.5); const earL = new THREE.Mesh(earGeo, new THREE.MeshLambertMaterial({color: 0xffab91})); earL.position.set(-0.6, 1.8, 0); const earR = new THREE.Mesh(earGeo, new THREE.MeshLambertMaterial({color: 0xffab91})); earR.position.set(0.6, 1.8, 0);
                const nose = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.2), new THREE.MeshLambertMaterial({color: 0xff5722})); nose.position.set(0, 1, 1);
                
                // ç‚ºäº†è®“èº«é«”æ—‹è½‰æ™‚äº”å®˜è·Ÿè‘—å‹•ï¼Œå»ºç«‹ä¸€å€‹å…§éƒ¨çš„ Group æ”¾èº«é«”éƒ¨ä»¶
                this.bodyGroup = new THREE.Group();
                this.bodyGroup.add(body, earL, earR, nose);
                this.mesh.add(this.bodyGroup);

                // è¡€æ¢ (ç¨ç«‹æ–¼ bodyGroupï¼Œé¿å…ç¿»æ»¾)
                const barContainer = new THREE.Group();
                const bg = new THREE.Mesh(new THREE.PlaneGeometry(3.2, 0.6), new THREE.MeshBasicMaterial({color:0x000000}));
                const fg = new THREE.Mesh(new THREE.PlaneGeometry(3, 0.4), new THREE.MeshBasicMaterial({color:0x29b6f6})); 
                fg.position.z = 0.01; 
                barContainer.add(bg, fg);
                barContainer.position.y = 3.5;
                this.hpBar = fg;
                this.barContainer = barContainer; // å­˜èµ·ä¾† update ç”¨
                this.mesh.add(barContainer);

                // å‹•æ…‹è¡Œç‚ºåƒæ•¸
                this.homePos = this.mesh.position.clone(); // è¨˜ä½å‡ºç”Ÿé»
                this.targetPos = this.homePos.clone();
                this.state = 'IDLE'; // IDLE, MOVING
                this.idleTimer = Math.random() * 60 + 30; // éš¨æ©Ÿç™¼å‘†æ™‚é–“
                this.moveSpeed = 0.04;
                this.bodyGroup = new THREE.Group(); this.bodyGroup.add(body, earL, earR, nose); this.mesh.add(this.bodyGroup);
                const barContainer = new THREE.Group(); const bg = new THREE.Mesh(new THREE.PlaneGeometry(3.2, 0.6), new THREE.MeshBasicMaterial({color:0x000000})); const fg = new THREE.Mesh(new THREE.PlaneGeometry(3, 0.4), new THREE.MeshBasicMaterial({color:0x29b6f6})); fg.position.z = 0.01; barContainer.add(bg, fg); barContainer.position.y = 3.5; this.hpBar = fg; this.barContainer = barContainer; this.mesh.add(barContainer);
                this.homePos = this.mesh.position.clone(); this.targetPos = this.homePos.clone(); this.state = 'IDLE'; this.idleTimer = Math.random() * 60 + 30; this.moveSpeed = 0.04;
            }

            update() {
                // è¡€æ¢æ°¸é æœå‘ç›¸æ©Ÿ
                this.barContainer.lookAt(game.camera.position);

                if (this.state === 'IDLE') {
                    // ç™¼å‘†å‹•ç•«: å‘¼å¸
                    const time = Date.now() * 0.005;
                    this.bodyGroup.position.y = Math.sin(time) * 0.05;
                    this.bodyGroup.rotation.z = Math.sin(time * 0.5) * 0.02;

                    this.idleTimer--;
                    if (this.idleTimer <= 0) {
                        this.pickNewTarget();
                    }
                    const time = Date.now() * 0.005; this.bodyGroup.position.y = Math.sin(time) * 0.05; this.bodyGroup.rotation.z = Math.sin(time * 0.5) * 0.02;
                    this.idleTimer--; if (this.idleTimer <= 0) this.pickNewTarget();
                } else if (this.state === 'MOVING') {
                    // ç§»å‹•é‚è¼¯
                    const currentPos = this.mesh.position;
                    const dist = currentPos.distanceTo(this.targetPos);

                    if (dist < 0.1) {
                        // åˆ°é”ç›®æ¨™
                        this.state = 'IDLE';
                        this.idleTimer = Math.random() * 100 + 50;
                    } else {
                        // å‰é€²
                        const dir = new THREE.Vector3().subVectors(this.targetPos, currentPos).normalize();
                        this.mesh.position.add(dir.multiplyScalar(this.moveSpeed));
                        
                        // é¢å‘ç›®æ¨™
                        this.bodyGroup.lookAt(this.targetPos.x, this.bodyGroup.position.y + this.mesh.position.y, this.targetPos.z);
                        
                        // èµ°è·¯è·³èºå‹•ç•«
                        const time = Date.now() * 0.015;
                        this.bodyGroup.position.y = Math.abs(Math.sin(time)) * 0.5; // è·³å‹•
                    }
                    const currentPos = this.mesh.position; const dist = currentPos.distanceTo(this.targetPos);
                    if (dist < 0.1) { this.state = 'IDLE'; this.idleTimer = Math.random() * 100 + 50; }
                    else { const dir = new THREE.Vector3().subVectors(this.targetPos, currentPos).normalize(); this.mesh.position.add(dir.multiplyScalar(this.moveSpeed)); this.bodyGroup.lookAt(this.targetPos.x, this.bodyGroup.position.y + this.mesh.position.y, this.targetPos.z); const time = Date.now() * 0.015; this.bodyGroup.position.y = Math.abs(Math.sin(time)) * 0.5; }
                }
            }

            pickNewTarget() {
                // åœ¨å‡ºç”Ÿé»é™„è¿‘éš¨æ©Ÿæ‰¾é» (åŠå¾‘ 2 æ ¼å…§)
                const range = TILE_SIZE * 2; 
                const dx = (Math.random() - 0.5) * 2 * range;
                const dz = (Math.random() - 0.5) * 2 * range;
                const range = TILE_SIZE * 2; const dx = (Math.random() - 0.5) * 2 * range; const dz = (Math.random() - 0.5) * 2 * range;
                this.targetPos.set(this.homePos.x + dx, 0, this.homePos.z + dz);
                
                // é™åˆ¶åœ¨é‚Šç•Œå…§ (ç°¡å–® clamp)
                this.targetPos.x = Math.max(0, Math.min(this.targetPos.x, game.gridW * TILE_SIZE));
                this.targetPos.z = Math.max(0, Math.min(this.targetPos.z, game.gridH * TILE_SIZE));
                
                this.targetPos.x = Math.max(0, Math.min(this.targetPos.x, game.gridW * TILE_SIZE)); this.targetPos.z = Math.max(0, Math.min(this.targetPos.z, game.gridH * TILE_SIZE));
                this.state = 'MOVING';
            }

            updateBar() { const pct = Math.max(0, this.hp / this.hpMax); this.hpBar.scale.x = pct; }
            takeDamage(amt) { this.hp -= amt; this.updateBar(); if (this.hp <= 0) game.removeAnimal(this); }
        }
