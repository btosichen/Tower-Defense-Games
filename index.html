<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ê•µÈôêÂ°îÈò≤ - Âø´Ê®ÇËæ≤Â†¥Áâà (È≠îÁéãÊé•Âäõ)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --accent: #ff6d00;
            --bg-ui: rgba(255, 255, 255, 0.95);
            --text-color: #333;
        }
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #4fc3f7; color: var(--text-color); }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        #top-bar {
            display: flex; gap: 15px; background: var(--bg-ui); padding: 12px 25px;
            border-radius: 50px; pointer-events: auto; border-bottom: 4px solid var(--accent);
            align-self: center; font-weight: bold; font-size: 1.2em;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15); color: #444;
            align-items: center;
        }
        .stat { display: flex; align-items: center; gap: 5px; }
        .stat span { color: #d32f2f; font-family: monospace; font-size: 1.2em; }
        .stat.money span { color: #f57f17; }
        .stat.animals span { color: #0277bd; }

        .icon-btn {
            background: #eee; border: none; border-radius: 50%; 
            width: 35px; height: 35px; cursor: pointer; font-weight: bold; font-size: 1.2em;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); transition: transform 0.1s, background 0.2s; margin-left: 5px;
        }
        .icon-btn:active { transform: scale(0.9); }
        
        #heal-btn { background: #00e676; color: white; }
        #heal-btn:hover { background: #00c853; }
        
        #bgm-toggle.active { background: #76ff03; color: #33691e; }
        
        #pause-btn { background: #ffeb3b; color: #f57f17; }
        #pause-btn:hover { background: #fdd835; }
        #pause-btn.paused { background: #ff9800; color: white; animation: pulse 1s infinite; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        .heal-cost { font-size: 0.6em; color: #666; margin-left: 2px; margin-right: 10px; }

        #bottom-controls {
            display: flex; justify-content: center; align-items: flex-end; gap: 10px;
            pointer-events: auto; margin-bottom: 20px; flex-wrap: wrap;
        }

        .control-group {
            display: flex; gap: 10px; background: rgba(255,255,255,0.5); 
            padding: 10px; border-radius: 20px; backdrop-filter: blur(5px);
        }

        .tower-card {
            background: var(--bg-ui); width: 85px; padding: 8px; border-radius: 12px;
            text-align: center; cursor: pointer; transition: all 0.2s; border: 3px solid #fff;
            position: relative; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .tower-card:hover { transform: translateY(-8px); border-color: var(--accent); }
        .tower-card.active { border-color: var(--accent); background: #fff3e0; transform: translateY(-8px); }
        .tower-card.farm { border-color: #aed581; }
        .tower-card.farm.active { border-color: #76ff03; background: #f1f8e9; }
        
        .tower-icon { 
            width: 40px; height: 40px; margin: 0 auto 5px; border-radius: 10px; 
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1); display: flex; 
            justify-content: center; align-items: center; font-size: 20px;
            border: 2px solid rgba(0,0,0,0.05);
        }
        .tower-cost { color: #e65100; font-weight: bold; font-size: 0.85em; }
        .tower-name { font-size: 0.75em; margin-bottom: 2px; color: #555; }

        .action-btn {
            background: linear-gradient(45deg, #ff6d00, #ff9100); color: white; border: none;
            padding: 15px 30px; border-radius: 50px; font-size: 1.1em; font-weight: bold;
            cursor: pointer; box-shadow: 0 5px 15px rgba(255, 109, 0, 0.4);
            transition: transform 0.1s; pointer-events: auto; height: 70px;
            align-self: center;
        }
        .action-btn:active { transform: scale(0.95); }
        .action-btn:disabled { background: #ccc; cursor: not-allowed; opacity: 0.7; box-shadow: none; }

        #upgrade-panel {
            position: absolute; right: 20px; top: 50%; transform: translateY(-50%);
            background: var(--bg-ui); padding: 20px; border-radius: 20px; width: 240px;
            pointer-events: auto; display: none; border: 2px solid #fff;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
        }
        .up-info { margin-bottom: 15px; line-height: 1.6; font-size: 0.95em; color: #555; }
        .up-val { color: #0277bd; font-weight: bold; float: right; }
        .up-btn { width: 100%; padding: 12px; margin-top: 8px; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; color: white; transition: 0.2s; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .btn-upgrade { background: #43a047; } .btn-upgrade:hover { background: #2e7d32; }
        .btn-sell { background: #e53935; } .btn-sell:hover { background: #c62828; }
        .btn-close { background: #78909c; }

        #game-over {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none;
            justify-content: center; align-items: center; flex-direction: column;
            color: white; z-index: 999; pointer-events: auto; backdrop-filter: blur(5px);
        }
        h1 { margin: 0; font-size: 5em; color: #ffeb3b; text-shadow: 0 0 20px #ff6d00; text-transform: uppercase; letter-spacing: 5px; }
        
        .diff-tag {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255,255,255,0.9); color: #d50000;
            padding: 5px 15px; border-radius: 20px; font-size: 0.9em;
            pointer-events: auto; font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        #tower-destroyed-msg {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            color: red; font-weight: bold; font-size: 2em; text-shadow: 0 0 10px white;
            opacity: 0; pointer-events: none; transition: opacity 0.5s; z-index: 900;
        }
        
        .hp-bar-bg { width: 100%; height: 6px; background: #ddd; border-radius: 3px; margin-top: 5px; overflow: hidden; }
        .hp-bar-fill { height: 100%; background: #00e676; width: 100%; transition: width 0.2s; }
        
        .float-text {
            position: absolute; color: #ffd740; font-weight: bold; font-size: 1.5em; 
            text-shadow: 0 0 5px black; pointer-events: none; animation: floatUp 1s forwards;
        }
        @keyframes floatUp { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-50px); opacity: 0; } }
        
        /* Êö´ÂÅúÈÅÆÁΩ© */
        #pause-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.3); pointer-events: none; display: none;
            justify-content: center; align-items: center; color: white; font-size: 3em; font-weight: bold;
            text-shadow: 0 0 20px black; z-index: 800;
        }
    </style>
</head>
<body>

    <div class="diff-tag">Ê•µÈôêÂ°îÈò≤: È≠îÁéãÊé•ÂäõÊà∞ | Á®ÆÁî∞Ë≥∫Èå¢ | ÂèØÊö´ÂÅú</div>
    <div id="tower-destroyed-msg">‚ö†Ô∏è Â°îË¢´ÊëßÊØÄÔºÅ</div>
    <div id="pause-overlay">Â∑≤Êö´ÂÅú</div>

    <div id="ui-layer">
        <div id="top-bar">
            <div class="stat">‚ù§Ô∏è <span id="lives-txt">20</span></div>
            <div class="stat money">üí∞ <span id="money-txt">900</span></div>
            <div class="stat animals" style="margin-right:0;">üê∞ <span id="animals-txt">3</span></div>
            <div style="display:flex; align-items:center;">
                <button id="heal-btn" class="icon-btn" onclick="game.healAnimals()" title="Ëä±Ë≤ª $500 Ê≤ªÁôÇÊâÄÊúâÂ∞èÂãïÁâ©">‚úö</button>
                <span class="heal-cost">($500)</span>
            </div>
            
            <div class="stat" style="margin-left: 10px;">üåä <span id="wave-txt">1</span></div>
            <div class="stat">üëæ <span id="enemies-txt">0</span></div>
            <div style="flex:1;"></div>
            <button id="pause-btn" class="icon-btn" onclick="game.togglePause()" title="Êö´ÂÅúÈÅäÊà≤">‚è∏Ô∏è</button>
            <button id="bgm-toggle" class="icon-btn" onclick="AudioSys.toggleBGM()" title="ÈñãÈóúÈü≥Ê®Ç">üéµ</button>
        </div>

        <!-- ÂçáÁ¥öÈù¢Êùø -->
        <div id="upgrade-panel">
            <h2 style="margin:0 0 5px 0; color:#333; border-bottom:2px solid #ffcc80; padding-bottom:5px;" id="up-name">Â°îÂêçÁ®±</h2>
            <div style="font-size:0.8em; color:#666; margin-bottom:10px;">
                ËÄê‰πÖÂ∫¶: <span id="up-hp">500</span> / <span id="up-max-hp">500</span>
                <div class="hp-bar-bg"><div class="hp-bar-fill" id="up-hp-bar"></div></div>
            </div>
            <div class="up-info">
                Á≠âÁ¥ö: <span id="up-level" class="up-val">1</span><br>
                ÂÇ∑ÂÆ≥: <span id="up-dmg" class="up-val">10</span><br>
                Â∞ÑÁ®ã: <span id="up-range" class="up-val">10</span><br>
                ÊîªÈÄü: <span id="up-speed" class="up-val">ÊÖ¢</span>
            </div>
            <button class="up-btn btn-upgrade" id="btn-upgrade" onclick="game.upgradeTower()">ÂçáÁ¥ö ($50)</button>
            <button class="up-btn btn-sell" onclick="game.sellTower()">Ë≥£Âá∫ ($30)</button>
            <button class="up-btn btn-close" onclick="game.closePanel()">ÈóúÈñâ</button>
        </div>

        <div id="bottom-controls">
            <!-- Èò≤Á¶¶Â°îÂçÄ -->
            <div class="control-group">
                <div class="tower-card" onclick="game.selectBuildType('ARCHER')" id="btn-archer">
                    <div class="tower-icon" style="background: #fff9c4; color:#fbc02d;">üèπ</div>
                    <div class="tower-name">ÁÆ≠Â°î(Áü≠)</div>
                    <div class="tower-cost">$40</div>
                </div>
                <div class="tower-card" onclick="game.selectBuildType('ICE')" id="btn-ice">
                    <div class="tower-icon" style="background: #e1f5fe; color:#039be5;">‚ùÑÔ∏è</div>
                    <div class="tower-name">ÂÜ∞Â°î(Áü≠)</div>
                    <div class="tower-cost">$70</div>
                </div>
                <div class="tower-card" onclick="game.selectBuildType('FIRE')" id="btn-fire">
                    <div class="tower-icon" style="background: #ffebee; color:#e53935;">üî•</div>
                    <div class="tower-name">ÁÅ´Â°î(Ê•µÁü≠)</div>
                    <div class="tower-cost">$120</div>
                </div>
                <div class="tower-card" onclick="game.selectBuildType('LASER')" id="btn-laser">
                    <div class="tower-icon" style="background: #f3e5f5; color:#8e24aa;">‚ö°</div>
                    <div class="tower-name">Èõ∑Â∞Ñ(ÂÖ®)</div>
                    <div class="tower-cost">$540</div>
                </div>
            </div>

            <!-- Ëæ≤ËÄïÂçÄ -->
            <div class="control-group" style="background: rgba(220, 255, 220, 0.6);">
                <div class="tower-card farm" onclick="game.selectBuildType('FRUIT')" id="btn-fruit">
                    <div class="tower-icon" style="background: #ffcdd2; color:#d50000;">üçé</div>
                    <div class="tower-name">Ê∞¥Êûú(Âø´)</div>
                    <div class="tower-cost">$50</div>
                </div>
                <div class="tower-card farm" onclick="game.selectBuildType('VEGGIE')" id="btn-veggie">
                    <div class="tower-icon" style="background: #c8e6c9; color:#2e7d32;">üéÉ</div>
                    <div class="tower-name">Ëî¨Ëèú(ÊÖ¢)</div>
                    <div class="tower-cost">$80</div>
                </div>
            </div>

            <button id="next-wave-btn" class="action-btn" onclick="game.nextWave()">üëπ ËøéÊà∞</button>
        </div>
    </div>

    <div id="game-over">
        <h1 id="go-title">GAME OVER</h1>
        <p style="font-size: 1.5em; color:#fff;" id="go-reason">ÊúÄÁµÇÊ≥¢Ê¨°: <span id="final-wave" style="color:#ffeb3b; font-weight:bold;">0</span></p>
        <button class="action-btn" onclick="location.reload()">ÈáçÊñ∞ÊåëÊà∞</button>
    </div>

    <script>
        const AudioSys = {
            ctx: new (window.AudioContext || window.webkitAudioContext)(),
            bgmInterval: null,
            isBgmMuted: true, 
            bgmNoteIdx: 0,
            
            play(type, freq, dur, vol=0.1, type2='sine') {
                if(this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if(type2 === 'slide') {
                    osc.frequency.exponentialRampToValueAtTime(freq/2, this.ctx.currentTime + dur);
                }
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + dur);
            },
            
            shoot() { this.play('square', 800, 0.1, 0.05, 'slide'); },
            laser() { this.play('sawtooth', 1200, 0.15, 0.05, 'slide'); },
            build() { this.play('sine', 600, 0.1, 0.1); },
            boom() { this.play('sawtooth', 100, 0.3, 0.15); },
            error() { this.play('triangle', 150, 0.2, 0.1); },
            animalDie() { this.play('sawtooth', 50, 0.8, 0.2); },
            enemyShoot() { this.play('square', 400, 0.1, 0.05); }, 
            towerDestroy() { this.play('sawtooth', 80, 0.5, 0.3); }, 
            heal() { this.play('sine', 400, 0.1, 0.1); setTimeout(()=>this.play('sine', 600, 0.2, 0.1), 100); },
            harvest() { this.play('sine', 1000, 0.1, 0.1); setTimeout(()=>this.play('sine', 1500, 0.2, 0.1), 100); }, 

            toggleBGM() {
                this.isBgmMuted = !this.isBgmMuted;
                const btn = document.getElementById('bgm-toggle');
                if (!this.isBgmMuted) {
                    if (this.ctx.state === 'suspended') this.ctx.resume();
                    this.startBGM();
                    btn.classList.add('active');
                } else {
                    this.stopBGM();
                    btn.classList.remove('active');
                }
            },
            
            startBGM() {
                if (this.bgmInterval) return;
                const melody = [523,0,523,0,783,0,783,0,880,0,880,0,783,0,0,0,698,0,698,0,659,0,659,0,587,0,587,0,523,0,0,0];
                const bass = [261,261,392,392,440,440,392,392,349,349,329,329,293,293,261,261];
                const tempo = 160; 

                this.bgmInterval = setInterval(() => {
                    if (this.isBgmMuted) return;
                    const note = melody[this.bgmNoteIdx % melody.length];
                    if (note > 0) this.play('triangle', note, 0.1, 0.05, 'sine');
                    if (this.bgmNoteIdx % 4 === 0) {
                        const bassNote = bass[Math.floor((this.bgmNoteIdx % (bass.length*4)) / 4)];
                        this.play('sine', bassNote, 0.3, 0.08, 'sine');
                    }
                    this.bgmNoteIdx++;
                }, tempo);
            },

            stopBGM() {
                if (this.bgmInterval) {
                    clearInterval(this.bgmInterval);
                    this.bgmInterval = null;
                }
            }
        };

        const TILE_SIZE = 5; 
        const GRID_W = 20;
        const GRID_H = 15;
        
        const PATH_WEST = [{x:0, z:2}, {x:5, z:2}, {x:5, z:10}, {x:12, z:10}, {x:12, z:12}, {x:18, z:12}];
        const PATH_NORTH = [{x:8, z:0}, {x:8, z:5}, {x:14, z:5}, {x:14, z:12}, {x:18, z:12}];
        const PATH_SOUTH = [{x:10, z:14}, {x:10, z:8}, {x:16, z:8}, {x:16, z:12}, {x:18, z:12}];
        const PATH_EAST = [{x:19, z:4}, {x:16, z:4}, {x:16, z:8}, {x:18, z:8}, {x:18, z:12}];

        const TOWER_DATA = {
            ARCHER: { cost: 40, range: 3.5, damage: 8, rate: 40, color: 0xfdd835, name: "ÁÆ≠Â°î", type:'proj' },
            ICE:    { cost: 70, range: 3, damage: 4,  rate: 45, color: 0x4fc3f7, name: "ÂÜ∞Â°î", type:'proj' },
            FIRE:   { cost: 120, range: 2.5, damage: 15, rate: 70, color: 0xff7043, name: "ÁÅ´Â°î", type:'aoe' },
            LASER:  { cost: 540, range: 16, damage: 2, rate: 0,   color: 0xe040fb, name: "Èõ∑Â∞ÑÂ°î", type:'laser' } 
        };

        const FARM_DATA = {
            FRUIT: { cost: 50, growTime: 300, sell: 120, name: "Ê∞¥ÊûúÊ®π", color: 0xff5252, type: 'farm' }, 
            VEGGIE: { cost: 80, growTime: 900, sell: 300, name: "Â§ßÂçóÁìú", color: 0xff9800, type: 'farm' } 
        };

        class Game3D {
            constructor() {
                this.lives = 20;
                this.money = 900; 
                this.wave = 1;
                this.enemies = [];
                this.towers = [];
                this.plants = []; 
                this.projectiles = [];
                this.particles = [];
                this.animals = []; 
                this.decorations = [];
                this.waveActive = false;
                this.spawnQueue = [];
                this.clock = new THREE.Clock();
                this.isPaused = false; // Êö´ÂÅúÁãÄÊÖã
                this.bossesRemainingInWave = 0; // Áï∂ÂâçÊ≥¢Ê¨°Ââ©È§òÊú™Âá∫Â†¥ÁöÑÈ≠îÁéãÊï∏

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x4fc3f7); 
                this.scene.fog = new THREE.Fog(0x4fc3f7, 60, 200);

                const aspect = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 500);
                this.camera.position.set(GRID_W * TILE_SIZE / 2, 80, 80); 
                this.camera.lookAt(GRID_W * TILE_SIZE / 2, 0, GRID_H * TILE_SIZE / 2);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
                dirLight.position.set(50, 100, 50);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                this.scene.add(dirLight);
                const spotLight = new THREE.SpotLight(0xffeb3b, 0.4);
                spotLight.position.set(0, 50, 0);
                this.scene.add(spotLight);

                this.grid = []; 
                this.createMap();
                this.createDecorations(); 
                this.initAnimals();       

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.buildType = null; 
                this.selectedTower = null;
                
                this.ghostMesh = new THREE.Group();
                const gBox = new THREE.Mesh(
                    new THREE.BoxGeometry(TILE_SIZE*0.8, TILE_SIZE, TILE_SIZE*0.8),
                    new THREE.MeshBasicMaterial({ color: 0x76ff03, transparent: true, opacity: 0.5 })
                );
                this.ghostMesh.add(gBox);
                this.ghostMesh.visible = false;
                this.scene.add(this.ghostMesh);

                this.rangeCircle = new THREE.Mesh(
                    new THREE.RingGeometry(0.1, 0.2, 64),
                    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
                );
                this.rangeCircle.rotation.x = -Math.PI / 2;
                this.rangeCircle.visible = false;
                this.scene.add(this.rangeCircle);

                window.addEventListener('resize', () => this.onResize());
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mousedown', (e) => this.onClick(e));
                window.addEventListener('click', () => { if (AudioSys.isBgmMuted) AudioSys.toggleBGM(); }, { once: true });

                this.updateUI();
                this.animate();
            }

            // Êñ∞Â¢ûÔºöÂàáÊèõÊö´ÂÅú
            togglePause() {
                this.isPaused = !this.isPaused;
                const btn = document.getElementById('pause-btn');
                const overlay = document.getElementById('pause-overlay');
                if (this.isPaused) {
                    btn.classList.add('paused');
                    btn.innerText = "‚ñ∂";
                    overlay.style.display = "flex";
                } else {
                    btn.classList.remove('paused');
                    btn.innerText = "‚è∏Ô∏è";
                    overlay.style.display = "none";
                }
            }

            createMap() {
                const floorGeo = new THREE.PlaneGeometry(GRID_W * TILE_SIZE * 2, GRID_H * TILE_SIZE * 2);
                const floorMat = new THREE.MeshLambertMaterial({ color: 0x8bc34a }); 
                const floor = new THREE.Mesh(floorGeo, floorMat);
                floor.rotation.x = -Math.PI / 2;
                floor.position.set(GRID_W*TILE_SIZE/2 - TILE_SIZE/2, -0.2, GRID_H*TILE_SIZE/2 - TILE_SIZE/2);
                floor.receiveShadow = true;
                this.scene.add(floor);

                const matEmpty = new THREE.MeshLambertMaterial({ color: 0xc5e1a5 });
                const matPath = new THREE.MeshLambertMaterial({ color: 0xffe0b2 });
                
                for(let x=0; x<GRID_W; x++) {
                    this.grid[x] = [];
                    for(let z=0; z<GRID_H; z++) {
                        let type = 0; 
                        if (this.isPointOnPath(x, z, PATH_WEST) || this.isPointOnPath(x, z, PATH_NORTH) ||
                            this.isPointOnPath(x, z, PATH_SOUTH) || this.isPointOnPath(x, z, PATH_EAST)) {
                            type = 1;
                        }
                        const h = type === 1 ? 0.2 : 0.5;
                        const geo = new THREE.BoxGeometry(TILE_SIZE * 0.95, h, TILE_SIZE * 0.95);
                        const mat = type === 1 ? matPath : matEmpty;
                        const tile = new THREE.Mesh(geo, mat);
                        tile.position.set(x * TILE_SIZE, h/2, z * TILE_SIZE);
                        tile.receiveShadow = true;
                        tile.castShadow = true;
                        this.scene.add(tile);
                        this.grid[x][z] = { type: type, mesh: tile, tower: null, plant: null, x:x, z:z };
                    }
                }

                const endP = {x: 18, z: 12};
                const endBase = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 4, 8), new THREE.MeshPhongMaterial({color: 0xd32f2f}));
                endBase.position.set(endP.x * TILE_SIZE, 2, endP.z * TILE_SIZE);
                endBase.castShadow = true;
                this.scene.add(endBase);
                
                const startPoints = [PATH_WEST[0], PATH_NORTH[0], PATH_SOUTH[0], PATH_EAST[0]];
                startPoints.forEach(start => {
                    const startM = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 4), new THREE.MeshLambertMaterial({color: 0x76ff03}));
                    startM.position.set(start.x * TILE_SIZE, 0.5, start.z * TILE_SIZE);
                    this.scene.add(startM);
                });
            }

            createDecorations() {
                const trunkMat = new THREE.MeshLambertMaterial({color: 0x795548});
                const leavesMat = new THREE.MeshLambertMaterial({color: 0x43a047});
                const flowerColors = [0xffeb3b, 0xe91e63, 0x9c27b0, 0xffffff];

                for(let x=0; x<GRID_W; x++) {
                    for(let z=0; z<GRID_H; z++) {
                        if (this.grid[x][z].type === 0 && Math.random() > 0.7) {
                            const posX = x * TILE_SIZE;
                            const posZ = z * TILE_SIZE;
                            const rand = Math.random();
                            if (rand > 0.6) {
                                const tree = new THREE.Group();
                                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 2), trunkMat);
                                trunk.position.y = 1; trunk.castShadow = true;
                                const leaves = new THREE.Mesh(new THREE.ConeGeometry(2, 4, 8), leavesMat);
                                leaves.position.y = 3.5; leaves.castShadow = true;
                                tree.add(trunk, leaves);
                                const s = 0.8 + Math.random() * 0.4;
                                tree.scale.set(s, s, s);
                                tree.rotation.y = Math.random() * Math.PI;
                                tree.position.set(posX, 0.5, posZ);
                                this.scene.add(tree);
                                this.decorations.push(tree);
                                this.grid[x][z].hasDecoration = true;
                            } else {
                                const flower = new THREE.Group();
                                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1), leavesMat);
                                stem.position.y = 0.5;
                                const petalColor = flowerColors[Math.floor(Math.random()*flowerColors.length)];
                                const petal = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4), new THREE.MeshBasicMaterial({color: petalColor}));
                                petal.position.y = 1;
                                flower.add(stem, petal);
                                flower.position.set(posX + (Math.random()-0.5)*2, 0.5, posZ + (Math.random()-0.5)*2);
                                this.scene.add(flower);
                                this.decorations.push(flower);
                            }
                        }
                    }
                }
            }

            initAnimals() {
                const animalLocs = [PATH_WEST[2], PATH_NORTH[2], PATH_SOUTH[2]];
                animalLocs.forEach(loc => {
                    const animal = new Animal(loc.x, loc.z);
                    this.scene.add(animal.mesh);
                    this.animals.push(animal);
                });
                document.getElementById('animals-txt').innerText = this.animals.length;
            }

            healAnimals() {
                const cost = 500;
                if (this.money >= cost && this.animals.length > 0) {
                    let healed = false;
                    this.animals.forEach(a => {
                        if (a.hp < a.hpMax) {
                            a.hp = Math.min(a.hpMax, a.hp + (a.hpMax * 0.5)); 
                            a.updateBar();
                            this.particles.push(new EffectParticle(a.mesh.position.x, 3, a.mesh.position.z, 0x00e676, 'burst'));
                            healed = true;
                        }
                    });

                    if (healed) {
                        this.money -= cost;
                        AudioSys.heal();
                        this.updateUI();
                    } else {
                        AudioSys.error();
                    }
                } else {
                    AudioSys.error();
                }
            }

            isPointOnPath(x, z, path) {
                for(let i=0; i<path.length-1; i++) {
                    let p1 = path[i];
                    let p2 = path[i+1];
                    if(p1.z === p2.z && z === p1.z) {
                        if(x >= Math.min(p1.x, p2.x) && x <= Math.max(p1.x, p2.x)) return true;
                    }
                    if(p1.x === p2.x && x === p1.x) {
                        if(z >= Math.min(p1.z, p2.z) && z <= Math.max(p1.z, p2.z)) return true;
                    }
                }
                return false;
            }

            nextWave() {
                if(this.waveActive) return;
                this.waveActive = true;
                document.getElementById('next-wave-btn').disabled = true;

                const activePaths = [PATH_WEST, PATH_NORTH, PATH_SOUTH, PATH_EAST];
                const groups = 8 + Math.floor(this.wave * 2); 
                const hpMult = Math.pow(1.5, this.wave - 1); 
                let spawnDelayBase = Math.max(10, 35 - (this.wave * 2));

                // 1. ‰∏ÄËà¨Â∞èÊÄ™ËàáÁÇ∏ÂΩàÂÆ¢ÁöÑÊéíÁ®ã
                for(let i=0; i<groups; i++) {
                    const baseDelay = i * spawnDelayBase;
                    for (let j = 0; j < 6; j++) {
                        let type = 'NORMAL';
                        const rand = Math.random();
                        if (this.wave >= 1 && rand > 0.5) type = 'FAST';
                        if (this.wave >= 2 && rand > 0.7) type = 'SHOOTER'; 
                        if (this.wave >= 3 && rand > 0.8) type = 'TANK';
                        if (this.wave >= 4 && Math.random() > 0.85) type = 'FLYING';

                        let path = activePaths[j % 4]; 
                        if (type === 'FLYING') path = activePaths[Math.floor(Math.random() * 4)];
                        this.spawnQueue.push({ type, hpMult, path, delay: baseDelay + (j * 3) });
                    }
                    // ÁÇ∏ÂΩàÂÆ¢Â∞èÈöä
                    if (this.wave >= 2 && Math.random() > 0.85) {
                        for(let b=0; b<4; b++) {
                             this.spawnQueue.push({ type: 'BOMBER', hpMult, path: activePaths[b % 4], delay: baseDelay + 15 + (b * 2) });
                        }
                    }
                }

                // 2. È≠îÁéãÊé•ÂäõÊ©üÂà∂ÔºöÂàùÂßãÂåñÈ≠îÁéãÊï∏ÈáèÔºå‰ΩÜÂè™ÂÖàÂè¨ÂñöÁ¨¨‰∏ÄÈöª
                this.bossesRemainingInWave = 1 + Math.floor(Math.random() * 4); // Êú¨Ê≥¢Á∏ΩÈ≠îÁéãÊï∏ 1-4
                this.spawnBossSequence(groups * spawnDelayBase); // Âú®Â∞èÊÄ™Â∑Æ‰∏çÂ§öÂá∫ÂÆåÂæåÈñãÂßãÂá∫È≠îÁéã
            }

            // Êñ∞Â¢ûÔºöÂè¨ÂñöÂñÆ‰∏ÄÈ≠îÁéãÂèäÂÖ∂Ë≠∑Ë°õ
            spawnBossSequence(baseDelay = 0) {
                if (this.bossesRemainingInWave <= 0) return;
                
                this.bossesRemainingInWave--; // Êâ£Èô§‰∏ÄÈöªÂæÖÂëΩÈ≠îÁéã
                
                const activePaths = [PATH_WEST, PATH_NORTH, PATH_SOUTH, PATH_EAST];
                const bossPath = activePaths[Math.floor(Math.random() * 4)]; // Èö®Ê©üË∑ØÂè£
                const hpMult = Math.pow(1.5, this.wave - 1);

                // È≠îÁéãÊú¨È´î
                this.spawnQueue.push({ type: 'BOSS', hpMult, path: bossPath, delay: baseDelay });
                
                // Ë≠∑Ë°õÈöä (Ë∑üÈö®È≠îÁéã)
                this.spawnQueue.push({ type: 'BOMBER', hpMult, path: bossPath, delay: baseDelay + 5 });
                this.spawnQueue.push({ type: 'BOMBER', hpMult, path: bossPath, delay: baseDelay + 8 });
                this.spawnQueue.push({ type: 'SHOOTER', hpMult, path: bossPath, delay: baseDelay + 12 });
                this.spawnQueue.push({ type: 'SHOOTER', hpMult, path: bossPath, delay: baseDelay + 15 });
            }

            spawnEnemy() {
                if(this.spawnQueue.length === 0) return;
                const next = this.spawnQueue[0];
                if(next.delay > 0) {
                    next.delay--;
                    return;
                }
                this.spawnQueue.shift();
                const enemy = new Enemy(next.type, next.hpMult, next.path);
                this.enemies.push(enemy);
                this.scene.add(enemy.mesh);
            }

            update() {
                // --- Êö´ÂÅúÈÇèËºØ ---
                if (this.isPaused) {
                    this.renderer.render(this.scene, this.camera); // ‰øùÊåÅÊ∏≤ÊüìÔºå‰∏çÊõ¥Êñ∞ÈÇèËºØ
                    return; 
                }

                if (this.lives <= 0) return;

                if (this.waveActive) {
                    this.spawnEnemy();
                    if (this.spawnQueue.length === 0 && this.enemies.length === 0 && this.bossesRemainingInWave === 0) {
                        this.endWave();
                    }
                }

                this.animals.forEach(a => a.update());

                // Ê§çÁâ©ÁîüÈï∑ÈÇèËºØ
                for (let i = this.plants.length - 1; i >= 0; i--) {
                    this.plants[i].update();
                }

                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const e = this.enemies[i];
                    const status = e.update(this.animals, this.towers); 
                    
                    if (status === 'REACHED') {
                        this.lives--;
                        AudioSys.error();
                        this.removeEnemy(e);
                        this.camera.position.x += (Math.random()-0.5); 
                        setTimeout(()=>this.camera.position.x = GRID_W * TILE_SIZE / 2, 50);
                        if(this.lives <= 0) this.gameOver("Âü∫Âú∞Ë¢´ÊëßÊØÄ");
                    }
                }

                this.towers.forEach(t => t.update(this.enemies));

                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const p = this.projectiles[i];
                    if (!p.active) {
                        this.scene.remove(p.mesh);
                        this.projectiles.splice(i, 1);
                    } else {
                        p.update();
                    }
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    if(!this.particles[i].update()) {
                        this.scene.remove(this.particles[i].mesh);
                        this.particles.splice(i, 1);
                    }
                }

                this.updateUI();
            }

            endWave() {
                this.waveActive = false;
                this.wave++;
                this.money += 200 + (this.wave * 30); 
                document.getElementById('next-wave-btn').disabled = false;
                AudioSys.build();
            }

            removeEnemy(e) {
                // Â¶ÇÊûúÊ≠ªÊéâÁöÑÊòØÈ≠îÁéãÔºå‰∏îÈÇÑÊúâÈ≠îÁéãÊ≤íÂá∫‰æÜÔºåÊéíÁ®ã‰∏ã‰∏ÄÈöª
                if (e.type === 'BOSS' && this.bossesRemainingInWave > 0) {
                    this.spawnBossSequence(100); // 100ÂπÄ (Á¥Ñ1.5Áßí) ÂæåÂá∫Áèæ‰∏ã‰∏ÄÈöª
                }

                this.scene.remove(e.mesh);
                e.dispose();
                const idx = this.enemies.indexOf(e);
                if (idx > -1) this.enemies.splice(idx, 1);
            }
            
            removeAnimal(a) {
                this.scene.remove(a.mesh);
                const idx = this.animals.indexOf(a);
                if (idx > -1) this.animals.splice(idx, 1);
                document.getElementById('animals-txt').innerText = this.animals.length;
                AudioSys.animalDie();
                this.gameOver("Â∞èÂãïÁâ©Ë¢´ÊÆ∫Ê≠ª‰∫ÜÔºÅÊàëÂÄëÊ≤íËÉΩ‰øùË≠∑ÂÆÉ...");
            }

            removeTower(t) {
                this.scene.remove(t.mesh);
                this.grid[t.gx][t.gz].tower = null;
                const idx = this.towers.indexOf(t);
                if (idx > -1) this.towers.splice(idx, 1);
                
                game.particles.push(new EffectParticle(t.mesh.position.x, 2, t.mesh.position.z, 0xff0000, 'explode', 2));
                AudioSys.towerDestroy();
                
                const msg = document.getElementById('tower-destroyed-msg');
                msg.style.opacity = 1;
                setTimeout(() => msg.style.opacity = 0, 1500);
                if(this.selectedTower === t) this.closePanel();
            }

            selectBuildType(type) {
                document.querySelectorAll('.tower-card').forEach(el => el.classList.remove('active'));
                
                if (type === null || this.buildType === type) {
                    this.buildType = null;
                    this.ghostMesh.visible = false;
                    this.rangeCircle.visible = false;
                    return;
                }
                
                this.buildType = type;
                document.getElementById(
                    type === 'FRUIT' ? 'btn-fruit' : 
                    type === 'VEGGIE' ? 'btn-veggie' : 
                    `btn-${type.toLowerCase()}`
                ).classList.add('active');
                
                this.closePanel();
                
                // Âà§Êñ∑ÊòØËæ≤‰ΩúÁâ©ÈÇÑÊòØÈò≤Á¶¶Â°î
                const isFarm = FARM_DATA[type] !== undefined;
                if (!isFarm) {
                    this.rangeCircle.visible = true;
                    const data = TOWER_DATA[type];
                    this.rangeCircle.geometry = new THREE.RingGeometry(data.range * TILE_SIZE - 0.5, data.range * TILE_SIZE, 64);
                } else {
                    this.rangeCircle.visible = false;
                }
            }

            getGridPos(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const target = new THREE.Vector3();
                this.raycaster.ray.intersectPlane(plane, target);
                if (target) {
                    const gx = Math.round(target.x / TILE_SIZE);
                    const gz = Math.round(target.z / TILE_SIZE);
                    return { x: gx, z: gz, worldX: gx * TILE_SIZE, worldZ: gz * TILE_SIZE };
                }
                return null;
            }

            onMouseMove(e) {
                const pos = this.getGridPos(e);
                if (pos && pos.x >= 0 && pos.x < GRID_W && pos.z >= 0 && pos.z < GRID_H) {
                    if (this.buildType) {
                        this.ghostMesh.position.set(pos.worldX, 1, pos.worldZ);
                        this.ghostMesh.visible = true;
                        const cell = this.grid[pos.x][pos.z];
                        // Ê™¢Êü•ÔºöÁ©∫Âú∞„ÄÅÁÑ°Â°î„ÄÅÁÑ°Ê§çÁâ©„ÄÅÁÑ°Ë£ùÈ£æ
                        const canBuild = cell.type === 0 && cell.tower === null && cell.plant === null && !cell.hasDecoration;
                        this.ghostMesh.children[0].material.color.setHex(canBuild ? 0x76ff03 : 0xff1744);
                        
                        if (TOWER_DATA[this.buildType]) {
                            this.rangeCircle.position.set(pos.worldX, 1, pos.worldZ);
                        }
                    }
                } else {
                    this.ghostMesh.visible = false;
                }
            }

            onClick(e) {
                if (e.target.closest('button') || e.target.closest('.tower-card')) return;

                const pos = this.getGridPos(e);
                if (!pos || pos.x < 0 || pos.x >= GRID_W || pos.z < 0 || pos.z >= GRID_H) return;
                const cell = this.grid[pos.x][pos.z];

                if (this.buildType) {
                    if (cell.type === 0 && cell.tower === null && cell.plant === null && !cell.hasDecoration) {
                        if (FARM_DATA[this.buildType]) {
                            // Á®ÆÊ§ç
                            if (this.money >= FARM_DATA[this.buildType].cost) {
                                this.buildPlant(pos.x, pos.z, this.buildType);
                            } else {
                                AudioSys.error();
                            }
                        } else {
                            // ËìãÂ°î
                            if (this.money >= TOWER_DATA[this.buildType].cost) {
                                this.buildTower(pos.x, pos.z, this.buildType);
                            } else {
                                AudioSys.error();
                            }
                        }
                    }
                } else {
                    // Êî∂Êàê
                    if (cell.plant) {
                        cell.plant.tryHarvest();
                    } else if (cell.tower) {
                        this.selectTower(cell.tower);
                    } else {
                        this.closePanel();
                    }
                }
            }

            buildTower(gx, gz, type) {
                this.money -= TOWER_DATA[type].cost;
                const t = new Tower(gx, gz, type);
                this.scene.add(t.mesh);
                this.towers.push(t);
                this.grid[gx][gz].tower = t;
                AudioSys.build();
                this.particles.push(new EffectParticle(t.mesh.position.x, 2, t.mesh.position.z, 0xffffff, 'burst'));
                this.selectBuildType(null);
                this.updateUI();
            }

            buildPlant(gx, gz, type) {
                this.money -= FARM_DATA[type].cost;
                const p = new Plant(gx, gz, type);
                this.scene.add(p.mesh);
                this.plants.push(p);
                this.grid[gx][gz].plant = p;
                AudioSys.build(); // ÊåñÂúüËÅ≤
                this.particles.push(new EffectParticle(p.mesh.position.x, 1, p.mesh.position.z, 0x8d6e63, 'burst')); // Ê≥•ÂúüÁâπÊïà
                this.selectBuildType(null);
                this.updateUI();
            }

            selectTower(tower) {
                this.selectedTower = tower;
                this.rangeCircle.visible = true;
                this.rangeCircle.position.set(tower.mesh.position.x, 1, tower.mesh.position.z);
                const r = tower.getRange() * TILE_SIZE;
                this.rangeCircle.geometry = new THREE.RingGeometry(r-0.5, r, 64);
                const p = document.getElementById('upgrade-panel');
                p.style.display = 'block';
                document.getElementById('up-name').innerText = TOWER_DATA[tower.type].name;
                this.updatePanelInfo();
            }

            updatePanelInfo() {
                if (!this.selectedTower) return;
                const t = this.selectedTower;
                const cost = Math.floor(TOWER_DATA[t.type].cost * 1.5 * t.level);
                document.getElementById('up-level').innerText = t.level;
                document.getElementById('up-dmg').innerText = (t.getDamage()).toFixed(1);
                document.getElementById('up-range').innerText = t.getRange();
                document.getElementById('btn-upgrade').innerText = `ÂçáÁ¥ö ($${cost})`;
                document.getElementById('btn-upgrade').disabled = this.money < cost;
                
                document.getElementById('up-hp').innerText = Math.floor(t.hp);
                document.getElementById('up-max-hp').innerText = t.maxHp;
                document.getElementById('up-hp-bar').style.width = (t.hp / t.maxHp * 100) + '%';
            }

            upgradeTower() {
                if(!this.selectedTower) return;
                const t = this.selectedTower;
                const cost = Math.floor(TOWER_DATA[t.type].cost * 1.5 * t.level);
                if (this.money >= cost) {
                    this.money -= cost;
                    t.upgrade();
                    AudioSys.build();
                    this.particles.push(new EffectParticle(t.mesh.position.x, 4, t.mesh.position.z, 0xffff00, 'burst'));
                    this.updatePanelInfo();
                    this.updateUI();
                }
            }

            sellTower() {
                if(!this.selectedTower) return;
                const t = this.selectedTower;
                const val = Math.floor(TOWER_DATA[t.type].cost * 0.4 * t.level);
                this.money += val;
                this.scene.remove(t.mesh);
                this.grid[t.gx][t.gz].tower = null;
                this.towers = this.towers.filter(x => x !== t);
                AudioSys.build();
                this.closePanel();
                this.updateUI();
            }

            closePanel() {
                this.selectedTower = null;
                document.getElementById('upgrade-panel').style.display = 'none';
                if (!this.buildType) this.rangeCircle.visible = false;
            }

            updateUI() {
                document.getElementById('lives-txt').innerText = this.lives;
                document.getElementById('money-txt').innerText = this.money;
                document.getElementById('wave-txt').innerText = this.wave;
                document.getElementById('enemies-txt').innerText = this.spawnQueue.length + this.enemies.length;
                if(this.selectedTower) this.updatePanelInfo();
            }

            gameOver(reason) {
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('go-title').innerText = "GAME OVER";
                document.getElementById('go-reason').innerHTML = `${reason}<br>ÊúÄÁµÇÊ≥¢Ê¨°: <span style="color:#ffeb3b">${this.wave}</span>`;
                this.renderer.setAnimationLoop(null);
                AudioSys.stopBGM();
            }

            onResize() {
                const aspect = window.innerWidth / window.innerHeight;
                this.camera.aspect = aspect;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                this.renderer.setAnimationLoop(() => {
                    this.update();
                    this.renderer.render(this.scene, this.camera);
                });
            }
        }

        // ==========================================
        // Ê§çÁâ©È°ûÂà•
        // ==========================================
        class Plant {
            constructor(gx, gz, type) {
                this.gx = gx; this.gz = gz; this.type = type;
                this.data = FARM_DATA[type];
                this.growth = 0; // 0 to 1
                this.maxGrowth = this.data.growTime;
                
                this.mesh = new THREE.Group();
                this.mesh.position.set(gx * TILE_SIZE, 0, gz * TILE_SIZE);

                // ÂπºËãó (ÈÄöÁî®)
                const sprout = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1, 8), new THREE.MeshLambertMaterial({color: 0x8bc34a}));
                sprout.position.y = 0.5;
                this.mesh.add(sprout);
                this.visual = sprout; // ÂºïÁî®Áï∂ÂâçË¶ñË¶∫Ê®°Âûã

                // ÊàêÁÜüÊ®°Âûã (Èö±Ëóè)
                if (type === 'FRUIT') {
                    // ÊûúÊ®π
                    this.matureMesh = new THREE.Group();
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 1.5), new THREE.MeshLambertMaterial({color: 0x795548}));
                    trunk.position.y = 0.75;
                    const leaves = new THREE.Mesh(new THREE.IcosahedronGeometry(1.5), new THREE.MeshLambertMaterial({color: 0x4caf50}));
                    leaves.position.y = 2.5;
                    // Á¥ÖËâ≤ÊûúÂØ¶
                    const f1 = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:0xff1744})); f1.position.set(0.8, 2.5, 0.5);
                    const f2 = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:0xff1744})); f2.position.set(-0.7, 3.0, -0.4);
                    const f3 = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:0xff1744})); f3.position.set(0.2, 2.2, -0.9);
                    this.matureMesh.add(trunk, leaves, f1, f2, f3);
                } else {
                    // Â§ßÂçóÁìú
                    this.matureMesh = new THREE.Group();
                    const pumpkin = new THREE.Mesh(new THREE.SphereGeometry(1.5, 12, 8), new THREE.MeshLambertMaterial({color: 0xff9800}));
                    pumpkin.scale.y = 0.7; pumpkin.position.y = 1;
                    const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.5), new THREE.MeshLambertMaterial({color: 0x388e3c}));
                    stem.position.y = 1.8;
                    this.matureMesh.add(pumpkin, stem);
                }
                this.matureMesh.visible = false;
                this.matureMesh.scale.set(0.1, 0.1, 0.1);
                this.mesh.add(this.matureMesh);
            }

            update() {
                if (this.growth < this.maxGrowth) {
                    this.growth++;
                    // ÊàêÈï∑ÂãïÁï´ÔºöÂπºËãóËÆäÂ§ß -> ÂàáÊèõÊ®°Âûã
                    const progress = this.growth / this.maxGrowth;
                    
                    if (progress < 0.5) {
                        this.visual.scale.setScalar(1 + progress * 2);
                    } else if (!this.matureMesh.visible) {
                        this.visual.visible = false;
                        this.matureMesh.visible = true;
                    }

                    if (this.matureMesh.visible && progress < 1) {
                        const s = 0.1 + (progress - 0.5) * 2 * 0.9;
                        this.matureMesh.scale.set(s, s, s);
                    }
                } else {
                    // ÊàêÁÜüÂãïÁï´ (Ë∑≥Âãï)
                    const s = 1 + Math.sin(Date.now() * 0.005) * 0.1;
                    this.matureMesh.scale.set(s, s, s);
                    // ÁôºÂÖâÊèêÁ§∫
                    this.matureMesh.children.forEach(c => {
                        if(c.material.emissive) c.material.emissive.setHex(0x333333);
                    });
                }
            }

            tryHarvest() {
                if (this.growth >= this.maxGrowth) {
                    // Êî∂Êàê
                    game.money += this.data.sell;
                    AudioSys.harvest();
                    
                    // ÊµÆÂãïÊñáÂ≠ó
                    const text = document.createElement('div');
                    text.className = 'float-text';
                    text.innerText = `+$${this.data.sell}`;
                    // Â∞á 3D Â∫ßÊ®ôËΩâÁÇ∫ 2D Ëû¢ÂπïÂ∫ßÊ®ô
                    const vec = this.mesh.position.clone();
                    vec.y += 3;
                    vec.project(game.camera);
                    const x = (vec.x * .5 + .5) * window.innerWidth;
                    const y = (-(vec.y * .5) + .5) * window.innerHeight;
                    text.style.left = `${x}px`;
                    text.style.top = `${y}px`;
                    document.body.appendChild(text);
                    setTimeout(() => text.remove(), 1000);

                    // ÁßªÈô§Ê§çÁâ©
                    game.scene.remove(this.mesh);
                    game.grid[this.gx][this.gz].plant = null;
                    game.plants = game.plants.filter(p => p !== this);
                    game.particles.push(new EffectParticle(this.mesh.position.x, 2, this.mesh.position.z, 0xffd700, 'burst', 1.5));
                    
                    game.updateUI();
                } else {
                    // Êú™ÊàêÁÜüÊèêÁ§∫Èü≥
                    AudioSys.error();
                }
            }
        }

        // ==========================================
        // ÂÖ∂‰ªñÂØ¶È´îÈ°ûÂà• (ÂãïÁâ©„ÄÅÊïµ‰∫∫„ÄÅÂ°î„ÄÅÂ≠êÂΩà„ÄÅÁâπÊïà)
        // ==========================================
        
        class Animal {
            constructor(gx, gz) {
                this.hpMax = 200; this.hp = this.hpMax;
                this.mesh = new THREE.Group(); this.mesh.position.set(gx * TILE_SIZE, 0, gz * TILE_SIZE);
                const body = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 2), new THREE.MeshLambertMaterial({color: 0xffccbc})); 
                body.position.y = 0.75; body.castShadow = true;
                const earGeo = new THREE.BoxGeometry(0.5, 1, 0.5);
                const earL = new THREE.Mesh(earGeo, new THREE.MeshLambertMaterial({color: 0xffab91})); earL.position.set(-0.6, 1.8, 0);
                const earR = new THREE.Mesh(earGeo, new THREE.MeshLambertMaterial({color: 0xffab91})); earR.position.set(0.6, 1.8, 0);
                const nose = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.2), new THREE.MeshLambertMaterial({color: 0xff5722})); nose.position.set(0, 1, 1);
                this.mesh.add(body, earL, earR, nose);
                const barContainer = new THREE.Group();
                const bg = new THREE.Mesh(new THREE.PlaneGeometry(3.2, 0.6), new THREE.MeshBasicMaterial({color:0x000000}));
                const fg = new THREE.Mesh(new THREE.PlaneGeometry(3, 0.4), new THREE.MeshBasicMaterial({color:0x29b6f6})); 
                fg.position.z = 0.01; barContainer.add(bg, fg); barContainer.position.y = 3.5; this.hpBar = fg; this.mesh.add(barContainer);
                this.animOffset = Math.random() * 100;
                this.onBeforeRender = () => { barContainer.lookAt(game.camera.position); };
            }
            update() {
                const time = Date.now() * 0.005 + this.animOffset;
                this.mesh.children[0].position.y = 0.75 + Math.sin(time) * 0.1;
                this.mesh.children[0].rotation.y = Math.sin(time * 0.5) * 0.1;
            }
            updateBar() { const pct = Math.max(0, this.hp / this.hpMax); this.hpBar.scale.x = pct; }
            takeDamage(amt) { this.hp -= amt; this.updateBar(); if (this.hp <= 0) game.removeAnimal(this); }
        }

        class Enemy {
            constructor(type, hpMult, path) {
                this.type = type; this.path = path; this.pathIdx = 0;
                this.hpMax = 50 * hpMult; this.speed = 0.08; this.color = 0xffffff; this.reward = 15;
                this.isSlowed = 0; this.flyHeight = 0; this.attackCooldown = 0; this.damage = 4; 
                this.defense = Math.floor(game.wave * 0.8) + 1; this.attackRange = 3; 
                let geo;
                if (type === 'NORMAL') { geo = new THREE.DodecahedronGeometry(1.5); this.color = 0x5c6bc0; this.speed = 0.08; }
                else if (type === 'FAST') { geo = new THREE.ConeGeometry(1, 2.5, 8); this.color = 0xffca28; this.speed = 0.15; this.hpMax = 35 * hpMult; this.attackRange = 2; this.damage = 3; }
                else if (type === 'TANK') { geo = new THREE.BoxGeometry(2.5, 2.5, 2.5); this.color = 0x4e342e; this.speed = 0.04; this.hpMax = 150 * hpMult; this.reward = 40; this.damage = 10; this.defense += 3; this.attackRange = 5; }
                else if (type === 'SHOOTER') { geo = new THREE.CylinderGeometry(0.8, 0.8, 3, 8); this.color = 0x43a047; this.speed = 0.07; this.hpMax = 40 * hpMult; this.damage = 8; this.attackRange = 18; }
                else if (type === 'BOMBER') { geo = new THREE.IcosahedronGeometry(1.8, 1); this.color = 0x212121; this.speed = 0.05; this.hpMax = 80 * hpMult; this.attackRange = 6; this.defense += 5; this.reward = 50; }
                else if (type === 'FLYING') { geo = new THREE.CylinderGeometry(0.5, 1.5, 0.5, 6); this.color = 0xd81b60; this.speed = 0.1; this.hpMax = 40 * hpMult; this.flyHeight = 8; this.reward = 25; const startP = {x: 0, z: Math.random() * GRID_H}; this.customStart = new THREE.Vector3(startP.x * TILE_SIZE, this.flyHeight, startP.z * TILE_SIZE); const endP = {x: 18, z: 12}; this.customTarget = new THREE.Vector3(endP.x * TILE_SIZE, this.flyHeight, endP.z * TILE_SIZE); }
                else if (type === 'BOSS') { geo = new THREE.TorusKnotGeometry(1.5, 0.5, 64, 8); this.color = 0xffd700; this.speed = 0.03; this.hpMax = 50 * hpMult * 30; this.reward = 500; this.defense += 10; this.damage = 50; this.attackRange = 4; }
                this.hp = this.hpMax;
                this.mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: this.color })); this.mesh.castShadow = true;
                if (type === 'FLYING') { this.mesh.position.copy(this.customStart); this.mesh.lookAt(this.customTarget); }
                else { const start = this.path[0]; this.mesh.position.set(start.x * TILE_SIZE, 1.5, start.z * TILE_SIZE); }
                if (type === 'BOSS') { this.mesh.scale.set(1.5, 1.5, 1.5); this.mesh.position.y = 3; }
                const barContainer = new THREE.Group(); const bg = new THREE.Mesh(new THREE.PlaneGeometry(3.2, 0.6), new THREE.MeshBasicMaterial({color:0x000000})); const fg = new THREE.Mesh(new THREE.PlaneGeometry(3, 0.4), new THREE.MeshBasicMaterial({color:0x76ff03})); fg.position.z = 0.01; barContainer.add(bg, fg); barContainer.position.y = type === 'BOSS' ? 5 : 3; this.hpBar = fg; this.mesh.add(barContainer);
                this.onBeforeRender = () => { barContainer.lookAt(game.camera.position); };
            }
            update(animals, towers) {
                let currentSpeed = this.speed;
                if (this.isSlowed > 0) { currentSpeed *= 0.6; this.isSlowed--; this.mesh.material.emissive.setHex(0x00ffff); } else { this.mesh.material.emissive.setHex(0x000000); }
                if ((this.type === 'BOMBER' || this.type === 'BOSS') && towers.length > 0) {
                    for(let tower of towers) {
                        const dist = this.mesh.position.distanceTo(tower.mesh.position);
                        if (dist < this.attackRange * TILE_SIZE) {
                            if (this.attackCooldown <= 0) {
                                this.attackCooldown = 150; AudioSys.enemyShoot();
                                const bomb = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color:0x000000})); bomb.position.copy(this.mesh.position); bomb.position.y += 2; game.scene.add(bomb);
                                const targetPos = tower.mesh.position.clone(); let t = 0;
                                const animateBomb = setInterval(() => { t += 0.1; bomb.position.lerp(targetPos, 0.1); bomb.position.y += Math.sin(t * Math.PI) * 0.5; if (bomb.position.distanceTo(targetPos) < 1) { clearInterval(animateBomb); game.scene.remove(bomb); tower.takeDamage(999); } }, 50);
                            } else { this.attackCooldown--; } return 'ATTACKING_TOWER';
                        }
                    }
                }
                if (this.type !== 'FLYING' && animals.length > 0) {
                    for(let animal of animals) {
                        const dist = this.mesh.position.distanceTo(animal.mesh.position);
                        if (dist < this.attackRange * TILE_SIZE * 0.8) { 
                            if (this.attackCooldown <= 0) {
                                animal.takeDamage(this.damage); this.attackCooldown = 40; AudioSys.enemyShoot();
                                const laserGeo = new THREE.BufferGeometry().setFromPoints([this.mesh.position.clone().add(new THREE.Vector3(0,1,0)), animal.mesh.position.clone().add(new THREE.Vector3(0,1,0))]); const laser = new THREE.Line(laserGeo, new THREE.LineBasicMaterial({color: 0xff0000, linewidth: 2})); game.scene.add(laser); setTimeout(() => game.scene.remove(laser), 100); this.mesh.position.y += 0.5; setTimeout(() => this.mesh.position.y -= 0.5, 100);
                            } else { this.attackCooldown--; } return 'ATTACKING';
                        }
                    }
                }
                if (this.type === 'FLYING') {
                    const dir = new THREE.Vector3().subVectors(this.customTarget, this.mesh.position).normalize(); this.mesh.position.add(dir.multiplyScalar(currentSpeed * TILE_SIZE));
                    if (this.mesh.position.distanceTo(this.customTarget) < 1) return 'REACHED';
                } else {
                    const targetNode = this.path[this.pathIdx + 1]; if (!targetNode) return 'REACHED';
                    const tx = targetNode.x * TILE_SIZE; const tz = targetNode.z * TILE_SIZE;
                    const dx = tx - this.mesh.position.x; const dz = tz - this.mesh.position.z;
                    const dist = Math.sqrt(dx*dx + dz*dz); const moveDist = currentSpeed * TILE_SIZE;
                    if (dist < moveDist) { this.mesh.position.x = tx; this.mesh.position.z = tz; this.pathIdx++; if(this.path[this.pathIdx+1]) { this.mesh.lookAt(this.path[this.pathIdx+1].x * TILE_SIZE, 1.5, this.path[this.pathIdx+1].z * TILE_SIZE); } } else { this.mesh.position.x += (dx/dist) * moveDist; this.mesh.position.z += (dz/dist) * moveDist; }
                }
                this.mesh.children[0].lookAt(game.camera.position); return 'MOVING';
            }
            takeDamage(amt) {
                const actualDamage = Math.max(1, amt - this.defense); this.hp -= actualDamage; const pct = Math.max(0, this.hp / this.hpMax); this.hpBar.scale.x = pct; this.hpBar.material.color.setHex(pct > 0.5 ? 0x76ff03 : 0xff1744);
                const pColor = actualDamage < amt ? 0xaaaaaa : this.color; game.particles.push(new EffectParticle(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z, pColor, 'hit', 0.5));
                if (this.hp <= 0) { game.money += this.reward; game.removeEnemy(this); game.particles.push(new EffectParticle(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z, this.color, 'explode')); AudioSys.boom(); }
            }
            dispose() { this.mesh.geometry.dispose(); this.mesh.material.dispose(); }
        }

        class Tower {
            constructor(gx, gz, type) {
                this.gx = gx; this.gz = gz; this.type = type; this.level = 1; this.cooldown = 0; this.maxHp = 500; this.hp = this.maxHp; 
                const data = TOWER_DATA[type]; this.mesh = new THREE.Group(); this.mesh.position.set(gx * TILE_SIZE, 0, gz * TILE_SIZE);
                const baseGeo = new THREE.CylinderGeometry(2, 2.2, 1, 8); const baseMat = new THREE.MeshPhongMaterial({ color: 0x546e7a }); const base = new THREE.Mesh(baseGeo, baseMat); base.position.y = 0.5; base.castShadow = true; this.mesh.add(base);
                this.head = new THREE.Group(); this.head.position.y = 1; 
                let headMesh;
                if (type === 'ARCHER') { const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), new THREE.MeshPhongMaterial({color: data.color})); const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 3), new THREE.MeshPhongMaterial({color: 0x333})); barrel.rotation.x = Math.PI/2; barrel.position.z = 1.5; this.head.add(body, barrel); }
                else if (type === 'ICE') { const geo = new THREE.OctahedronGeometry(1.2); headMesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({color: data.color, transparent:true, opacity:0.8})); this.head.add(headMesh); this.animator = () => { headMesh.rotation.y += 0.05; headMesh.rotation.x += 0.02; }; }
                else if (type === 'FIRE') { const cone = new THREE.Mesh(new THREE.ConeGeometry(1.5, 3, 8, 1, true), new THREE.MeshPhongMaterial({color: data.color, side: THREE.DoubleSide})); cone.rotation.x = Math.PI/2; cone.position.z = 1; this.head.add(cone); }
                else if (type === 'LASER') { const sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshPhongMaterial({color: data.color, emissive: data.color, emissiveIntensity: 0.5})); this.head.add(sphere); const lens = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1), new THREE.MeshBasicMaterial({color: 0xffffff})); lens.rotation.x = Math.PI/2; lens.position.z = 1; this.head.add(lens); }
                this.mesh.add(this.head);
            }
            getRange() { return TOWER_DATA[this.type].range * (1 + 0.1*(this.level-1)); }
            getDamage() { return TOWER_DATA[this.type].damage * (1 + 0.4*(this.level-1)); }
            getRate() { return Math.max(5, TOWER_DATA[this.type].rate - (this.level * 2)); }
            takeDamage(amount) { this.hp -= amount; if(game.selectedTower === this) game.updatePanelInfo(); if (this.hp <= 0) game.removeTower(this); }
            update(enemies) {
                if (this.animator) this.animator();
                if (this.cooldown > 0) { this.cooldown--; if (this.type === 'LASER' && this.laserMesh) { this.laserMesh.material.opacity -= 0.1; if (this.laserMesh.material.opacity <= 0) { this.mesh.remove(this.laserMesh); this.laserMesh = null; } } return; }
                const range = this.getRange() * TILE_SIZE; let target = null; let minDist = range;
                for (let e of enemies) { const d = this.mesh.position.distanceTo(e.mesh.position); if (d <= range && d < minDist) { minDist = d; target = e; } }
                if (target) {
                    this.head.lookAt(target.mesh.position); const dmg = this.getDamage();
                    if (this.type === 'LASER') { target.takeDamage(dmg); this.createLaserBeam(target.mesh.position); this.cooldown = 10; AudioSys.laser(); }
                    else { game.projectiles.push(new Projectile(this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), target, this.type, dmg)); this.cooldown = this.getRate(); AudioSys.shoot(); }
                }
            }
            createLaserBeam(targetPos) { if (this.laserMesh) this.mesh.remove(this.laserMesh); const points = []; points.push(new THREE.Vector3(0, 2, 0)); const localTarget = this.mesh.worldToLocal(targetPos.clone()); points.push(localTarget); const geo = new THREE.BufferGeometry().setFromPoints(points); const mat = new THREE.LineBasicMaterial({ color: 0xff00ff, linewidth: 2, transparent: true, opacity: 1 }); this.laserMesh = new THREE.Line(geo, mat); this.mesh.add(this.laserMesh); }
            upgrade() { this.level++; const s = 1 + (this.level * 0.1); this.mesh.scale.set(s, s, s); this.maxHp += 500; this.hp = this.maxHp; }
        }

        class Projectile {
            constructor(startPos, target, type, damage) { this.pos = startPos; this.target = target; this.type = type; this.damage = damage; this.active = true; this.speed = type === 'ARCHER' ? 1.0 : 0.8; const color = TOWER_DATA[type].color; let geo = new THREE.SphereGeometry(0.3); if (type === 'ARCHER') geo = new THREE.BoxGeometry(0.2, 0.2, 0.8); this.mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: color })); this.mesh.position.copy(startPos); game.scene.add(this.mesh); this.lastTargetPos = target.mesh.position.clone(); }
            update() { let targetPos = this.lastTargetPos; if (game.enemies.includes(this.target)) { targetPos = this.target.mesh.position; this.lastTargetPos = targetPos.clone(); } const dir = new THREE.Vector3().subVectors(targetPos, this.mesh.position).normalize(); this.mesh.position.add(dir.multiplyScalar(this.speed * TILE_SIZE * 0.2)); this.mesh.lookAt(targetPos); if (this.mesh.position.distanceTo(targetPos) < 1.0) { this.hit(targetPos); } }
            hit(pos) { this.active = false; if (this.type === 'FIRE') { game.particles.push(new EffectParticle(pos.x, pos.y, pos.z, 0xff5722, 'explode', 2)); game.enemies.forEach(e => { if (e.mesh.position.distanceTo(pos) < 2.5 * TILE_SIZE) { e.takeDamage(this.damage); } }); } else if (this.type === 'ICE') { if (game.enemies.includes(this.target)) { this.target.takeDamage(this.damage); this.target.isSlowed = 60; } } else { if (game.enemies.includes(this.target)) { this.target.takeDamage(this.damage); } } }
        }

        class EffectParticle {
            constructor(x, y, z, color, type='burst', scale=1) { this.life = 1.0; this.mesh = new THREE.Group(); this.type = type; const count = type === 'explode' ? 8 : (type === 'hit' ? 2 : 4); for(let i=0; i<count; i++) { const size = (Math.random() * 0.4 + 0.1) * scale; const p = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), new THREE.MeshBasicMaterial({color: color})); p.userData.velocity = new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5+0.5, (Math.random()-0.5)*0.5); this.mesh.add(p); } this.mesh.position.set(x, y, z); game.scene.add(this.mesh); }
            update() { this.life -= 0.05; this.mesh.children.forEach(p => { p.position.add(p.userData.velocity); p.rotation.x += 0.1; p.userData.velocity.y -= 0.02; }); this.mesh.children.forEach(p => { if (p.material.opacity > 0) p.material.opacity = this.life; }); return this.life > 0; }
        }

        const game = new Game3D();

    </script>
</body>
</html>
