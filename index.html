<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ê•µÈôêÂ°îÈò≤ - ÊØÄÊªÖÂÄíÊï∏</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --accent: #d50000;
            --bg-ui: rgba(255, 255, 255, 0.9);
            --text-color: #333;
        }
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #87CEEB; color: var(--text-color); }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        #top-bar {
            display: flex; gap: 25px; background: var(--bg-ui); padding: 15px 30px;
            border-radius: 50px; pointer-events: auto; border-bottom: 4px solid var(--accent);
            align-self: center; font-weight: bold; font-size: 1.3em;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15); color: #444;
            position: relative;
        }
        .stat { display: flex; align-items: center; gap: 8px; }
        .stat span { color: #d32f2f; }
        .stat.money span { color: #f57f17; }
        .stat.animals span { color: #2979ff; }

        #bgm-toggle {
            background: #eee; border: none; border-radius: 50%; width: 40px; height: 40px;
            cursor: pointer; font-size: 1.2em; display: flex; justify-content: center; align-items: center;
            transition: background 0.2s; margin-left: 10px;
        }
        #bgm-toggle:hover { background: #ddd; }
        #bgm-toggle.active { background: #b2ff59; color: #33691e; }

        #bottom-controls {
            display: flex; justify-content: center; align-items: flex-end; gap: 15px;
            pointer-events: auto; margin-bottom: 20px;
        }

        .tower-card {
            background: var(--bg-ui); width: 100px; padding: 10px; border-radius: 15px;
            text-align: center; cursor: pointer; transition: all 0.2s; border: 3px solid #fff;
            position: relative; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .tower-card:hover { transform: translateY(-10px); border-color: var(--accent); }
        .tower-card.active { border-color: var(--accent); background: #ffebee; transform: translateY(-10px); }
        
        .tower-icon { 
            width: 50px; height: 50px; margin: 0 auto 5px; border-radius: 12px; 
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1); display: flex; 
            justify-content: center; align-items: center; font-size: 24px;
            border: 2px solid rgba(0,0,0,0.05);
        }
        .tower-cost { color: #e65100; font-weight: bold; font-size: 0.9em; }
        .tower-name { font-size: 0.8em; margin-bottom: 2px; color: #555; }

        .action-btn {
            background: linear-gradient(45deg, #d50000, #ff1744); color: white; border: none;
            padding: 15px 40px; border-radius: 50px; font-size: 1.2em; font-weight: bold;
            cursor: pointer; box-shadow: 0 5px 15px rgba(213, 0, 0, 0.4);
            transition: transform 0.1s; pointer-events: auto; height: 80px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        .action-btn:active { transform: scale(0.95); }
        .action-btn:disabled { background: #ccc; cursor: not-allowed; opacity: 0.7; box-shadow: none; }

        #upgrade-panel {
            position: absolute; right: 20px; top: 50%; transform: translateY(-50%);
            background: var(--bg-ui); padding: 20px; border-radius: 20px; width: 240px;
            pointer-events: auto; display: none; border: 2px solid #fff;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
        }
        .up-info { margin-bottom: 15px; line-height: 1.6; font-size: 0.95em; color: #555; }
        .up-val { color: #0277bd; font-weight: bold; float: right; }
        .up-btn { width: 100%; padding: 12px; margin-top: 8px; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; color: white; transition: 0.2s; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .btn-upgrade { background: #43a047; } .btn-upgrade:hover { background: #2e7d32; }
        .btn-sell { background: #e53935; } .btn-sell:hover { background: #c62828; }
        .btn-close { background: #78909c; }

        #game-over {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none;
            justify-content: center; align-items: center; flex-direction: column;
            color: white; z-index: 999; pointer-events: auto; backdrop-filter: blur(5px);
        }
        h1 { margin: 0; font-size: 5em; color: #ffeb3b; text-shadow: 0 0 20px #ff6d00; text-transform: uppercase; letter-spacing: 5px; }
        
        .diff-tag {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255,255,255,0.8); color: #d50000;
            padding: 5px 15px; border-radius: 20px; font-size: 0.9em;
            pointer-events: auto; font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        /* Â°îË¢´ÊëßÊØÄÁöÑÊèêÁ§∫ */
        #tower-destroyed-msg {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            color: red; font-weight: bold; font-size: 2em; text-shadow: 0 0 10px black;
            opacity: 0; pointer-events: none; transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div class="diff-tag">Ê•µÈôêÊ®°Âºè: ÊãÜÂ°îÁÇ∏ÂΩàÂÆ¢ | 18Ê†ºÁãôÊìäÊâã</div>
    <div id="tower-destroyed-msg">‚ö†Ô∏è Â°îË¢´ÊëßÊØÄÔºÅ</div>

    <div id="ui-layer">
        <div id="top-bar">
            <div class="stat">‚ù§Ô∏è <span id="lives-txt">20</span></div>
            <div class="stat money">üí∞ <span id="money-txt">150</span></div>
            <div class="stat animals">üê∞ ÂÄñÂ≠ò: <span id="animals-txt">3</span></div>
            <div class="stat">üåä Ê≥¢Ê¨°: <span id="wave-txt">1</span></div>
            <div class="stat">üëæ Êïµ‰∫∫: <span id="enemies-txt">0</span></div>
            <button id="bgm-toggle" onclick="AudioSys.toggleBGM()">üéµ</button>
        </div>

        <!-- ÂçáÁ¥öÈù¢Êùø -->
        <div id="upgrade-panel">
            <h2 style="margin:0 0 15px 0; color:#333; border-bottom:2px solid #ffcc80; padding-bottom:5px;" id="up-name">Â°îÂêçÁ®±</h2>
            <div class="up-info">
                Á≠âÁ¥ö: <span id="up-level" class="up-val">1</span><br>
                ÂÇ∑ÂÆ≥: <span id="up-dmg" class="up-val">10</span><br>
                Â∞ÑÁ®ã: <span id="up-range" class="up-val">10</span><br>
                ÊîªÈÄü: <span id="up-speed" class="up-val">ÊÖ¢</span>
            </div>
            <button class="up-btn btn-upgrade" id="btn-upgrade" onclick="game.upgradeTower()">ÂçáÁ¥ö ($50)</button>
            <button class="up-btn btn-sell" onclick="game.sellTower()">Ë≥£Âá∫ ($30)</button>
            <button class="up-btn btn-close" onclick="game.closePanel()">ÈóúÈñâ</button>
        </div>

        <div id="bottom-controls">
            <div class="tower-card" onclick="game.selectBuildType('ARCHER')" id="btn-archer">
                <div class="tower-icon" style="background: #fff9c4; color:#fbc02d;">üèπ</div>
                <div class="tower-name">ÁÆ≠Â°î (ÂñÆÈ´î)</div>
                <div class="tower-cost">$40</div>
            </div>
            <div class="tower-card" onclick="game.selectBuildType('ICE')" id="btn-ice">
                <div class="tower-icon" style="background: #e1f5fe; color:#039be5;">‚ùÑÔ∏è</div>
                <div class="tower-name">ÂÜ∞Â°î (Á∑©ÈÄü)</div>
                <div class="tower-cost">$70</div>
            </div>
            <div class="tower-card" onclick="game.selectBuildType('FIRE')" id="btn-fire">
                <div class="tower-icon" style="background: #ffebee; color:#e53935;">üî•</div>
                <div class="tower-name">ÁÅ´Â°î (ÁØÑÂúç)</div>
                <div class="tower-cost">$120</div>
            </div>
            <div class="tower-card" onclick="game.selectBuildType('LASER')" id="btn-laser">
                <div class="tower-icon" style="background: #f3e5f5; color:#8e24aa;">‚ö°</div>
                <div class="tower-name">Èõ∑Â∞Ñ (È´òÂÇ∑)</div>
                <div class="tower-cost">$180</div>
            </div>

            <button id="next-wave-btn" class="action-btn" onclick="game.nextWave()">‚öîÔ∏è ËøéÊà∞Âº∑Êïµ</button>
        </div>
    </div>

    <div id="game-over">
        <h1 id="go-title">GAME OVER</h1>
        <p style="font-size: 1.5em; color:#fff;" id="go-reason">ÊúÄÁµÇÊ≥¢Ê¨°: <span id="final-wave" style="color:#ffeb3b; font-weight:bold;">0</span></p>
        <button class="action-btn" onclick="location.reload()">ÈáçÊñ∞ÊåëÊà∞</button>
    </div>

    <script>
        const AudioSys = {
            ctx: new (window.AudioContext || window.webkitAudioContext)(),
            bgmInterval: null,
            isBgmMuted: true, 
            bgmNoteIdx: 0,
            
            play(type, freq, dur, vol=0.1, type2='sine') {
                if(this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if(type2 === 'slide') {
                    osc.frequency.exponentialRampToValueAtTime(freq/2, this.ctx.currentTime + dur);
                }
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + dur);
            },
            
            shoot() { this.play('square', 800, 0.1, 0.05, 'slide'); },
            laser() { this.play('sawtooth', 1200, 0.15, 0.05, 'slide'); },
            build() { this.play('sine', 600, 0.1, 0.1); },
            boom() { this.play('sawtooth', 100, 0.3, 0.15); },
            error() { this.play('triangle', 150, 0.2, 0.1); },
            animalDie() { this.play('sawtooth', 50, 0.8, 0.2); },
            enemyShoot() { this.play('square', 400, 0.1, 0.05); }, 
            towerDestroy() { this.play('sawtooth', 80, 0.5, 0.3); }, // Â°îË¢´ÊØÄÈü≥Êïà

            toggleBGM() {
                this.isBgmMuted = !this.isBgmMuted;
                const btn = document.getElementById('bgm-toggle');
                if (!this.isBgmMuted) {
                    if (this.ctx.state === 'suspended') this.ctx.resume();
                    this.startBGM();
                    btn.classList.add('active');
                } else {
                    this.stopBGM();
                    btn.classList.remove('active');
                }
            },
            
            startBGM() {
                if (this.bgmInterval) return;
                const melody = [523,0,523,0,783,0,783,0,880,0,880,0,783,0,0,0,698,0,698,0,659,0,659,0,587,0,587,0,523,0,0,0];
                const bass = [261,261,392,392,440,440,392,392,349,349,329,329,293,293,261,261];
                const tempo = 170; 

                this.bgmInterval = setInterval(() => {
                    if (this.isBgmMuted) return;
                    const note = melody[this.bgmNoteIdx % melody.length];
                    if (note > 0) this.play('triangle', note, 0.1, 0.05, 'sine');
                    if (this.bgmNoteIdx % 4 === 0) {
                        const bassNote = bass[Math.floor((this.bgmNoteIdx % (bass.length*4)) / 4)];
                        this.play('sine', bassNote, 0.3, 0.08, 'sine');
                    }
                    this.bgmNoteIdx++;
                }, tempo);
            },

            stopBGM() {
                if (this.bgmInterval) {
                    clearInterval(this.bgmInterval);
                    this.bgmInterval = null;
                }
            }
        };

        const TILE_SIZE = 5; 
        const GRID_W = 20;
        const GRID_H = 15;
        
        const PATH_WEST = [{x:0, z:2}, {x:5, z:2}, {x:5, z:10}, {x:12, z:10}, {x:12, z:12}, {x:18, z:12}];
        const PATH_NORTH = [{x:8, z:0}, {x:8, z:5}, {x:14, z:5}, {x:14, z:12}, {x:18, z:12}];
        const PATH_SOUTH = [{x:10, z:14}, {x:10, z:8}, {x:16, z:8}, {x:16, z:12}, {x:18, z:12}];
        const PATH_EAST = [{x:19, z:4}, {x:16, z:4}, {x:16, z:8}, {x:18, z:8}, {x:18, z:12}];

        const TOWER_DATA = {
            ARCHER: { cost: 40, range: 7, damage: 8, rate: 40, color: 0xfdd835, name: "ÁÆ≠Â°î", type:'proj' },
            ICE:    { cost: 70, range: 6, damage: 4,  rate: 45, color: 0x4fc3f7, name: "ÂÜ∞Â°î", type:'proj' },
            FIRE:   { cost: 120, range: 5, damage: 15, rate: 70, color: 0xff7043, name: "ÁÅ´Â°î", type:'aoe' },
            LASER:  { cost: 180, range: 16, damage: 2, rate: 0,   color: 0xe040fb, name: "Èõ∑Â∞ÑÂ°î", type:'laser' } 
        };

        class Game3D {
            constructor() {
                this.lives = 20;
                this.money = 150;
                this.wave = 1;
                this.enemies = [];
                this.towers = [];
                this.projectiles = [];
                this.particles = [];
                this.animals = []; 
                this.decorations = [];
                this.waveActive = false;
                this.spawnQueue = [];
                this.clock = new THREE.Clock();

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); 
                this.scene.fog = new THREE.Fog(0x87CEEB, 60, 200);

                const aspect = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 500);
                this.camera.position.set(GRID_W * TILE_SIZE / 2, 80, 80); 
                this.camera.lookAt(GRID_W * TILE_SIZE / 2, 0, GRID_H * TILE_SIZE / 2);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
                dirLight.position.set(50, 100, 50);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                this.scene.add(dirLight);
                const spotLight = new THREE.SpotLight(0xffe0b2, 0.4);
                spotLight.position.set(0, 50, 0);
                this.scene.add(spotLight);

                this.grid = []; 
                this.createMap();
                this.createDecorations(); 
                this.initAnimals();       

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.buildType = null;
                this.selectedTower = null;
                
                this.ghostMesh = new THREE.Group();
                const gBox = new THREE.Mesh(
                    new THREE.BoxGeometry(TILE_SIZE*0.8, TILE_SIZE, TILE_SIZE*0.8),
                    new THREE.MeshBasicMaterial({ color: 0x76ff03, transparent: true, opacity: 0.5 })
                );
                this.ghostMesh.add(gBox);
                this.ghostMesh.visible = false;
                this.scene.add(this.ghostMesh);

                this.rangeCircle = new THREE.Mesh(
                    new THREE.RingGeometry(0.1, 0.2, 64),
                    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
                );
                this.rangeCircle.rotation.x = -Math.PI / 2;
                this.rangeCircle.visible = false;
                this.scene.add(this.rangeCircle);

                window.addEventListener('resize', () => this.onResize());
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mousedown', (e) => this.onClick(e));
                window.addEventListener('click', () => { if (AudioSys.isBgmMuted) AudioSys.toggleBGM(); }, { once: true });

                this.updateUI();
                this.animate();
            }

            createMap() {
                const floorGeo = new THREE.PlaneGeometry(GRID_W * TILE_SIZE * 2, GRID_H * TILE_SIZE * 2);
                const floorMat = new THREE.MeshLambertMaterial({ color: 0x66bb6a });
                const floor = new THREE.Mesh(floorGeo, floorMat);
                floor.rotation.x = -Math.PI / 2;
                floor.position.set(GRID_W*TILE_SIZE/2 - TILE_SIZE/2, -0.2, GRID_H*TILE_SIZE/2 - TILE_SIZE/2);
                floor.receiveShadow = true;
                this.scene.add(floor);

                const matEmpty = new THREE.MeshLambertMaterial({ color: 0x81c784 });
                const matPath = new THREE.MeshLambertMaterial({ color: 0xffe0b2 });
                
                for(let x=0; x<GRID_W; x++) {
                    this.grid[x] = [];
                    for(let z=0; z<GRID_H; z++) {
                        let type = 0; 
                        if (this.isPointOnPath(x, z, PATH_WEST) || this.isPointOnPath(x, z, PATH_NORTH) ||
                            this.isPointOnPath(x, z, PATH_SOUTH) || this.isPointOnPath(x, z, PATH_EAST)) {
                            type = 1;
                        }
                        const h = type === 1 ? 0.2 : 0.5;
                        const geo = new THREE.BoxGeometry(TILE_SIZE * 0.95, h, TILE_SIZE * 0.95);
                        const mat = type === 1 ? matPath : matEmpty;
                        const tile = new THREE.Mesh(geo, mat);
                        tile.position.set(x * TILE_SIZE, h/2, z * TILE_SIZE);
                        tile.receiveShadow = true;
                        tile.castShadow = true;
                        this.scene.add(tile);
                        this.grid[x][z] = { type: type, mesh: tile, tower: null, x:x, z:z };
                    }
                }

                const endP = {x: 18, z: 12};
                const endBase = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 4, 8), new THREE.MeshPhongMaterial({color: 0xd32f2f}));
                endBase.position.set(endP.x * TILE_SIZE, 2, endP.z * TILE_SIZE);
                endBase.castShadow = true;
                this.scene.add(endBase);
                
                const startPoints = [PATH_WEST[0], PATH_NORTH[0], PATH_SOUTH[0], PATH_EAST[0]];
                startPoints.forEach(start => {
                    const startM = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 4), new THREE.MeshLambertMaterial({color: 0x76ff03}));
                    startM.position.set(start.x * TILE_SIZE, 0.5, start.z * TILE_SIZE);
                    this.scene.add(startM);
                });
            }

            createDecorations() {
                const trunkMat = new THREE.MeshLambertMaterial({color: 0x5d4037});
                const leavesMat = new THREE.MeshLambertMaterial({color: 0x2e7d32});
                const flowerColors = [0xffeb3b, 0xff4081, 0x7c4dff, 0xffffff];

                for(let x=0; x<GRID_W; x++) {
                    for(let z=0; z<GRID_H; z++) {
                        if (this.grid[x][z].type === 0 && Math.random() > 0.7) {
                            const posX = x * TILE_SIZE;
                            const posZ = z * TILE_SIZE;
                            const rand = Math.random();
                            if (rand > 0.6) {
                                const tree = new THREE.Group();
                                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 2), trunkMat);
                                trunk.position.y = 1; trunk.castShadow = true;
                                const leaves = new THREE.Mesh(new THREE.ConeGeometry(2, 4, 8), leavesMat);
                                leaves.position.y = 3.5; leaves.castShadow = true;
                                tree.add(trunk, leaves);
                                const s = 0.8 + Math.random() * 0.4;
                                tree.scale.set(s, s, s);
                                tree.rotation.y = Math.random() * Math.PI;
                                tree.position.set(posX, 0.5, posZ);
                                this.scene.add(tree);
                                this.decorations.push(tree);
                                this.grid[x][z].hasDecoration = true;
                            } else {
                                const flower = new THREE.Group();
                                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1), leavesMat);
                                stem.position.y = 0.5;
                                const petalColor = flowerColors[Math.floor(Math.random()*flowerColors.length)];
                                const petal = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4), new THREE.MeshBasicMaterial({color: petalColor}));
                                petal.position.y = 1;
                                flower.add(stem, petal);
                                flower.position.set(posX + (Math.random()-0.5)*2, 0.5, posZ + (Math.random()-0.5)*2);
                                this.scene.add(flower);
                                this.decorations.push(flower);
                            }
                        }
                    }
                }
            }

            initAnimals() {
                const animalLocs = [PATH_WEST[2], PATH_NORTH[2], PATH_SOUTH[2]];
                animalLocs.forEach(loc => {
                    const animal = new Animal(loc.x, loc.z);
                    this.scene.add(animal.mesh);
                    this.animals.push(animal);
                });
                document.getElementById('animals-txt').innerText = this.animals.length;
            }

            isPointOnPath(x, z, path) {
                for(let i=0; i<path.length-1; i++) {
                    let p1 = path[i];
                    let p2 = path[i+1];
                    if(p1.z === p2.z && z === p1.z) {
                        if(x >= Math.min(p1.x, p2.x) && x <= Math.max(p1.x, p2.x)) return true;
                    }
                    if(p1.x === p2.x && x === p1.x) {
                        if(z >= Math.min(p1.z, p2.z) && z <= Math.max(p1.z, p2.z)) return true;
                    }
                }
                return false;
            }

            nextWave() {
                if(this.waveActive) return;
                this.waveActive = true;
                document.getElementById('next-wave-btn').disabled = true;

                const activePaths = [PATH_WEST, PATH_NORTH, PATH_SOUTH, PATH_EAST];

                const count = 30 + Math.floor(this.wave * 5);
                const hpMult = Math.pow(1.5, this.wave - 1); 
                
                let spawnDelayBase = Math.max(5, 30 - (this.wave * 2));

                for(let i=0; i<count; i++) {
                    let type = 'NORMAL';
                    const rand = Math.random();

                    if (this.wave >= 1 && rand > 0.6) type = 'FAST';
                    if (this.wave >= 2 && rand > 0.75) type = 'SHOOTER'; 
                    if (this.wave >= 3 && rand > 0.85) type = 'TANK';
                    if (this.wave >= 3 && rand > 0.92) type = 'BOMBER'; // Êñ∞Â¢ûÁÇ∏ÂΩàÂÆ¢
                    if (this.wave >= 4 && Math.random() > 0.8) type = 'FLYING';

                    let path = activePaths[0];
                    if (type !== 'FLYING') {
                        path = activePaths[Math.floor(Math.random() * activePaths.length)];
                    }
                    
                    this.spawnQueue.push({ type, hpMult, path, delay: i * spawnDelayBase });
                }
            }

            spawnEnemy() {
                if(this.spawnQueue.length === 0) return;
                const next = this.spawnQueue[0];
                if(next.delay > 0) {
                    next.delay--;
                    return;
                }
                this.spawnQueue.shift();
                const enemy = new Enemy(next.type, next.hpMult, next.path);
                this.enemies.push(enemy);
                this.scene.add(enemy.mesh);
            }

            update() {
                if (this.lives <= 0) return;

                if (this.waveActive) {
                    this.spawnEnemy();
                    if (this.spawnQueue.length === 0 && this.enemies.length === 0) {
                        this.endWave();
                    }
                }

                this.animals.forEach(a => a.update());

                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const e = this.enemies[i];
                    const status = e.update(this.animals, this.towers); // ÂÇ≥ÂÖ•Â°îÂàóË°®‰æõÁÇ∏ÂΩàÂÆ¢ÊîªÊìä
                    
                    if (status === 'REACHED') {
                        this.lives--;
                        AudioSys.error();
                        this.removeEnemy(e);
                        this.camera.position.x += (Math.random()-0.5); 
                        setTimeout(()=>this.camera.position.x = GRID_W * TILE_SIZE / 2, 50);
                        if(this.lives <= 0) this.gameOver("Âü∫Âú∞Ë¢´ÊëßÊØÄ");
                    }
                }

                this.towers.forEach(t => t.update(this.enemies));

                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const p = this.projectiles[i];
                    if (!p.active) {
                        this.scene.remove(p.mesh);
                        this.projectiles.splice(i, 1);
                    } else {
                        p.update();
                    }
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    if(!this.particles[i].update()) {
                        this.scene.remove(this.particles[i].mesh);
                        this.particles.splice(i, 1);
                    }
                }

                this.updateUI();
            }

            endWave() {
                this.waveActive = false;
                this.wave++;
                this.money += 150 + (this.wave * 25); 
                document.getElementById('next-wave-btn').disabled = false;
                AudioSys.build();
            }

            removeEnemy(e) {
                this.scene.remove(e.mesh);
                e.dispose();
                const idx = this.enemies.indexOf(e);
                if (idx > -1) this.enemies.splice(idx, 1);
            }
            
            removeAnimal(a) {
                this.scene.remove(a.mesh);
                const idx = this.animals.indexOf(a);
                if (idx > -1) this.animals.splice(idx, 1);
                document.getElementById('animals-txt').innerText = this.animals.length;
                AudioSys.animalDie();
                this.gameOver("Â∞èÂãïÁâ©Ë¢´ÊÆ∫Ê≠ª‰∫ÜÔºÅÊàëÂÄëÊ≤íËÉΩ‰øùË≠∑ÂÆÉ...");
            }

            removeTower(t) {
                this.scene.remove(t.mesh);
                this.grid[t.gx][t.gz].tower = null;
                const idx = this.towers.indexOf(t);
                if (idx > -1) this.towers.splice(idx, 1);
                
                // ÁàÜÁÇ∏ÁâπÊïà
                game.particles.push(new EffectParticle(t.mesh.position.x, 2, t.mesh.position.z, 0xff0000, 'explode', 2));
                AudioSys.towerDestroy();
                
                // UI ÊèêÁ§∫
                const msg = document.getElementById('tower-destroyed-msg');
                msg.style.opacity = 1;
                setTimeout(() => msg.style.opacity = 0, 1500);
            }

            selectBuildType(type) {
                document.querySelectorAll('.tower-card').forEach(el => el.classList.remove('active'));
                if (type === null || this.buildType === type) {
                    this.buildType = null;
                    this.ghostMesh.visible = false;
                    this.rangeCircle.visible = false;
                    return;
                }
                this.buildType = type;
                document.getElementById(`btn-${type.toLowerCase()}`).classList.add('active');
                this.closePanel();
                this.rangeCircle.visible = true;
                const data = TOWER_DATA[type];
                this.rangeCircle.geometry = new THREE.RingGeometry(data.range * TILE_SIZE - 0.5, data.range * TILE_SIZE, 64);
            }

            getGridPos(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const target = new THREE.Vector3();
                this.raycaster.ray.intersectPlane(plane, target);
                if (target) {
                    const gx = Math.round(target.x / TILE_SIZE);
                    const gz = Math.round(target.z / TILE_SIZE);
                    return { x: gx, z: gz, worldX: gx * TILE_SIZE, worldZ: gz * TILE_SIZE };
                }
                return null;
            }

            onMouseMove(e) {
                const pos = this.getGridPos(e);
                if (pos && pos.x >= 0 && pos.x < GRID_W && pos.z >= 0 && pos.z < GRID_H) {
                    if (this.buildType) {
                        this.ghostMesh.position.set(pos.worldX, 1, pos.worldZ);
                        this.ghostMesh.visible = true;
                        const cell = this.grid[pos.x][pos.z];
                        const canBuild = cell.type === 0 && cell.tower === null && !cell.hasDecoration;
                        this.ghostMesh.children[0].material.color.setHex(canBuild ? 0x76ff03 : 0xff1744);
                        this.rangeCircle.position.set(pos.worldX, 1, pos.worldZ);
                    }
                } else {
                    this.ghostMesh.visible = false;
                }
            }

            onClick(e) {
                const pos = this.getGridPos(e);
                if (!pos || pos.x < 0 || pos.x >= GRID_W || pos.z < 0 || pos.z >= GRID_H) return;
                const cell = this.grid[pos.x][pos.z];
                if (this.buildType) {
                    if (cell.type === 0 && cell.tower === null && !cell.hasDecoration) {
                        if (this.money >= TOWER_DATA[this.buildType].cost) {
                            this.buildTower(pos.x, pos.z, this.buildType);
                        } else {
                            AudioSys.error();
                        }
                    }
                } else {
                    if (cell.tower) {
                        this.selectTower(cell.tower);
                    } else {
                        this.closePanel();
                    }
                }
            }

            buildTower(gx, gz, type) {
                this.money -= TOWER_DATA[type].cost;
                const t = new Tower(gx, gz, type);
                this.scene.add(t.mesh);
                this.towers.push(t);
                this.grid[gx][gz].tower = t;
                AudioSys.build();
                this.particles.push(new EffectParticle(t.mesh.position.x, 2, t.mesh.position.z, 0xffffff, 'burst'));
                this.selectBuildType(null);
                this.updateUI();
            }

            selectTower(tower) {
                this.selectedTower = tower;
                this.rangeCircle.visible = true;
                this.rangeCircle.position.set(tower.mesh.position.x, 1, tower.mesh.position.z);
                const r = tower.getRange() * TILE_SIZE;
                this.rangeCircle.geometry = new THREE.RingGeometry(r-0.5, r, 64);
                const p = document.getElementById('upgrade-panel');
                p.style.display = 'block';
                document.getElementById('up-name').innerText = TOWER_DATA[tower.type].name;
                this.updatePanelInfo();
            }

            updatePanelInfo() {
                if (!this.selectedTower) return;
                const t = this.selectedTower;
                const cost = Math.floor(TOWER_DATA[t.type].cost * 1.5 * t.level);
                document.getElementById('up-level').innerText = t.level;
                document.getElementById('up-dmg').innerText = (t.getDamage()).toFixed(1);
                document.getElementById('up-range').innerText = t.getRange();
                document.getElementById('btn-upgrade').innerText = `ÂçáÁ¥ö ($${cost})`;
                document.getElementById('btn-upgrade').disabled = this.money < cost;
            }

            upgradeTower() {
                if(!this.selectedTower) return;
                const t = this.selectedTower;
                const cost = Math.floor(TOWER_DATA[t.type].cost * 1.5 * t.level);
                if (this.money >= cost) {
                    this.money -= cost;
                    t.upgrade();
                    AudioSys.build();
                    this.particles.push(new EffectParticle(t.mesh.position.x, 4, t.mesh.position.z, 0xffff00, 'burst'));
                    this.updatePanelInfo();
                    this.updateUI();
                }
            }

            sellTower() {
                if(!this.selectedTower) return;
                const t = this.selectedTower;
                const val = Math.floor(TOWER_DATA[t.type].cost * 0.4 * t.level);
                this.money += val;
                this.scene.remove(t.mesh);
                this.grid[t.gx][t.gz].tower = null;
                this.towers = this.towers.filter(x => x !== t);
                AudioSys.build();
                this.closePanel();
                this.updateUI();
            }

            closePanel() {
                this.selectedTower = null;
                document.getElementById('upgrade-panel').style.display = 'none';
                if (!this.buildType) this.rangeCircle.visible = false;
            }

            updateUI() {
                document.getElementById('lives-txt').innerText = this.lives;
                document.getElementById('money-txt').innerText = this.money;
                document.getElementById('wave-txt').innerText = this.wave;
                document.getElementById('enemies-txt').innerText = this.spawnQueue.length + this.enemies.length;
                if(this.selectedTower) this.updatePanelInfo();
            }

            gameOver(reason) {
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('go-title').innerText = "GAME OVER";
                document.getElementById('go-reason').innerHTML = `${reason}<br>ÊúÄÁµÇÊ≥¢Ê¨°: <span style="color:#ffeb3b">${this.wave}</span>`;
                this.renderer.setAnimationLoop(null);
                AudioSys.stopBGM();
            }

            onResize() {
                const aspect = window.innerWidth / window.innerHeight;
                this.camera.aspect = aspect;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                this.renderer.setAnimationLoop(() => {
                    this.update();
                    this.renderer.render(this.scene, this.camera);
                });
            }
        }

        class Animal {
            constructor(gx, gz) {
                this.hpMax = 200; 
                this.hp = this.hpMax;
                this.mesh = new THREE.Group();
                this.mesh.position.set(gx * TILE_SIZE, 0, gz * TILE_SIZE);

                const body = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 2), new THREE.MeshLambertMaterial({color: 0xffccbc})); 
                body.position.y = 0.75; body.castShadow = true;
                const earGeo = new THREE.BoxGeometry(0.5, 1, 0.5);
                const earL = new THREE.Mesh(earGeo, new THREE.MeshLambertMaterial({color: 0xffab91}));
                earL.position.set(-0.6, 1.8, 0);
                const earR = new THREE.Mesh(earGeo, new THREE.MeshLambertMaterial({color: 0xffab91}));
                earR.position.set(0.6, 1.8, 0);
                const nose = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.2), new THREE.MeshLambertMaterial({color: 0xff5722}));
                nose.position.set(0, 1, 1);
                this.mesh.add(body, earL, earR, nose);

                const barContainer = new THREE.Group();
                const bg = new THREE.Mesh(new THREE.PlaneGeometry(3.2, 0.6), new THREE.MeshBasicMaterial({color:0x000000}));
                const fg = new THREE.Mesh(new THREE.PlaneGeometry(3, 0.4), new THREE.MeshBasicMaterial({color:0x29b6f6})); 
                fg.position.z = 0.01;
                barContainer.add(bg, fg);
                barContainer.position.y = 3.5;
                this.hpBar = fg;
                this.mesh.add(barContainer);
                this.animOffset = Math.random() * 100;
                this.onBeforeRender = () => { barContainer.lookAt(game.camera.position); };
            }

            update() {
                const time = Date.now() * 0.005 + this.animOffset;
                this.mesh.children[0].position.y = 0.75 + Math.sin(time) * 0.1;
                this.mesh.children[0].rotation.y = Math.sin(time * 0.5) * 0.1;
            }

            takeDamage(amt) {
                this.hp -= amt;
                const pct = Math.max(0, this.hp / this.hpMax);
                this.hpBar.scale.x = pct;
                if (this.hp <= 0) {
                    game.removeAnimal(this);
                }
            }
        }

        class Enemy {
            constructor(type, hpMult, path) {
                this.type = type;
                this.path = path;
                this.pathIdx = 0;
                this.hpMax = 50 * hpMult;
                this.speed = 0.08;
                this.color = 0xffffff;
                this.reward = 15;
                this.isSlowed = 0;
                this.flyHeight = 0;
                this.attackCooldown = 0;
                this.damage = 4; 
                this.defense = Math.floor(game.wave * 0.8) + 1; 
                this.attackRange = 3; 

                let geo;
                if (type === 'NORMAL') {
                    geo = new THREE.DodecahedronGeometry(1.5);
                    this.color = 0x5c6bc0; this.speed = 0.08;
                } else if (type === 'FAST') {
                    geo = new THREE.ConeGeometry(1, 2.5, 8);
                    this.color = 0xffca28; this.speed = 0.15; this.hpMax = 35 * hpMult;
                    this.attackRange = 2; 
                    this.damage = 3;
                } else if (type === 'TANK') {
                    geo = new THREE.BoxGeometry(2.5, 2.5, 2.5);
                    this.color = 0x4e342e; this.speed = 0.04; this.hpMax = 150 * hpMult; this.reward = 40; 
                    this.damage = 10; 
                    this.defense += 3; 
                    this.attackRange = 5; 
                } else if (type === 'SHOOTER') { 
                    geo = new THREE.CylinderGeometry(0.8, 0.8, 3, 8);
                    this.color = 0x43a047; this.speed = 0.07; this.hpMax = 40 * hpMult; 
                    this.damage = 8; 
                    // --- Ë™øÊï¥Ôºö18Ê†ºË∂ÖÈÅ†Â∞ÑÁ®ã ---
                    this.attackRange = 18; 
                } else if (type === 'BOMBER') { // Êñ∞Â¢ûÔºöÁÇ∏ÂΩàÂÆ¢
                    geo = new THREE.IcosahedronGeometry(1.8, 1);
                    this.color = 0x212121; // ÈªëËâ≤
                    this.speed = 0.05; // ÊÖ¢ÈÄü
                    this.hpMax = 80 * hpMult; // Ë°ÄÂéö
                    this.attackRange = 6; // ÁÇ∏ÂΩàÊäïÊì≤Ë∑ùÈõ¢
                    this.defense += 5; // È´òÈò≤Á¶¶
                    this.reward = 50;
                } else if (type === 'FLYING') {
                    geo = new THREE.CylinderGeometry(0.5, 1.5, 0.5, 6);
                    this.color = 0xd81b60; this.speed = 0.1; this.hpMax = 40 * hpMult; this.flyHeight = 8; this.reward = 25;
                    const startP = {x: 0, z: Math.random() * GRID_H}; 
                    this.customStart = new THREE.Vector3(startP.x * TILE_SIZE, this.flyHeight, startP.z * TILE_SIZE);
                    const endP = {x: 18, z: 12}; 
                    this.customTarget = new THREE.Vector3(endP.x * TILE_SIZE, this.flyHeight, endP.z * TILE_SIZE);
                }

                this.hp = this.hpMax;
                this.mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: this.color }));
                this.mesh.castShadow = true;

                if (type === 'FLYING') {
                    this.mesh.position.copy(this.customStart);
                    this.mesh.lookAt(this.customTarget);
                } else {
                    const start = this.path[0];
                    this.mesh.position.set(start.x * TILE_SIZE, 1.5, start.z * TILE_SIZE);
                }
                
                const barContainer = new THREE.Group();
                const bg = new THREE.Mesh(new THREE.PlaneGeometry(3.2, 0.6), new THREE.MeshBasicMaterial({color:0x000000}));
                const fg = new THREE.Mesh(new THREE.PlaneGeometry(3, 0.4), new THREE.MeshBasicMaterial({color:0x76ff03}));
                fg.position.z = 0.01;
                barContainer.add(bg, fg);
                barContainer.position.y = 3;
                this.hpBar = fg;
                this.mesh.add(barContainer);

                this.onBeforeRender = () => { barContainer.lookAt(game.camera.position); };
            }

            update(animals, towers) {
                let currentSpeed = this.speed;
                if (this.isSlowed > 0) {
                    currentSpeed *= 0.6; this.isSlowed--;
                    this.mesh.material.emissive.setHex(0x00ffff);
                } else {
                    this.mesh.material.emissive.setHex(0x000000);
                }

                // ÁÇ∏ÂΩàÂÆ¢ÂÑ™ÂÖàÊîªÊìäÂ°î
                if (this.type === 'BOMBER' && towers.length > 0) {
                    for(let tower of towers) {
                        const dist = this.mesh.position.distanceTo(tower.mesh.position);
                        const range = this.attackRange * TILE_SIZE; 
                        
                        if (dist < range) {
                            if (this.attackCooldown <= 0) {
                                // ‰∏üÁÇ∏ÂΩà
                                this.attackCooldown = 150; // ÂÜ∑Âçª‰πÖ‰∏ÄÈªû
                                AudioSys.enemyShoot();
                                
                                // ÁÇ∏ÂΩàÊããÁâ©Á∑öË¶ñË¶∫
                                const bomb = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color:0x000000}));
                                bomb.position.copy(this.mesh.position);
                                bomb.position.y += 2;
                                game.scene.add(bomb);
                                
                                const targetPos = tower.mesh.position.clone();
                                let t = 0;
                                const animateBomb = setInterval(() => {
                                    t += 0.1;
                                    bomb.position.lerp(targetPos, 0.1);
                                    bomb.position.y += Math.sin(t * Math.PI) * 0.5; // Á∞°ÂñÆÊããÁâ©Á∑ö
                                    
                                    if (bomb.position.distanceTo(targetPos) < 1) {
                                        clearInterval(animateBomb);
                                        game.scene.remove(bomb);
                                        // Áû¨ÈñìÊëßÊØÄÂ°î
                                        tower.takeDamage(999);
                                    }
                                }, 50);
                            } else {
                                this.attackCooldown--;
                            }
                            return 'ATTACKING_TOWER'; // ÁÇ∏ÂΩàÂÆ¢Â∞àÂøÉÊãÜÂ°î
                        }
                    }
                }

                // ÂÖ∂‰ªñÈÅ†Ë∑ùÊîªÊìäÈÇèËºØ (ÊîªÊìäÂãïÁâ©)
                if (this.type !== 'FLYING' && animals.length > 0) {
                    for(let animal of animals) {
                        const dist = this.mesh.position.distanceTo(animal.mesh.position);
                        const range = this.attackRange * TILE_SIZE * 0.8; 
                        
                        if (dist < range) { 
                            if (this.attackCooldown <= 0) {
                                animal.takeDamage(this.damage);
                                this.attackCooldown = 40; 
                                AudioSys.enemyShoot();
                                
                                const laserGeo = new THREE.BufferGeometry().setFromPoints([
                                    this.mesh.position.clone().add(new THREE.Vector3(0,1,0)),
                                    animal.mesh.position.clone().add(new THREE.Vector3(0,1,0))
                                ]);
                                const laser = new THREE.Line(laserGeo, new THREE.LineBasicMaterial({color: 0xff0000, linewidth: 2}));
                                game.scene.add(laser);
                                setTimeout(() => game.scene.remove(laser), 100);

                                this.mesh.position.y += 0.5;
                                setTimeout(() => this.mesh.position.y -= 0.5, 100);
                            } else {
                                this.attackCooldown--;
                            }
                            return 'ATTACKING';
                        }
                    }
                }

                if (this.type === 'FLYING') {
                    const dir = new THREE.Vector3().subVectors(this.customTarget, this.mesh.position).normalize();
                    this.mesh.position.add(dir.multiplyScalar(currentSpeed * TILE_SIZE));
                    if (this.mesh.position.distanceTo(this.customTarget) < 1) return 'REACHED';
                } else {
                    const targetNode = this.path[this.pathIdx + 1];
                    if (!targetNode) return 'REACHED';

                    const tx = targetNode.x * TILE_SIZE;
                    const tz = targetNode.z * TILE_SIZE;
                    const dx = tx - this.mesh.position.x;
                    const dz = tz - this.mesh.position.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    const moveDist = currentSpeed * TILE_SIZE;

                    if (dist < moveDist) {
                        this.mesh.position.x = tx;
                        this.mesh.position.z = tz;
                        this.pathIdx++;
                        if(this.path[this.pathIdx+1]) {
                            this.mesh.lookAt(this.path[this.pathIdx+1].x * TILE_SIZE, 1.5, this.path[this.pathIdx+1].z * TILE_SIZE);
                        }
                    } else {
                        this.mesh.position.x += (dx/dist) * moveDist;
                        this.mesh.position.z += (dz/dist) * moveDist;
                    }
                }
                
                this.mesh.children[0].lookAt(game.camera.position);
                return 'MOVING';
            }

            takeDamage(amt) {
                const actualDamage = Math.max(1, amt - this.defense);
                
                this.hp -= actualDamage;
                const pct = Math.max(0, this.hp / this.hpMax);
                this.hpBar.scale.x = pct;
                this.hpBar.material.color.setHex(pct > 0.5 ? 0x76ff03 : 0xff1744);

                const pColor = actualDamage < amt ? 0xaaaaaa : this.color;
                game.particles.push(new EffectParticle(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z, pColor, 'hit', 0.5));

                if (this.hp <= 0) {
                    game.money += this.reward;
                    game.removeEnemy(this);
                    game.particles.push(new EffectParticle(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z, this.color, 'explode'));
                    AudioSys.boom();
                }
            }
            dispose() {
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        class Tower {
            constructor(gx, gz, type) {
                this.gx = gx; this.gz = gz; this.type = type; this.level = 1; this.cooldown = 0;
                this.hp = 100; // Â°î‰πüÊúâË°ÄÈáè‰∫Ü
                const data = TOWER_DATA[type];
                this.mesh = new THREE.Group();
                this.mesh.position.set(gx * TILE_SIZE, 0, gz * TILE_SIZE);

                const baseGeo = new THREE.CylinderGeometry(2, 2.2, 1, 8);
                const baseMat = new THREE.MeshPhongMaterial({ color: 0x546e7a });
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = 0.5; base.castShadow = true;
                this.mesh.add(base);

                this.head = new THREE.Group();
                this.head.position.y = 1; 
                
                let headMesh;
                if (type === 'ARCHER') {
                    const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), new THREE.MeshPhongMaterial({color: data.color}));
                    const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 3), new THREE.MeshPhongMaterial({color: 0x333}));
                    barrel.rotation.x = Math.PI/2; barrel.position.z = 1.5;
                    this.head.add(body, barrel);
                } else if (type === 'ICE') {
                    const geo = new THREE.OctahedronGeometry(1.2);
                    headMesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({color: data.color, transparent:true, opacity:0.8}));
                    this.head.add(headMesh);
                    this.animator = () => { headMesh.rotation.y += 0.05; headMesh.rotation.x += 0.02; };
                } else if (type === 'FIRE') {
                    const cone = new THREE.Mesh(new THREE.ConeGeometry(1.5, 3, 8, 1, true), new THREE.MeshPhongMaterial({color: data.color, side: THREE.DoubleSide}));
                    cone.rotation.x = Math.PI/2; cone.position.z = 1;
                    this.head.add(cone);
                } else if (type === 'LASER') {
                    const sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshPhongMaterial({color: data.color, emissive: data.color, emissiveIntensity: 0.5}));
                    this.head.add(sphere);
                    const lens = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1), new THREE.MeshBasicMaterial({color: 0xffffff}));
                    lens.rotation.x = Math.PI/2; lens.position.z = 1;
                    this.head.add(lens);
                }
                this.mesh.add(this.head);
            }

            getRange() { return TOWER_DATA[this.type].range * (1 + 0.1*(this.level-1)); }
            getDamage() { return TOWER_DATA[this.type].damage * (1 + 0.4*(this.level-1)); }
            getRate() { return Math.max(5, TOWER_DATA[this.type].rate - (this.level * 2)); }

            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    game.removeTower(this);
                }
            }

            update(enemies) {
                if (this.animator) this.animator();

                if (this.cooldown > 0) {
                    this.cooldown--;
                    if (this.type === 'LASER' && this.laserMesh) {
                        this.laserMesh.material.opacity -= 0.1;
                        if (this.laserMesh.material.opacity <= 0) {
                            this.mesh.remove(this.laserMesh);
                            this.laserMesh = null;
                        }
                    }
                    return;
                }

                const range = this.getRange() * TILE_SIZE;
                let target = null;
                let minDist = range;

                for (let e of enemies) {
                    const d = this.mesh.position.distanceTo(e.mesh.position);
                    if (d <= range && d < minDist) {
                        minDist = d;
                        target = e;
                    }
                }

                if (target) {
                    this.head.lookAt(target.mesh.position);
                    const dmg = this.getDamage();
                    if (this.type === 'LASER') {
                        target.takeDamage(dmg);
                        this.createLaserBeam(target.mesh.position);
                        this.cooldown = 10;
                        AudioSys.laser();
                    } else {
                        game.projectiles.push(new Projectile(
                            this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)),
                            target,
                            this.type,
                            dmg
                        ));
                        this.cooldown = this.getRate();
                        AudioSys.shoot();
                    }
                }
            }

            createLaserBeam(targetPos) {
                if (this.laserMesh) this.mesh.remove(this.laserMesh);
                const points = [];
                points.push(new THREE.Vector3(0, 2, 0));
                const localTarget = this.mesh.worldToLocal(targetPos.clone());
                points.push(localTarget);
                const geo = new THREE.BufferGeometry().setFromPoints(points);
                const mat = new THREE.LineBasicMaterial({ color: 0xff00ff, linewidth: 2, transparent: true, opacity: 1 });
                this.laserMesh = new THREE.Line(geo, mat);
                this.mesh.add(this.laserMesh);
            }

            upgrade() {
                this.level++;
                const s = 1 + (this.level * 0.1);
                this.mesh.scale.set(s, s, s);
            }
        }

        class Projectile {
            constructor(startPos, target, type, damage) {
                this.pos = startPos; this.target = target; this.type = type; this.damage = damage;
                this.active = true; this.speed = type === 'ARCHER' ? 1.0 : 0.8; 
                const color = TOWER_DATA[type].color;
                let geo = new THREE.SphereGeometry(0.3);
                if (type === 'ARCHER') geo = new THREE.BoxGeometry(0.2, 0.2, 0.8);
                this.mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: color }));
                this.mesh.position.copy(startPos);
                game.scene.add(this.mesh);
                this.lastTargetPos = target.mesh.position.clone();
            }

            update() {
                let targetPos = this.lastTargetPos;
                if (game.enemies.includes(this.target)) {
                    targetPos = this.target.mesh.position;
                    this.lastTargetPos = targetPos.clone();
                }
                const dir = new THREE.Vector3().subVectors(targetPos, this.mesh.position).normalize();
                this.mesh.position.add(dir.multiplyScalar(this.speed * TILE_SIZE * 0.2));
                this.mesh.lookAt(targetPos);

                if (this.mesh.position.distanceTo(targetPos) < 1.0) {
                    this.hit(targetPos);
                }
            }

            hit(pos) {
                this.active = false;
                if (this.type === 'FIRE') {
                    game.particles.push(new EffectParticle(pos.x, pos.y, pos.z, 0xff5722, 'explode', 2));
                    game.enemies.forEach(e => {
                        if (e.mesh.position.distanceTo(pos) < 2.5 * TILE_SIZE) {
                            e.takeDamage(this.damage);
                        }
                    });
                } else if (this.type === 'ICE') {
                     if (game.enemies.includes(this.target)) {
                        this.target.takeDamage(this.damage);
                        this.target.isSlowed = 60;
                    }
                } else {
                    if (game.enemies.includes(this.target)) {
                        this.target.takeDamage(this.damage);
                    }
                }
            }
        }

        class EffectParticle {
            constructor(x, y, z, color, type='burst', scale=1) {
                this.life = 1.0; this.mesh = new THREE.Group(); this.type = type;
                const count = type === 'explode' ? 8 : (type === 'hit' ? 2 : 4);
                for(let i=0; i<count; i++) {
                    const size = (Math.random() * 0.4 + 0.1) * scale;
                    const p = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), new THREE.MeshBasicMaterial({color: color}));
                    p.userData.velocity = new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5+0.5, (Math.random()-0.5)*0.5);
                    this.mesh.add(p);
                }
                this.mesh.position.set(x, y, z);
                game.scene.add(this.mesh);
            }
            update() {
                this.life -= 0.05;
                this.mesh.children.forEach(p => {
                    p.position.add(p.userData.velocity);
                    p.rotation.x += 0.1; p.userData.velocity.y -= 0.02;
                });
                this.mesh.children.forEach(p => { if (p.material.opacity > 0) p.material.opacity = this.life; });
                return this.life > 0;
            }
        }

        const game = new Game3D();

    </script>
</body>
</html>
