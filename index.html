<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‰²å½©å¡”é˜² Color Defense</title>
    <style>
        :root {
            --bg-color: #e0f7fa;
            --panel-bg: #ffffff;
            --accent: #ff9800;
            --text: #37474f;
            --btn-hover: #f57c00;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        h1 {
            margin: 10px 0;
            color: #0097a7;
            text-shadow: 1px 1px 0px rgba(0,0,0,0.1);
        }

        #game-container {
            display: flex;
            gap: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        #canvas-wrapper {
            position: relative;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 0 5px #b2dfdb;
        }

        canvas {
            background-color: #81c784; /* è‰åœ°é¡è‰² */
            display: block;
            cursor: crosshair;
        }

        /* UI é¢æ¿ */
        #ui-panel {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .card {
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 1.1em;
        }

        .stat-item span {
            color: var(--accent);
        }

        /* å»ºé€ é¸å–® */
        .build-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .tower-btn {
            border: 2px solid #eee;
            background: white;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .tower-btn:hover {
            transform: translateY(-2px);
            border-color: var(--accent);
            background-color: #fff3e0;
        }

        .tower-btn.active {
            border-color: #00bcd4;
            background-color: #e0f7fa;
            box-shadow: 0 0 8px rgba(0, 188, 212, 0.4);
        }

        .tower-icon {
            width: 30px;
            height: 30px;
            margin-bottom: 5px;
            border-radius: 50%;
        }

        .tower-cost {
            font-size: 0.9em;
            color: #f57c00;
            font-weight: bold;
        }

        .tower-name {
            font-size: 0.8em;
            color: #666;
        }

        /* æ§åˆ¶æŒ‰éˆ• */
        .control-btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
        }

        .control-btn:hover {
            background: var(--btn-hover);
        }

        .control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .secondary-btn {
            background: #78909c;
            margin-top: 5px;
        }
        
        .secondary-btn:hover {
            background: #607d8b;
        }

        .danger-btn {
            background: #ef5350;
        }
        
        .danger-btn:hover {
            background: #e53935;
        }

        /* å‡ç´šé¢æ¿ */
        #upgrade-panel {
            display: none; /* é è¨­éš±è— */
        }

        #upgrade-panel.visible {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* éŠæˆ²çµæŸè¦†è“‹å±¤ */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            z-index: 10;
        }

        #overlay h2 {
            font-size: 3em;
            margin-bottom: 20px;
            color: #ffeb3b;
        }

    </style>
</head>
<body>

    <h1>ğŸ° è‰²å½©å¡”é˜² Color Defense</h1>

    <div id="game-container">
        <div id="canvas-wrapper">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="overlay">
                <h2 id="game-over-title">GAME OVER</h2>
                <p id="game-over-score">Final Wave: 0</p>
                <button class="control-btn" style="width: 200px;" onclick="game.restartGame()">é‡æ–°é–‹å§‹</button>
            </div>
        </div>

        <div id="ui-panel">
            <!-- ç‹€æ…‹å¡ç‰‡ -->
            <div class="card">
                <div class="stats-row">
                    <div class="stat-item">â¤ï¸ ç”Ÿå‘½: <span id="lives-display">20</span></div>
                    <div class="stat-item">ğŸ’° é‡‘éŒ¢: <span id="money-display">100</span></div>
                </div>
                <div class="stats-row">
                    <div class="stat-item">ğŸŒŠ æ³¢æ¬¡: <span id="wave-display">1</span></div>
                    <div class="stat-item">ğŸ‘¾ æ•µäºº: <span id="enemies-display">0</span></div>
                </div>
            </div>

            <!-- æ§åˆ¶å¡ç‰‡ -->
            <div class="card">
                <button id="next-wave-btn" class="control-btn" onclick="game.startNextWave()">ä¸‹ä¸€æ³¢ (Next Wave)</button>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button id="pause-btn" class="control-btn secondary-btn" onclick="game.togglePause()">æš«åœ</button>
                    <button class="control-btn secondary-btn" onclick="game.toggleSpeed()">x1/x2</button>
                </div>
            </div>

            <!-- å»ºé€ é¸å–® -->
            <div class="card">
                <h3 style="margin-top:0; font-size:1em; color:#555;">å»ºé€ å¡” (Build)</h3>
                <div class="build-grid" id="build-menu">
                    <!-- JS å‹•æ…‹ç”Ÿæˆ -->
                </div>
                <p style="font-size: 0.8em; color: #888; margin-bottom: 0;">é»é¸ä¸Šæ–¹å¡”ç¨®ï¼Œå†é»æ“Šåœ°åœ–æ”¾ç½®ã€‚</p>
            </div>

            <!-- å‡ç´š/è³‡è¨Šé¢æ¿ -->
            <div id="upgrade-panel" class="card">
                <h3 style="margin-top:0; font-size:1em;" id="selected-tower-name">é˜²ç¦¦å¡”</h3>
                <p style="font-size:0.9em;">ç­‰ç´š: <span id="tower-level">1</span></p>
                <p style="font-size:0.9em;">å‚·å®³: <span id="tower-damage">10</span></p>
                <p style="font-size:0.9em;">ç¯„åœ: <span id="tower-range">100</span></p>
                <button id="upgrade-btn" class="control-btn" onclick="game.upgradeSelectedTower()">å‡ç´š ($50)</button>
                <button id="sell-btn" class="control-btn danger-btn" style="margin-top:10px;" onclick="game.sellSelectedTower()">è³£å‡º ($25)</button>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // 0. éŸ³æ•ˆç³»çµ± (Audio Synth)
        // ==========================================
        const AudioSys = {
            ctx: null,
            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.ctx) this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playShoot: function() { this.playTone(400, 'square', 0.1, 0.05); },
            playHit: function() { this.playTone(100, 'sawtooth', 0.1, 0.05); },
            playBuild: function() { this.playTone(600, 'sine', 0.2, 0.1); },
            playUpgrade: function() { 
                if (!this.ctx) this.init();
                this.playTone(600, 'sine', 0.1, 0.1);
                setTimeout(() => this.playTone(800, 'sine', 0.2, 0.1), 100);
            },
            playExplosion: function() {
                this.playTone(100, 'sawtooth', 0.3, 0.1);
                this.playTone(50, 'square', 0.3, 0.1);
            },
            playError: function() { this.playTone(150, 'sawtooth', 0.2, 0.1); }
        };

        // ==========================================
        // 1. éŠæˆ²å¸¸æ•¸èˆ‡é…ç½®
        // ==========================================
        const TILE_SIZE = 40;
        const COLS = 20;
        const ROWS = 15;
        
        // é¡è‰²é…ç½®
        const COLORS = {
            path: '#fff59d',     // æ·¡é»ƒè‰²è·¯å¾‘
            grass: '#81c784',    // ç¶ è‰²èƒŒæ™¯
            highlight: 'rgba(255, 255, 255, 0.3)',
            range: 'rgba(0, 0, 0, 0.1)',
            rangeBuff: 'rgba(76, 175, 80, 0.2)'
        };

        // å¡”çš„å®šç¾©
        const TOWER_TYPES = {
            ARCHER: {
                id: 'ARCHER', name: 'ç®­å¡” (Archer)', color: '#ffeb3b', // é»ƒè‰²
                cost: 30, damage: 20, range: 120, rate: 30, // rate: frames per shot
                type: 'single', bulletColor: '#333'
            },
            ICE: {
                id: 'ICE', name: 'å†°å¡” (Ice)', color: '#4dd0e1', // å†°è—
                cost: 50, damage: 8, range: 100, rate: 40, 
                type: 'slow', effect: 0.6, bulletColor: '#b2ebf2' // 0.6 means 60% speed
            },
            FIRE: {
                id: 'FIRE', name: 'ç«å¡” (Fire)', color: '#f44336', // ç´…è‰²
                cost: 80, damage: 40, range: 110, rate: 90,
                type: 'aoe', splashRadius: 80, bulletColor: '#ff8a65'
            },
            NATURE: {
                id: 'NATURE', name: 'è‡ªç„¶å¡” (Buff)', color: '#4caf50', // æ·±ç¶ 
                cost: 100, damage: 0, range: 130, rate: 0,
                type: 'buff', buffAmount: 1.2 // 20% boost
            }
        };

        // åœ°åœ–è·¯å¾‘ (Grid Coordinates)
        const PATH_POINTS = [
            {x: 0, y: 2}, {x: 4, y: 2}, {x: 4, y: 8}, 
            {x: 10, y: 8}, {x: 10, y: 3}, {x: 16, y: 3}, 
            {x: 16, y: 10}, {x: 6, y: 10}, {x: 6, y: 13}, 
            {x: 19, y: 13}
        ];

        // ==========================================
        // 2. é¡åˆ¥å®šç¾©
        // ==========================================

        class Enemy {
            constructor(type, waveMult) {
                this.pathIndex = 0;
                // èµ·å§‹ä½ç½®
                this.x = PATH_POINTS[0].x * TILE_SIZE + TILE_SIZE/2;
                this.y = PATH_POINTS[0].y * TILE_SIZE + TILE_SIZE/2;
                
                // å±¬æ€§è¨­å®š
                this.type = type;
                this.radius = 10;
                this.frozenTimer = 0;
                this.maxHealth = 0;
                this.speed = 0;
                this.money = 0;
                this.color = '#000';
                this.shape = 'circle'; // circle, triangle, square

                this.setupStats(type, waveMult);
                this.health = this.maxHealth;
            }

            setupStats(type, mult) {
                // åŸºç¤æ•¸å€¼
                if (type === 'NORMAL') {
                    this.maxHealth = 30 * mult;
                    this.speed = 1.5;
                    this.money = 10;
                    this.color = '#7e57c2'; // ç´«è‰²
                    this.shape = 'circle';
                } else if (type === 'FAST') {
                    this.maxHealth = 20 * mult;
                    this.speed = 2.5;
                    this.money = 12;
                    this.color = '#ff4081'; // ç²‰ç´…
                    this.shape = 'triangle';
                } else if (type === 'TANK') {
                    this.maxHealth = 80 * mult;
                    this.speed = 0.8;
                    this.money = 20;
                    this.color = '#3e2723'; // æ·±è¤
                    this.shape = 'square';
                    this.radius = 14;
                }
            }

            update() {
                // è™•ç†æ¸›é€Ÿæ•ˆæœ
                let currentSpeed = this.speed;
                if (this.frozenTimer > 0) {
                    currentSpeed *= 0.6; // æ¸›é€Ÿ 40%
                    this.frozenTimer--;
                }

                // ç§»å‹•é‚è¼¯
                const target = PATH_POINTS[this.pathIndex + 1];
                if (!target) return; // å·²åˆ°çµ‚é»

                const tx = target.x * TILE_SIZE + TILE_SIZE/2;
                const ty = target.y * TILE_SIZE + TILE_SIZE/2;
                
                const dx = tx - this.x;
                const dy = ty - this.y;
                const dist = Math.hypot(dx, dy);

                if (dist < currentSpeed) {
                    this.x = tx;
                    this.y = ty;
                    this.pathIndex++;
                    if (this.pathIndex >= PATH_POINTS.length - 1) {
                        game.enemyReachedEnd(this);
                    }
                } else {
                    this.x += (dx / dist) * currentSpeed;
                    this.y += (dy / dist) * currentSpeed;
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                if (this.frozenTimer > 0) ctx.fillStyle = '#80deea'; // å†°å‡è‰²

                ctx.beginPath();
                if (this.shape === 'circle') {
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                } else if (this.shape === 'triangle') {
                    ctx.moveTo(this.x, this.y - this.radius);
                    ctx.lineTo(this.x + this.radius, this.y + this.radius);
                    ctx.lineTo(this.x - this.radius, this.y + this.radius);
                } else {
                    ctx.rect(this.x - this.radius, this.y - this.radius, this.radius*2, this.radius*2);
                }
                ctx.fill();

                // è¡€æ¢
                const hpPct = this.health / this.maxHealth;
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - 10, this.y - 20, 20, 4);
                ctx.fillStyle = '#76ff03';
                ctx.fillRect(this.x - 10, this.y - 20, 20 * hpPct, 4);
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    game.enemyKilled(this);
                }
            }
        }

        class Tower {
            constructor(c, r, typeKey) {
                this.c = c;
                this.r = r;
                this.x = c * TILE_SIZE + TILE_SIZE/2;
                this.y = r * TILE_SIZE + TILE_SIZE/2;
                this.typeKey = typeKey;
                this.level = 1;
                
                // è¤‡è£½åŸºç¤å±¬æ€§
                const base = TOWER_TYPES[typeKey];
                this.damage = base.damage;
                this.range = base.range;
                this.rate = base.rate;
                this.cost = base.cost; // å»ºé€ åƒ¹æ ¼ï¼Œå‡ç´šç”¨ base calculation
                this.buffed = false; // æ˜¯å¦è¢«è‡ªç„¶å¡”åŠ å¼·

                this.cooldown = 0;
                this.angle = 0; // ç ²ç®¡è§’åº¦
            }

            get currentDamage() { return this.buffed ? this.damage * 1.2 : this.damage; }
            get currentRate() { return this.buffed ? this.rate / 1.2 : this.rate; } // rateè¶Šå°è¶Šå¿«

            update() {
                if (this.typeKey === 'NATURE') return; // è‡ªç„¶å¡”ä¸æ”»æ“Š

                if (this.cooldown > 0) this.cooldown--;

                // å°‹æ‰¾ç›®æ¨™
                const target = this.findTarget();
                if (target) {
                    // è¨ˆç®—è§’åº¦
                    this.angle = Math.atan2(target.y - this.y, target.x - this.x);

                    if (this.cooldown <= 0) {
                        this.shoot(target);
                        this.cooldown = this.currentRate;
                    }
                }
            }

            findTarget() {
                // ç°¡å–®é‚è¼¯ï¼šæ‰¾ç¯„åœå…§èµ°æœ€é çš„æ•µäºº
                let bestEnemy = null;
                let maxProgress = -1;

                for (let enemy of game.enemies) {
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist <= this.range) {
                        // pathIndex ä»£è¡¨èµ°äº†å¹¾å€‹ç¯€é»ï¼Œè¶Šå¤§æ¦‚ç‡è¶Šå‰é¢
                        const progress = enemy.pathIndex * 1000 + (1000 - Math.hypot(enemy.x - (PATH_POINTS[enemy.pathIndex+1]?.x * TILE_SIZE || 0), enemy.y - (PATH_POINTS[enemy.pathIndex+1]?.y * TILE_SIZE || 0)));
                        if (progress > maxProgress) {
                            maxProgress = progress;
                            bestEnemy = enemy;
                        }
                    }
                }
                return bestEnemy;
            }

            shoot(target) {
                const type = TOWER_TYPES[this.typeKey];
                
                // å‰µå»ºç™¼å°„ç‰©
                game.projectiles.push(new Projectile(
                    this.x, this.y, target, this.typeKey, this.currentDamage
                ));
                
                AudioSys.playShoot();
            }

            upgrade() {
                this.level++;
                this.damage *= 1.3; // å‚·å®³å¢åŠ  30%
                // è²»ç”¨è¨ˆç®—åœ¨ Game é¡åˆ¥è™•ç†
            }

            draw(ctx) {
                const base = TOWER_TYPES[this.typeKey];
                
                // å¡”åŸºåº§
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 16, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 1;
                ctx.stroke();

                // å¡”èº«
                ctx.fillStyle = base.color;
                ctx.beginPath();
                if (this.typeKey === 'NATURE') {
                    // è‡ªç„¶å¡”ç•«å€‹è‘‰å­å½¢ç‹€æˆ–åå­—
                    ctx.rect(this.x - 8, this.y - 8, 16, 16);
                } else {
                    ctx.arc(this.x, this.y, 12, 0, Math.PI*2);
                }
                ctx.fill();

                // ç ²ç®¡ (å¦‚æœæœ‰)
                if (this.typeKey !== 'NATURE') {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    ctx.fillStyle = '#555';
                    ctx.fillRect(0, -3, 20, 6);
                    ctx.restore();
                }

                // ç­‰ç´šæ¨™è¨˜
                ctx.fillStyle = 'black';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Lv.' + this.level, this.x, this.y + 4);

                // Buff æ¨™è¨˜
                if (this.buffed) {
                    ctx.strokeStyle = '#00e676';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 18, 0, Math.PI*2);
                    ctx.stroke();
                }
            }
        }

        class Projectile {
            constructor(x, y, target, type, damage) {
                this.x = x;
                this.y = y;
                this.target = target; // è¿½è¹¤ç›®æ¨™
                this.type = type;
                this.damage = damage;
                this.speed = 8;
                this.active = true;
                this.radius = 4;
            }

            update() {
                // å¦‚æœç›®æ¨™æ­»äº†ï¼Œé›–ç„¶é‚„æ˜¯æœƒé£›éå»ï¼Œä½†æˆ‘å€‘å…ˆç°¡åŒ–ï¼š
                // å¦‚æœæ˜¯è¿½è¹¤å½ˆï¼Œæ›´æ–°è§’åº¦ã€‚
                
                let tx = this.target.x;
                let ty = this.target.y;

                // å¦‚æœç›®æ¨™å·²æ­»ï¼Œå¾€æœ€å¾Œå·²çŸ¥ä½ç½®é£›ï¼ˆé€™è£¡ç°¡åŒ–ç‚ºç›´æ¥æ¶ˆå¤±æˆ–ç¹¼çºŒé£›ï¼‰
                if (this.target.health <= 0) {
                    this.active = false; 
                    return;
                }

                const dx = tx - this.x;
                const dy = ty - this.y;
                const dist = Math.hypot(dx, dy);

                if (dist < this.speed) {
                    this.hit(this.target);
                } else {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
            }

            hit(enemy) {
                this.active = false;
                const config = TOWER_TYPES[this.type];

                // ç”¢ç”Ÿç‰¹æ•ˆ
                game.particles.push(new Particle(this.x, this.y, config.color));

                if (config.type === 'aoe') {
                    // ç«å¡”ç¯„åœå‚·å®³
                    AudioSys.playExplosion();
                    // ç•«å€‹çˆ†ç‚¸åœˆ
                    game.particles.push(new ExplosionRing(this.x, this.y, config.splashRadius, config.color));
                    
                    game.enemies.forEach(e => {
                        if (Math.hypot(e.x - this.x, e.y - this.y) <= config.splashRadius) {
                            e.takeDamage(this.damage);
                        }
                    });
                } else {
                    // å–®é«”
                    enemy.takeDamage(this.damage);
                    if (config.type === 'slow') {
                        enemy.frozenTimer = 60; // ç·©é€Ÿ 1 ç§’ (60 frames)
                        AudioSys.playHit();
                    }
                }
            }

            draw(ctx) {
                const config = TOWER_TYPES[this.type];
                ctx.fillStyle = config.bulletColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.life = 1.0;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.05;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class ExplosionRing {
            constructor(x, y, maxR, color) {
                this.x = x;
                this.y = y;
                this.r = 5;
                this.maxR = maxR;
                this.color = color;
                this.life = 1.0;
            }
            update() {
                this.r += 5;
                this.life -= 0.08;
            }
            draw(ctx) {
                if (this.life <= 0) return;
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // ==========================================
        // 3. éŠæˆ²ä¸»æ§ (Game Manager)
        // ==========================================
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;

                // ç‹€æ…‹
                this.lives = 20;
                this.money = 100;
                this.wave = 1;
                this.isPlaying = false;
                this.isPaused = false;
                this.speedMultiplier = 1;

                // å¯¦é«”
                this.towers = [];
                this.enemies = [];
                this.projectiles = [];
                this.particles = [];
                
                // æ³¢æ¬¡ç®¡ç†
                this.waveActive = false;
                this.enemiesToSpawn = [];
                this.spawnTimer = 0;

                // äº’å‹•
                this.selectedTowerType = null; // æº–å‚™å»ºé€ çš„å¡”
                this.selectedTower = null; // åœ°åœ–ä¸Šå·²é¸ä¸­çš„å¡” (å‡ç´šç”¨)
                
                this.setupInput();
                this.setupUI();
                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            // --- åˆå§‹åŒ–èˆ‡UI ---
            setupUI() {
                const menu = document.getElementById('build-menu');
                for (let key in TOWER_TYPES) {
                    const t = TOWER_TYPES[key];
                    const btn = document.createElement('div');
                    btn.className = 'tower-btn';
                    btn.onclick = () => this.selectTowerType(key, btn);
                    btn.innerHTML = `
                        <div class="tower-icon" style="background:${t.color}"></div>
                        <div class="tower-cost">$${t.cost}</div>
                        <div class="tower-name">${t.name.split(' ')[0]}</div>
                    `;
                    menu.appendChild(btn);
                }
                this.updateInfoDisplay();
            }

            setupInput() {
                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.handleInput(x, y);
                });
            }

            // --- æ ¸å¿ƒé‚è¼¯ ---
            
            handleInput(x, y) {
                const c = Math.floor(x / TILE_SIZE);
                const r = Math.floor(y / TILE_SIZE);

                // æª¢æŸ¥é»æ“Šæ˜¯å¦åœ¨ä»»ä½•å¡”ä¸Š
                const clickedTower = this.towers.find(t => t.c === c && t.r === r);

                if (clickedTower) {
                    this.selectedTower = clickedTower;
                    this.selectedTowerType = null; // å–æ¶ˆå»ºé€ æ¨¡å¼
                    this.updateSelectionUI();
                    this.highlightBuildBtn(null);
                    return;
                }

                // å¦‚æœè™•æ–¼å»ºé€ æ¨¡å¼
                if (this.selectedTowerType) {
                    if (this.canBuild(c, r)) {
                        this.buildTower(c, r, this.selectedTowerType);
                    } else {
                        AudioSys.playError();
                    }
                } else {
                    // é»æ“Šç©ºåœ°ï¼Œå–æ¶ˆé¸å–
                    this.selectedTower = null;
                    document.getElementById('upgrade-panel').classList.remove('visible');
                }
            }

            canBuild(c, r) {
                // é‚Šç•Œæª¢æŸ¥
                if (c < 0 || c >= COLS || r < 0 || r >= ROWS) return false;
                // è·¯å¾‘æª¢æŸ¥
                if (this.isPath(c, r)) return false;
                // é‡ç–Šæª¢æŸ¥
                if (this.towers.some(t => t.c === c && t.r === r)) return false;
                // é‡‘éŒ¢æª¢æŸ¥
                if (this.money < TOWER_TYPES[this.selectedTowerType].cost) return false;
                
                return true;
            }

            isPath(c, r) {
                // ç°¡å–®æª¢æŸ¥ï¼šé»æ˜¯å¦åœ¨è·¯å¾‘ç·šæ®µä¸Š
                for (let i = 0; i < PATH_POINTS.length - 1; i++) {
                    const p1 = PATH_POINTS[i];
                    const p2 = PATH_POINTS[i+1];
                    
                    // æ°´å¹³ç·šæ®µ
                    if (p1.y === p2.y && r === p1.y) {
                        if (c >= Math.min(p1.x, p2.x) && c <= Math.max(p1.x, p2.x)) return true;
                    }
                    // å‚ç›´ç·šæ®µ
                    if (p1.x === p2.x && c === p1.x) {
                        if (r >= Math.min(p1.y, p2.y) && r <= Math.max(p1.y, p2.y)) return true;
                    }
                }
                return false;
            }

            buildTower(c, r, typeKey) {
                const cost = TOWER_TYPES[typeKey].cost;
                this.money -= cost;
                const newTower = new Tower(c, r, typeKey);
                this.towers.push(newTower);
                this.recalcBuffs(); // æ›´æ–° Buff
                AudioSys.playBuild();
                this.updateInfoDisplay();
            }

            selectTowerType(key, btnElement) {
                if (this.selectedTowerType === key) {
                    // å–æ¶ˆé¸æ“‡
                    this.selectedTowerType = null;
                    this.highlightBuildBtn(null);
                } else {
                    this.selectedTowerType = key;
                    this.selectedTower = null; // å–æ¶ˆå¡”é¸å–
                    document.getElementById('upgrade-panel').classList.remove('visible');
                    this.highlightBuildBtn(btnElement);
                }
            }

            highlightBuildBtn(activeBtn) {
                const btns = document.querySelectorAll('.tower-btn');
                btns.forEach(b => b.classList.remove('active'));
                if (activeBtn) activeBtn.classList.add('active');
            }

            // --- æ³¢æ¬¡ç³»çµ± ---

            startNextWave() {
                if (this.waveActive) return;
                this.waveActive = true;
                document.getElementById('next-wave-btn').disabled = true;
                
                this.generateWave(this.wave);
            }

            generateWave(w) {
                // æ³¢æ¬¡è¨­å®š
                let count = 0;
                let type = 'NORMAL';
                
                // æ³¢æ¬¡é‚è¼¯
                this.enemiesToSpawn = [];
                const mult = Math.pow(1.2, w - 1); // é›£åº¦ä¿‚æ•¸

                if (w === 1) {
                    this.queueEnemy('NORMAL', 10, mult);
                } else if (w === 2) {
                    this.queueEnemy('FAST', 12, mult);
                } else if (w === 3) {
                    this.queueEnemy('NORMAL', 5, mult);
                    this.queueEnemy('FAST', 10, mult);
                } else if (w === 4) {
                    this.queueEnemy('TANK', 5, mult);
                } else if (w === 5) {
                    this.queueEnemy('NORMAL', 10, mult);
                    this.queueEnemy('TANK', 5, mult);
                    this.queueEnemy('FAST', 10, mult);
                } else {
                    // ç„¡é™æ³¢æ¬¡
                    const n = 10 + Math.floor(w * 1.5);
                    for(let i=0; i<n; i++) {
                        const r = Math.random();
                        let t = 'NORMAL';
                        if (r > 0.7) t = 'FAST';
                        if (r > 0.9) t = 'TANK';
                        this.enemiesToSpawn.push({type: t, mult: mult});
                    }
                }
            }

            queueEnemy(type, count, mult) {
                for(let i=0; i<count; i++) this.enemiesToSpawn.push({type, mult});
            }

            // --- éŠæˆ²å¾ªç’° ---

            update() {
                if (this.lives <= 0) return;
                if (this.isPaused) return;

                // 1. ç”¢ç”Ÿæ•µäºº
                if (this.waveActive && this.enemiesToSpawn.length > 0) {
                    this.spawnTimer++;
                    if (this.spawnTimer >= 40) { // Spawn rate
                        const data = this.enemiesToSpawn.shift();
                        this.enemies.push(new Enemy(data.type, data.mult));
                        this.spawnTimer = 0;
                        this.updateInfoDisplay();
                    }
                } else if (this.waveActive && this.enemiesToSpawn.length === 0 && this.enemies.length === 0) {
                    // æ³¢æ¬¡çµæŸ
                    this.waveActive = false;
                    this.wave++;
                    document.getElementById('next-wave-btn').disabled = false;
                    this.money += 50; // æ³¢æ¬¡çå‹µ
                    this.updateInfoDisplay();
                }

                // 2. å¡”æ”»æ“Š
                this.towers.forEach(t => t.update());

                // 3. å­å½ˆæ›´æ–°
                this.projectiles.forEach(p => p.update());
                this.projectiles = this.projectiles.filter(p => p.active);

                // 4. æ•µäººæ›´æ–°
                // å€’åºéæ­·ä»¥ä¾¿åˆªé™¤
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    this.enemies[i].update();
                }

                // 5. ç‰¹æ•ˆç²’å­
                this.particles.forEach(p => p.update());
                this.particles = this.particles.filter(p => p.life > 0);
            }

            draw() {
                // æ¸…ç©ºç•«å¸ƒ
                this.ctx.clearRect(0, 0, this.width, this.height);

                // ç•«ç¶²æ ¼ (é¸å¡«ï¼Œè®“ç©å®¶å¥½å°é½Š)
                this.ctx.strokeStyle = 'rgba(0,0,0,0.05)';
                this.ctx.lineWidth = 1;
                for(let c=0; c<=COLS; c++) {
                    this.ctx.beginPath(); this.ctx.moveTo(c*TILE_SIZE, 0); this.ctx.lineTo(c*TILE_SIZE, this.height); this.ctx.stroke();
                }
                for(let r=0; r<=ROWS; r++) {
                    this.ctx.beginPath(); this.ctx.moveTo(0, r*TILE_SIZE); this.ctx.lineTo(this.width, r*TILE_SIZE); this.ctx.stroke();
                }

                // ç•«è·¯å¾‘
                this.ctx.strokeStyle = COLORS.path;
                this.ctx.lineWidth = TILE_SIZE * 0.8;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.beginPath();
                PATH_POINTS.forEach((p, i) => {
                    const px = p.x * TILE_SIZE + TILE_SIZE/2;
                    const py = p.y * TILE_SIZE + TILE_SIZE/2;
                    if (i === 0) this.ctx.moveTo(px, py);
                    else this.ctx.lineTo(px, py);
                });
                this.ctx.stroke();

                // ç•«èµ·çµ‚é»
                const start = PATH_POINTS[0];
                const end = PATH_POINTS[PATH_POINTS.length-1];
                this.ctx.font = '20px Arial';
                this.ctx.fillStyle = 'blue';
                this.ctx.fillText('Start', start.x * TILE_SIZE, start.y * TILE_SIZE);
                this.ctx.fillStyle = 'red';
                this.ctx.fillText('End', end.x * TILE_SIZE, end.y * TILE_SIZE + 40);

                // ç•«å¡”
                this.towers.forEach(t => t.draw(this.ctx));

                // ç•«æ•µäºº
                this.enemies.forEach(e => e.draw(this.ctx));

                // ç•«å­å½ˆ
                this.projectiles.forEach(p => p.draw(this.ctx));

                // ç•«ç²’å­
                this.particles.forEach(p => p.draw(this.ctx));

                // ç•«é¸å–ç‹€æ…‹ (UI Overlay)
                this.drawOverlays();
            }

            drawOverlays() {
                // å»ºé€ é è¦½
                if (this.selectedTowerType) {
                    // å–å¾—æ»‘é¼ å¤§æ¦‚ä½ç½® (ç°¡å–®è™•ç†ï¼Œå¯¦éš›éœ€è¦è¿½è¹¤ mousemove)
                    // é€™è£¡åªåšç°¡å–®çš„é¸å–é¡¯ç¤ºï¼šé¡¯ç¤ºæ‰€æœ‰å¯å»ºé€ å€åŸŸæˆ–è·¯å¾‘
                }
                
                // å¦‚æœé¸ä¸­å¡”ï¼Œç•«å°„ç¨‹
                if (this.selectedTower) {
                    const t = this.selectedTower;
                    this.ctx.fillStyle = t.typeKey === 'NATURE' ? COLORS.rangeBuff : COLORS.range;
                    this.ctx.beginPath();
                    this.ctx.arc(t.x, t.y, t.range, 0, Math.PI*2);
                    this.ctx.fill();
                    
                    // é¸å–æ¡†
                    this.ctx.strokeStyle = 'white';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(t.x - 20, t.y - 20, 40, 40);
                }
            }

            loop() {
                // æ§åˆ¶éŠæˆ²é€Ÿåº¦
                const iterations = this.speedMultiplier;
                for(let i=0; i<iterations; i++) {
                    this.update();
                }
                this.draw();
                requestAnimationFrame(this.loop);
            }

            // --- è¼”åŠ©åŠŸèƒ½ ---

            enemyReachedEnd(enemy) {
                this.lives--;
                this.enemies = this.enemies.filter(e => e !== enemy);
                this.updateInfoDisplay();
                AudioSys.playError(); // æ‰£è¡€éŸ³æ•ˆ

                if (this.lives <= 0) {
                    this.gameOver();
                }
            }

            enemyKilled(enemy) {
                this.money += enemy.money;
                this.enemies = this.enemies.filter(e => e !== enemy);
                // æ­»äº¡ç‰¹æ•ˆ
                for(let i=0; i<5; i++) {
                    this.particles.push(new Particle(enemy.x, enemy.y, enemy.color));
                }
                this.updateInfoDisplay();
            }

            recalcBuffs() {
                // é‡ç½®æ‰€æœ‰å¡”çš„ç‹€æ…‹
                this.towers.forEach(t => t.buffed = false);

                // æ‰¾å‡ºè‡ªç„¶å¡”
                const buffers = this.towers.filter(t => t.typeKey === 'NATURE');
                
                buffers.forEach(buffer => {
                    this.towers.forEach(target => {
                        if (buffer === target) return;
                        const dist = Math.hypot(buffer.x - target.x, buffer.y - target.y);
                        if (dist <= buffer.range) {
                            target.buffed = true;
                        }
                    });
                });
            }

            // --- å‡ç´šèˆ‡è²©è³£ ---

            updateSelectionUI() {
                const panel = document.getElementById('upgrade-panel');
                const t = this.selectedTower;
                if (!t) {
                    panel.classList.remove('visible');
                    return;
                }

                panel.classList.add('visible');
                document.getElementById('selected-tower-name').innerText = TOWER_TYPES[t.typeKey].name;
                document.getElementById('tower-level').innerText = t.level;
                document.getElementById('tower-damage').innerText = Math.round(t.currentDamage);
                document.getElementById('tower-range').innerText = t.range;
                
                // å‡ç´šè²»ç”¨å…¬å¼ï¼šåŸºç¤è²» * 0.5 * ç­‰ç´š
                const upCost = Math.round(TOWER_TYPES[t.typeKey].cost * 0.8 * t.level);
                const sellPrice = Math.round(TOWER_TYPES[t.typeKey].cost * 0.5 + (upCost * (t.level-1) * 0.4));

                const upBtn = document.getElementById('upgrade-btn');
                upBtn.innerText = `å‡ç´š ($${upCost})`;
                upBtn.disabled = this.money < upCost;
                upBtn.onclick = () => {
                    if (this.money >= upCost) {
                        this.money -= upCost;
                        t.upgrade();
                        AudioSys.playUpgrade();
                        this.updateSelectionUI();
                        this.updateInfoDisplay();
                        // å‡ç´šå¯èƒ½æœƒå¢åŠ ç¯„åœï¼Œé‡ç®— buff
                        this.recalcBuffs();
                    }
                };

                const sellBtn = document.getElementById('sell-btn');
                sellBtn.innerText = `è³£å‡º ($${sellPrice})`;
                sellBtn.onclick = () => {
                    this.sellSelectedTower(sellPrice);
                };
            }

            sellSelectedTower(price) {
                if (!this.selectedTower) return;
                this.money += price;
                this.towers = this.towers.filter(t => t !== this.selectedTower);
                this.selectedTower = null;
                this.recalcBuffs();
                this.updateSelectionUI();
                this.updateInfoDisplay();
                AudioSys.playBuild(); // å€Ÿç”¨è²éŸ³
            }

            upgradeSelectedTower() {
                // é‚è¼¯åœ¨ updateSelectionUI çš„ onclick ä¸­å®šç¾©
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                document.getElementById('pause-btn').innerText = this.isPaused ? "ç¹¼çºŒ" : "æš«åœ";
            }

            toggleSpeed() {
                this.speedMultiplier = this.speedMultiplier === 1 ? 2 : 1;
            }

            updateInfoDisplay() {
                document.getElementById('lives-display').innerText = this.lives;
                document.getElementById('money-display').innerText = this.money;
                document.getElementById('wave-display').innerText = this.wave;
                document.getElementById('enemies-display').innerText = this.enemies.length + this.enemiesToSpawn.length;
                
                // å¦‚æœæ­£åœ¨é¸å–å¡”ï¼Œä¹Ÿè¦æ›´æ–°å‡ç´šæŒ‰éˆ•ç‹€æ…‹ï¼ˆå› ç‚ºéŒ¢è®Šäº†ï¼‰
                if (this.selectedTower) this.updateSelectionUI();
            }

            gameOver() {
                this.isPaused = true;
                document.getElementById('overlay').style.display = 'flex';
                document.getElementById('game-over-title').innerText = "GAME OVER";
                document.getElementById('game-over-score').innerText = "ä½ å­˜æ´»äº† " + (this.wave - 1) + " æ³¢";
            }

            restartGame() {
                this.lives = 20;
                this.money = 100;
                this.wave = 1;
                this.towers = [];
                this.enemies = [];
                this.projectiles = [];
                this.enemiesToSpawn = [];
                this.waveActive = false;
                this.isPaused = false;
                
                document.getElementById('overlay').style.display = 'none';
                document.getElementById('next-wave-btn').disabled = false;
                this.updateInfoDisplay();
            }
        }

        // å•Ÿå‹•éŠæˆ²
        const game = new Game();

    </script>
</body>
</html>
