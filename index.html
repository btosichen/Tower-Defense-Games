<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D è‰²å½©å¡”é˜² - ç«‹é«”å‡ç´šç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --accent: #ff9800;
            --bg-ui: rgba(255, 255, 255, 0.9);
        }
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #87CEEB; }
        
        /* UI è¦†è“‹å±¤ */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ° Canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* é ‚éƒ¨è³‡è¨Šåˆ— */
        #top-bar {
            display: flex;
            gap: 20px;
            background: var(--bg-ui);
            padding: 10px 20px;
            border-radius: 50px;
            pointer-events: auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            align-self: center;
            font-weight: bold;
            font-size: 1.2em;
        }
        .stat { display: flex; align-items: center; gap: 5px; }
        .stat span { color: #e91e63; }

        /* åº•éƒ¨æ§åˆ¶å€ */
        #bottom-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            pointer-events: auto;
            margin-bottom: 20px;
        }

        /* å»ºé€ å¡ç‰‡ */
        .tower-card {
            background: var(--bg-ui);
            width: 90px;
            padding: 10px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, border 0.2s;
            border: 3px solid transparent;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .tower-card:hover { transform: translateY(-5px); }
        .tower-card.active { border-color: #00bcd4; background: #e0f7fa; }
        .tower-color { width: 40px; height: 40px; margin: 0 auto 5px; border-radius: 50%; box-shadow: inset 0 -3px 5px rgba(0,0,0,0.2); }
        .tower-cost { color: #f57c00; font-weight: bold; }

        /* å‹•ä½œæŒ‰éˆ• */
        .action-btn {
            background: linear-gradient(45deg, #ff9800, #f57c00);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(245, 124, 0, 0.4);
            transition: transform 0.1s;
            pointer-events: auto;
        }
        .action-btn:active { transform: scale(0.95); }
        .action-btn:disabled { background: #ccc; box-shadow: none; cursor: not-allowed; }

        /* å‡ç´šæµ®å‹•è¦–çª— */
        #upgrade-panel {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--bg-ui);
            padding: 20px;
            border-radius: 15px;
            width: 220px;
            pointer-events: auto;
            display: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            animation: slideIn 0.3s;
        }
        @keyframes slideIn { from { opacity:0; transform: translate(20px, -50%); } to { opacity:1; transform: translate(0, -50%); } }
        
        .up-btn { width: 100%; padding: 10px; margin-top: 10px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; color: white; }
        .btn-upgrade { background: #4caf50; }
        .btn-sell { background: #f44336; }

        #game-over {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center; align-items: center; flex-direction: column;
            color: white; z-index: 999; pointer-events: auto;
        }
        h1 { margin: 0; font-size: 4em; color: #ffeb3b; text-shadow: 0 0 20px orange; }
    </style>
</head>
<body>

    <!-- éŠæˆ² UI -->
    <div id="ui-layer">
        <div id="top-bar">
            <div class="stat">â¤ï¸ <span id="lives-txt">20</span></div>
            <div class="stat">ğŸ’° <span id="money-txt">120</span></div>
            <div class="stat">ğŸŒŠ æ³¢æ¬¡: <span id="wave-txt">1</span></div>
            <div class="stat">ğŸ‘¾ æ•µäºº: <span id="enemies-txt">0</span></div>
        </div>

        <!-- å‡ç´šé¢æ¿ -->
        <div id="upgrade-panel">
            <h2 style="margin:0 0 10px 0; color:#333;" id="up-name">å¡”åç¨±</h2>
            <div style="color:#666; font-size:0.9em; margin-bottom:10px;">
                ç­‰ç´š: <span id="up-level" style="color:#00bcd4; font-weight:bold;">1</span><br>
                å‚·å®³: <span id="up-dmg">10</span><br>
                æ”»é€Ÿ: <span id="up-speed">æ…¢</span>
            </div>
            <button class="up-btn btn-upgrade" id="btn-upgrade" onclick="game.upgradeTower()">å‡ç´š ($50)</button>
            <button class="up-btn btn-sell" onclick="game.sellTower()">è³£å‡º ($30)</button>
            <button class="up-btn" style="background:#999;" onclick="game.closePanel()">é—œé–‰</button>
        </div>

        <div id="bottom-controls">
            <!-- å¡”åˆ—è¡¨ -->
            <div class="tower-card" onclick="game.selectBuildType('ARCHER')" id="btn-archer">
                <div class="tower-color" style="background: #ffeb3b;"></div>
                <div>ç®­å¡”</div>
                <div class="tower-cost">$30</div>
            </div>
            <div class="tower-card" onclick="game.selectBuildType('ICE')" id="btn-ice">
                <div class="tower-color" style="background: #4dd0e1;"></div>
                <div>å†°å¡”</div>
                <div class="tower-cost">$50</div>
            </div>
            <div class="tower-card" onclick="game.selectBuildType('FIRE')" id="btn-fire">
                <div class="tower-color" style="background: #f44336;"></div>
                <div>ç«å¡”</div>
                <div class="tower-cost">$80</div>
            </div>
            <div class="tower-card" onclick="game.selectBuildType('NATURE')" id="btn-nature">
                <div class="tower-color" style="background: #4caf50;"></div>
                <div>è‡ªç„¶</div>
                <div class="tower-cost">$100</div>
            </div>

            <button id="next-wave-btn" class="action-btn" onclick="game.nextWave()">ä¸‹ä¸€æ³¢ (Next Wave)</button>
        </div>
    </div>

    <div id="game-over">
        <h1>GAME OVER</h1>
        <p style="font-size: 1.5em;">æœ€çµ‚æ³¢æ¬¡: <span id="final-wave">0</span></p>
        <button class="action-btn" onclick="location.reload()">é‡æ–°é–‹å§‹</button>
    </div>

    <script>
        // ==========================================
        // 0. ç°¡å–®éŸ³æ•ˆç³»çµ± (Web Audio API)
        // ==========================================
        const AudioSys = {
            ctx: new (window.AudioContext || window.webkitAudioContext)(),
            play(type, freq, dur, vol=0.1) {
                if(this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + dur);
            },
            shoot() { this.play('square', 600, 0.1, 0.05); },
            build() { this.play('sine', 800, 0.2, 0.1); },
            boom() { this.play('sawtooth', 100, 0.4, 0.1); },
            error() { this.play('sawtooth', 150, 0.3, 0.1); }
        };

        // ==========================================
        // 1. éŠæˆ²é…ç½®èˆ‡ 3D åˆå§‹åŒ–
        // ==========================================
        const TILE_SIZE = 4; // 3D ä¸–ç•Œä¸­çš„æ ¼å­å¤§å°
        const GRID_W = 24;
        const GRID_H = 16;
        
        // è·¯å¾‘å®šç¾© (åº§æ¨™ç‚º Grid ç´¢å¼•)
        // è·¯å¾‘1: ä¸Šæ–¹è·¯å¾‘
        const PATH_1 = [
            {x:0, z:3}, {x:5, z:3}, {x:5, z:8}, {x:12, z:8}, 
            {x:12, z:4}, {x:18, z:4}, {x:18, z:10}, {x:23, z:10}
        ];
        // è·¯å¾‘2: ä¸‹æ–¹è·¯å¾‘ (ç¬¬4æ³¢å¾Œé–‹å•Ÿ)
        const PATH_2 = [
            {x:0, z:12}, {x:8, z:12}, {x:8, z:8}, {x:12, z:8}, 
            {x:12, z:4}, {x:18, z:4}, {x:18, z:10}, {x:23, z:10}
        ];

        const TOWER_DATA = {
            ARCHER: { cost: 30, range: 12, damage: 20, rate: 30, color: 0xffeb3b, name: "ç®­å¡”" },
            ICE:    { cost: 50, range: 10, damage: 8,  rate: 40, color: 0x4dd0e1, name: "å†°å¡”" },
            FIRE:   { cost: 80, range: 11, damage: 40, rate: 80, color: 0xf44336, name: "ç«å¡”" },
            NATURE: { cost: 100, range: 14, damage: 0, rate: 0,  color: 0x4caf50, name: "è‡ªç„¶å¡”" }
        };

        class Game3D {
            constructor() {
                this.lives = 20;
                this.money = 120;
                this.wave = 1;
                this.enemies = [];
                this.towers = [];
                this.projectiles = [];
                this.particles = [];
                this.waveActive = false;
                this.spawnQueue = [];

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); // å¤©ç©ºè—

                // Camera: Isometric view
                const aspect = window.innerWidth / window.innerHeight;
                const d = 40; // è¦–é‡ç¯„åœ
                this.camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
                this.camera.position.set(50, 50, 50); // è¨­ç½®é«˜è™•
                this.camera.lookAt(GRID_W * TILE_SIZE / 2, 0, GRID_H * TILE_SIZE / 2); // çœ‹å‘åœ°åœ–ä¸­å¿ƒ

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.body.appendChild(this.renderer.domElement);

                // å…‰ç…§
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
                dirLight.position.set(50, 100, 50);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                this.scene.add(dirLight);

                // åˆå§‹åŒ–åœ°åœ–
                this.grid = []; // å­˜å„²åœ°åœ–é¡å‹: 0=ç©ºåœ°, 1=è·¯å¾‘, 2=å¡”
                this.createMap();

                // äº’å‹•
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.buildType = null; // ç•¶å‰æº–å‚™å»ºé€ çš„å¡”
                this.selectedTower = null;
                
                // Ghost Tower (é è¦½)
                this.ghostMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(TILE_SIZE*0.8, TILE_SIZE, TILE_SIZE*0.8),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 })
                );
                this.ghostMesh.visible = false;
                this.scene.add(this.ghostMesh);

                // Range Indicator (å°„ç¨‹åœˆ)
                this.rangeCircle = new THREE.Mesh(
                    new THREE.RingGeometry(0.1, 0.2, 32),
                    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide })
                );
                this.rangeCircle.rotation.x = -Math.PI / 2;
                this.rangeCircle.visible = false;
                this.scene.add(this.rangeCircle);

                // äº‹ä»¶ç›£è½
                window.addEventListener('resize', () => this.onResize());
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mousedown', (e) => this.onClick(e));

                this.updateUI();
                this.animate();
            }

            createMap() {
                const geo = new THREE.BoxGeometry(TILE_SIZE, 1, TILE_SIZE);
                
                // æè³ª
                const matGrass = new THREE.MeshLambertMaterial({ color: 0x81c784 }); // è‰åœ°
                const matPath = new THREE.MeshLambertMaterial({ color: 0xffe082 });  // è·¯å¾‘ (æ²™è‰²)
                const matBase = new THREE.MeshLambertMaterial({ color: 0x5d4037 });  // åŸºåœ°

                for(let x=0; x<GRID_W; x++) {
                    this.grid[x] = [];
                    for(let z=0; z<GRID_H; z++) {
                        let type = 0;
                        // æª¢æŸ¥æ˜¯å¦åœ¨è·¯å¾‘ä¸Š
                        if (this.isPointOnPath(x, z, PATH_1) || this.isPointOnPath(x, z, PATH_2)) {
                            type = 1;
                        }

                        const mat = type === 1 ? matPath : matGrass;
                        const tile = new THREE.Mesh(geo, mat);
                        tile.position.set(x * TILE_SIZE + TILE_SIZE/2, -0.5, z * TILE_SIZE + TILE_SIZE/2);
                        tile.receiveShadow = true;
                        this.scene.add(tile);
                        this.grid[x][z] = { type: type, mesh: tile, tower: null };
                    }
                }
                
                // çµ‚é»æ¨™è¨˜
                const endP = PATH_1[PATH_1.length-1];
                const endBase = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 2), new THREE.MeshLambertMaterial({color: 0xe91e63}));
                endBase.position.set(endP.x * TILE_SIZE + TILE_SIZE/2, 1, endP.z * TILE_SIZE + TILE_SIZE/2);
                this.scene.add(endBase);
            }

            isPointOnPath(x, z, path) {
                // ç°¡å–®çš„è·¯å¾‘æª¢æŸ¥ï¼šç·šæ®µæª¢æ¸¬
                for(let i=0; i<path.length-1; i++) {
                    let p1 = path[i];
                    let p2 = path[i+1];
                    // æ°´å¹³æ®µ
                    if(p1.z === p2.z && z === p1.z) {
                        if(x >= Math.min(p1.x, p2.x) && x <= Math.max(p1.x, p2.x)) return true;
                    }
                    // å‚ç›´æ®µ
                    if(p1.x === p2.x && x === p1.x) {
                        if(z >= Math.min(p1.z, p2.z) && z <= Math.max(p1.z, p2.z)) return true;
                    }
                }
                return false;
            }

            // --- éŠæˆ²é‚è¼¯ ---

            nextWave() {
                if(this.waveActive) return;
                this.waveActive = true;
                document.getElementById('next-wave-btn').disabled = true;

                // é›£åº¦ç”Ÿæˆé‚è¼¯
                const count = 5 + Math.floor(this.wave * 1.5);
                const hpMult = Math.pow(1.2, this.wave - 1);
                
                // ç¬¬4æ³¢é–‹å§‹ï¼Œå•Ÿç”¨ç¬¬äºŒè·¯å¾‘ (æ•µäººè®Šå¤šï¼Œå‡ºç¾é»è®Šå¤š)
                const useMultiPath = this.wave >= 4;

                for(let i=0; i<count; i++) {
                    // éš¨æ©Ÿé¸æ“‡æ•µäººç¨®é¡
                    let type = 'NORMAL';
                    const r = Math.random();
                    if (r > 0.7 && this.wave > 1) type = 'FAST';
                    if (r > 0.9 && this.wave > 3) type = 'TANK';

                    // æ±ºå®šè·¯å¾‘
                    let path = PATH_1;
                    if (useMultiPath && Math.random() > 0.5) path = PATH_2;

                    this.spawnQueue.push({ type, hpMult, path, delay: i * 40 });
                }
            }

            spawnEnemy() {
                if(this.spawnQueue.length === 0) return;
                
                // å–å‡ºä¸¦æª¢æŸ¥å»¶é²
                const next = this.spawnQueue[0];
                if(next.delay > 0) {
                    next.delay--;
                    return;
                }

                this.spawnQueue.shift();
                const enemy = new Enemy(next.type, next.hpMult, next.path);
                this.enemies.push(enemy);
                this.scene.add(enemy.mesh);
            }

            update() {
                if (this.lives <= 0) return;

                // 1. ç”Ÿæˆæ•µäºº
                if (this.waveActive) {
                    this.spawnEnemy();
                    if (this.spawnQueue.length === 0 && this.enemies.length === 0) {
                        this.endWave();
                    }
                }

                // 2. æ›´æ–°æ•µäºº
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const e = this.enemies[i];
                    const reached = e.update();
                    if (reached) {
                        this.lives--;
                        AudioSys.error();
                        this.removeEnemy(e);
                        if(this.lives <= 0) this.gameOver();
                    }
                }

                // 3. æ›´æ–°å¡”
                this.towers.forEach(t => t.update(this.enemies));

                // 4. æ›´æ–°å­å½ˆ
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const p = this.projectiles[i];
                    if (!p.active) {
                        this.scene.remove(p.mesh);
                        this.projectiles.splice(i, 1);
                    } else {
                        p.update();
                    }
                }

                // 5. ç²’å­ç‰¹æ•ˆ
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    if(!this.particles[i].update()) {
                        this.scene.remove(this.particles[i].mesh);
                        this.particles.splice(i, 1);
                    }
                }

                this.updateUI();
            }

            endWave() {
                this.waveActive = false;
                this.wave++;
                this.money += 50 + (this.wave * 10);
                document.getElementById('next-wave-btn').disabled = false;
                AudioSys.build(); // æç¤ºéŸ³
            }

            removeEnemy(e) {
                this.scene.remove(e.mesh);
                e.dispose(); // æ¸…ç†è³‡æº
                const idx = this.enemies.indexOf(e);
                if (idx > -1) this.enemies.splice(idx, 1);
            }

            // --- äº’å‹•æ“ä½œ ---

            selectBuildType(type) {
                // UI æ›´æ–°
                document.querySelectorAll('.tower-card').forEach(el => el.classList.remove('active'));
                
                // ä¿®æ­£ï¼šå¦‚æœ type ç‚º null (å–æ¶ˆå»ºé€ )ï¼Œç›´æ¥è¿”å›
                if (type === null) {
                    this.buildType = null;
                    this.ghostMesh.visible = false;
                    this.rangeCircle.visible = false;
                    return;
                }
                
                if (this.buildType === type) {
                    this.buildType = null; // å–æ¶ˆ
                    this.ghostMesh.visible = false;
                    this.rangeCircle.visible = false;
                    return;
                }
                
                this.buildType = type;
                document.getElementById(`btn-${type.toLowerCase()}`).classList.add('active');
                
                // é—œé–‰å‡ç´šé¢æ¿
                this.closePanel();
                
                // é¡¯ç¤ºé è¦½ç¯„åœåœˆ
                this.rangeCircle.visible = true;
                const data = TOWER_DATA[type];
                // é‡æ–°ç¸®æ”¾åœˆåœˆ
                this.rangeCircle.geometry = new THREE.RingGeometry(data.range * TILE_SIZE - 0.5, data.range * TILE_SIZE, 64);
            }

            getGridPos(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                // Raycast against a mathematical plane at y=0
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const target = new THREE.Vector3();
                this.raycaster.ray.intersectPlane(plane, target);
                
                if (target) {
                    const gx = Math.floor(target.x / TILE_SIZE);
                    const gz = Math.floor(target.z / TILE_SIZE);
                    return { x: gx, z: gz, worldX: gx * TILE_SIZE + TILE_SIZE/2, worldZ: gz * TILE_SIZE + TILE_SIZE/2 };
                }
                return null;
            }

            onMouseMove(e) {
                const pos = this.getGridPos(e);
                if (pos && pos.x >= 0 && pos.x < GRID_W && pos.z >= 0 && pos.z < GRID_H) {
                    // ç§»å‹• Ghost
                    if (this.buildType) {
                        this.ghostMesh.position.set(pos.worldX, 0.5, pos.worldZ);
                        this.ghostMesh.visible = true;
                        
                        // æª¢æŸ¥èƒ½å¦å»ºé€ 
                        const cell = this.grid[pos.x][pos.z];
                        const canBuild = cell.type === 0 && cell.tower === null;
                        this.ghostMesh.material.color.setHex(canBuild ? 0x00ff00 : 0xff0000);

                        this.rangeCircle.position.set(pos.worldX, 0.5, pos.worldZ);
                    }
                } else {
                    this.ghostMesh.visible = false;
                }
            }

            onClick(e) {
                const pos = this.getGridPos(e);
                if (!pos) return;
                if (pos.x < 0 || pos.x >= GRID_W || pos.z < 0 || pos.z >= GRID_H) return;

                const cell = this.grid[pos.x][pos.z];

                if (this.buildType) {
                    // å»ºé€ æ¨¡å¼
                    if (cell.type === 0 && cell.tower === null) {
                        if (this.money >= TOWER_DATA[this.buildType].cost) {
                            this.buildTower(pos.x, pos.z, this.buildType);
                        } else {
                            AudioSys.error();
                        }
                    }
                } else {
                    // é¸æ“‡æ¨¡å¼
                    if (cell.tower) {
                        this.selectTower(cell.tower);
                    } else {
                        this.closePanel();
                    }
                }
            }

            buildTower(gx, gz, type) {
                this.money -= TOWER_DATA[type].cost;
                const t = new Tower(gx, gz, type);
                this.scene.add(t.mesh);
                this.towers.push(t);
                this.grid[gx][gz].tower = t;
                
                // ç‰¹æ•ˆ
                AudioSys.build();
                this.particles.push(new EffectParticle(t.mesh.position.x, 2, t.mesh.position.z, 0xffffff));

                this.selectBuildType(null); // çµæŸå»ºé€ 
                this.updateUI();
            }

            selectTower(tower) {
                this.selectedTower = tower;
                this.rangeCircle.visible = true;
                this.rangeCircle.position.set(tower.mesh.position.x, 0.5, tower.mesh.position.z);
                // è¨­ç½®ç¯„åœåœˆå¤§å°
                const r = tower.getRange() * TILE_SIZE;
                this.rangeCircle.geometry = new THREE.RingGeometry(r-0.5, r, 64);

                // UI
                const p = document.getElementById('upgrade-panel');
                p.style.display = 'block';
                document.getElementById('up-name').innerText = TOWER_DATA[tower.type].name;
                this.updatePanelInfo();
            }

            updatePanelInfo() {
                if (!this.selectedTower) return;
                const t = this.selectedTower;
                const cost = Math.floor(TOWER_DATA[t.type].cost * 0.8 * t.level);
                
                document.getElementById('up-level').innerText = t.level;
                document.getElementById('up-dmg').innerText = Math.floor(t.getDamage());
                document.getElementById('btn-upgrade').innerText = `å‡ç´š ($${cost})`;
                document.getElementById('btn-upgrade').disabled = this.money < cost;
            }

            upgradeTower() {
                if(!this.selectedTower) return;
                const t = this.selectedTower;
                const cost = Math.floor(TOWER_DATA[t.type].cost * 0.8 * t.level);
                
                if (this.money >= cost) {
                    this.money -= cost;
                    t.upgrade();
                    AudioSys.build();
                    // ç‰¹æ•ˆ
                    this.particles.push(new EffectParticle(t.mesh.position.x, 4, t.mesh.position.z, 0xffff00));
                    this.updatePanelInfo();
                    this.updateUI();
                }
            }

            sellTower() {
                if(!this.selectedTower) return;
                const t = this.selectedTower;
                // è³£å‡ºåƒ¹æ ¼
                const val = Math.floor(TOWER_DATA[t.type].cost * 0.5 * t.level);
                this.money += val;
                
                this.scene.remove(t.mesh);
                this.grid[t.gx][t.gz].tower = null;
                this.towers = this.towers.filter(x => x !== t);
                
                AudioSys.build();
                this.closePanel();
                this.updateUI();
            }

            closePanel() {
                this.selectedTower = null;
                document.getElementById('upgrade-panel').style.display = 'none';
                if (!this.buildType) this.rangeCircle.visible = false;
            }

            updateUI() {
                document.getElementById('lives-txt').innerText = this.lives;
                document.getElementById('money-txt').innerText = this.money;
                document.getElementById('wave-txt').innerText = this.wave;
                document.getElementById('enemies-txt').innerText = this.spawnQueue.length + this.enemies.length;
                
                if(this.selectedTower) this.updatePanelInfo();
            }

            gameOver() {
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('final-wave').innerText = this.wave;
                this.renderer.setAnimationLoop(null); // åœæ­¢æ¸²æŸ“
            }

            onResize() {
                const aspect = window.innerWidth / window.innerHeight;
                const d = 40;
                this.camera.left = -d * aspect;
                this.camera.right = d * aspect;
                this.camera.top = d;
                this.camera.bottom = -d;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                this.renderer.setAnimationLoop(() => {
                    this.update();
                    this.renderer.render(this.scene, this.camera);
                });
            }
        }

        // ==========================================
        // 2. å¯¦é«”é¡åˆ¥
        // ==========================================

        class Enemy {
            constructor(type, hpMult, path) {
                this.type = type;
                this.path = path;
                this.pathIdx = 0;
                this.hpMax = 30 * hpMult;
                this.speed = 0.1;
                this.color = 0xff0000;
                this.reward = 10;
                this.isSlowed = 0;

                // æ ¹æ“šé¡å‹è¨­å®šå¤–è§€
                let geo;
                if (type === 'NORMAL') {
                    geo = new THREE.SphereGeometry(1.2, 16, 16);
                    this.color = 0x7e57c2; // ç´«
                    this.speed = 0.12;
                    this.hpMax = 30 * hpMult;
                } else if (type === 'FAST') {
                    geo = new THREE.ConeGeometry(1, 2, 8);
                    this.color = 0xff4081; // ç²‰
                    this.speed = 0.2;
                    this.hpMax = 20 * hpMult;
                } else if (type === 'TANK') {
                    geo = new THREE.BoxGeometry(2, 2, 2);
                    this.color = 0x3e2723; // è¤
                    this.speed = 0.06;
                    this.hpMax = 80 * hpMult;
                    this.reward = 25;
                }

                this.hp = this.hpMax;
                this.mesh = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ color: this.color }));
                this.mesh.castShadow = true;
                
                // åˆå§‹ä½ç½®
                const start = this.path[0];
                this.mesh.position.set(start.x * TILE_SIZE + TILE_SIZE/2, 1.5, start.z * TILE_SIZE + TILE_SIZE/2);
                
                // è¡€æ¢
                const barGeo = new THREE.PlaneGeometry(3, 0.5);
                const barMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
                this.hpBar = new THREE.Mesh(barGeo, barMat);
                this.hpBar.position.y = 3;
                // è®“è¡€æ¢æ°¸é æœå‘ç›¸æ©Ÿ
                this.hpBar.quaternion.copy(game.camera.quaternion);
                this.mesh.add(this.hpBar);
            }

            update() {
                // ç·©é€Ÿæ¢å¾©
                let currentSpeed = this.speed;
                if (this.isSlowed > 0) {
                    currentSpeed *= 0.5;
                    this.isSlowed--;
                    this.mesh.material.color.setHex(0x80deea); // è®Šè—
                } else {
                    this.mesh.material.color.setHex(this.color);
                }

                // ç§»å‹•
                const targetNode = this.path[this.pathIdx + 1];
                if (!targetNode) return true; // åˆ°é”çµ‚é»

                const tx = targetNode.x * TILE_SIZE + TILE_SIZE/2;
                const tz = targetNode.z * TILE_SIZE + TILE_SIZE/2;

                const dx = tx - this.mesh.position.x;
                const dz = tz - this.mesh.position.z;
                const dist = Math.sqrt(dx*dx + dz*dz);

                if (dist < currentSpeed) {
                    this.mesh.position.x = tx;
                    this.mesh.position.z = tz;
                    this.pathIdx++;
                    // æ—‹è½‰é¢å‘
                    if(this.path[this.pathIdx+1]) {
                        this.mesh.lookAt(
                            this.path[this.pathIdx+1].x * TILE_SIZE + TILE_SIZE/2,
                            1.5,
                            this.path[this.pathIdx+1].z * TILE_SIZE + TILE_SIZE/2
                        );
                    }
                } else {
                    this.mesh.position.x += (dx/dist) * currentSpeed;
                    this.mesh.position.z += (dz/dist) * currentSpeed;
                }

                return false;
            }

            takeDamage(amt) {
                this.hp -= amt;
                // æ›´æ–°è¡€æ¢
                const pct = Math.max(0, this.hp / this.hpMax);
                this.hpBar.scale.x = pct;
                this.hpBar.material.color.setHex(pct > 0.5 ? 0x00ff00 : 0xff0000);

                if (this.hp <= 0) {
                    game.money += this.reward;
                    game.removeEnemy(this);
                    game.particles.push(new EffectParticle(this.mesh.position.x, 1.5, this.mesh.position.z, this.color));
                }
            }
            
            dispose() {
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        class Tower {
            constructor(gx, gz, type) {
                this.gx = gx;
                this.gz = gz;
                this.type = type;
                this.level = 1;
                this.cooldown = 0;
                this.buffed = false;

                const data = TOWER_DATA[type];
                
                // 3D æ¨¡å‹çµ„åˆ
                this.mesh = new THREE.Group();
                this.mesh.position.set(gx * TILE_SIZE + TILE_SIZE/2, 0, gz * TILE_SIZE + TILE_SIZE/2);

                // åº•åº§
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.8, 2, 1, 8),
                    new THREE.MeshLambertMaterial({ color: 0xeeeeee })
                );
                base.position.y = 0.5;
                this.mesh.add(base);

                // å¡”èº«
                let bodyGeo;
                if (type === 'ARCHER') bodyGeo = new THREE.CylinderGeometry(0.5, 1, 3);
                if (type === 'ICE') bodyGeo = new THREE.BoxGeometry(1.5, 3, 1.5);
                if (type === 'FIRE') bodyGeo = new THREE.CylinderGeometry(1.2, 1.2, 2.5);
                if (type === 'NATURE') bodyGeo = new THREE.ConeGeometry(1.5, 4, 4); // æ¨¹å½¢

                const body = new THREE.Mesh(bodyGeo, new THREE.MeshLambertMaterial({ color: data.color }));
                body.position.y = 2;
                body.castShadow = true;
                this.mesh.add(body);
                this.bodyMesh = body; // ç”¨æ–¼æ—‹è½‰

                // ç ²ç®¡ (Nature é™¤å¤–)
                if (type !== 'NATURE') {
                    const turret = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 0.5, 2),
                        new THREE.MeshLambertMaterial({ color: 0x333333 })
                    );
                    turret.position.y = 1;
                    turret.position.z = 1; // å‘å‰ä¼¸
                    body.add(turret);
                }

                // ç­‰ç´šæ¨™ç¤º
                this.lvlMarker = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3),
                    new THREE.MeshBasicMaterial({color:0x000000})
                );
                this.lvlMarker.position.y = 4.5;
                this.mesh.add(this.lvlMarker);
            }

            getDamage() {
                const base = TOWER_DATA[this.type].damage;
                let dmg = base * Math.pow(1.3, this.level - 1);
                if(this.buffed) dmg *= 1.2;
                return dmg;
            }

            getRange() {
                return TOWER_DATA[this.type].range;
            }

            update(enemies) {
                // è‡ªç„¶å¡”é‚è¼¯ï¼šBuff å‘¨åœ
                if (this.type === 'NATURE') {
                    game.towers.forEach(t => {
                        if(t === this) return;
                        const d = this.mesh.position.distanceTo(t.mesh.position);
                        if (d <= this.getRange() * TILE_SIZE) {
                            t.buffed = true;
                        }
                    });
                    // è‡ªè½‰æ•ˆæœ
                    this.bodyMesh.rotation.y += 0.02;
                    return;
                }

                this.buffed = false; // æ¯å¹€é‡ç½®ï¼Œä¾é è‡ªç„¶å¡”é‡æ–°è³¦å€¼

                if (this.cooldown > 0) {
                    this.cooldown--;
                    return;
                }

                // å°‹æ‰¾ç›®æ¨™
                let target = null;
                let minDist = this.getRange() * TILE_SIZE;

                for (let e of enemies) {
                    const d = this.mesh.position.distanceTo(e.mesh.position);
                    if (d < minDist) {
                        minDist = d;
                        target = e;
                    }
                }

                if (target) {
                    // è½‰å‘æ•µäºº
                    this.bodyMesh.lookAt(target.mesh.position);
                    
                    // æ”»æ“Š
                    this.fire(target);
                    let rate = TOWER_DATA[this.type].rate;
                    if(this.buffed) rate *= 0.8;
                    this.cooldown = rate;
                }
            }

            fire(target) {
                const dmg = this.getDamage();
                AudioSys.shoot();

                if (this.type === 'FIRE') { // ç¯„åœå‚·å®³å­å½ˆ
                    game.projectiles.push(new Projectile(this.mesh.position, target, 'AOE', dmg));
                } else if (this.type === 'ICE') {
                    game.projectiles.push(new Projectile(this.mesh.position, target, 'SLOW', dmg));
                } else {
                    game.projectiles.push(new Projectile(this.mesh.position, target, 'NORMAL', dmg));
                }
            }

            upgrade() {
                this.level++;
                // è¦–è¦ºè®ŠåŒ–ï¼šè®Šå¤§ä¸€é»
                const s = 1 + (this.level * 0.1);
                this.mesh.scale.set(s, s, s);
            }
        }

        class Projectile {
            constructor(startPos, target, type, dmg) {
                this.pos = startPos.clone().add(new THREE.Vector3(0, 2, 0));
                this.target = target;
                this.type = type;
                this.dmg = dmg;
                this.speed = 0.8;
                this.active = true;

                let color = 0xffff00;
                if(type === 'SLOW') color = 0x00ffff;
                if(type === 'AOE') color = 0xff5722;

                this.mesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4),
                    new THREE.MeshBasicMaterial({ color: color })
                );
                this.mesh.position.copy(this.pos);
                game.scene.add(this.mesh);
            }

            update() {
                if (!this.target || this.target.hp <= 0) {
                    this.active = false;
                    return;
                }

                const dir = new THREE.Vector3().subVectors(this.target.mesh.position, this.mesh.position).normalize();
                this.mesh.position.add(dir.multiplyScalar(this.speed));

                if (this.mesh.position.distanceTo(this.target.mesh.position) < 1) {
                    this.hit();
                }
            }

            hit() {
                this.active = false;
                if (this.type === 'AOE') {
                    AudioSys.boom();
                    // çˆ†ç‚¸ç¯„åœ
                    game.enemies.forEach(e => {
                        if (e.mesh.position.distanceTo(this.mesh.position) < 3 * TILE_SIZE) {
                            e.takeDamage(this.dmg);
                        }
                    });
                    game.particles.push(new EffectParticle(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z, 0xff5722, 2));
                } else {
                    this.target.takeDamage(this.dmg);
                    if (this.type === 'SLOW') {
                        this.target.isSlowed = 60; // ç·©é€Ÿ
                    }
                }
            }
        }

        class EffectParticle {
            constructor(x, y, z, color, scale=1) {
                this.mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5*scale, 0.5*scale, 0.5*scale),
                    new THREE.MeshBasicMaterial({color: color, transparent:true})
                );
                this.mesh.position.set(x, y, z);
                // éš¨æ©Ÿé€Ÿåº¦
                this.vel = new THREE.Vector3((Math.random()-0.5), Math.random(), (Math.random()-0.5)).multiplyScalar(0.3);
                game.scene.add(this.mesh);
                this.life = 1.0;
            }
            update() {
                this.mesh.position.add(this.vel);
                this.life -= 0.05;
                this.mesh.material.opacity = this.life;
                this.mesh.rotation.x += 0.1;
                this.mesh.rotation.y += 0.1;
                return this.life > 0;
            }
        }

        // å•Ÿå‹•
        const game = new Game3D();

    </script>
</body>
</html>
