<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ¥µé™å¡”é˜² - ç›œè³Šæ©«è¡Œ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --accent: #d50000;
            --bg-ui: rgba(255, 255, 255, 0.95);
            --text-color: #333;
        }
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #4fc3f7; color: var(--text-color); user-select: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        #top-bar {
            display: flex; gap: 15px; background: var(--bg-ui); padding: 12px 25px;
            border-radius: 50px; pointer-events: auto; border-bottom: 4px solid var(--accent);
            align-self: center; font-weight: bold; font-size: 1.2em;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15); color: #444;
            align-items: center; flex-wrap: wrap;
        }
        .stat { display: flex; align-items: center; gap: 5px; }
        .stat span { color: #d32f2f; font-family: monospace; font-size: 1.2em; }
        .stat.money span { color: #f57f17; }
        .stat.animals span { color: #0277bd; }

        .icon-btn {
            background: #eee; border: none; border-radius: 50%; 
            width: 35px; height: 35px; cursor: pointer; font-weight: bold; font-size: 1.2em;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); transition: transform 0.1s, background 0.2s; margin-left: 5px;
        }
        .icon-btn:active { transform: scale(0.9); }
        
        #heal-btn { background: #00e676; color: white; }
        #heal-btn:hover { background: #00c853; }
        
        #bgm-toggle.active { background: #76ff03; color: #33691e; }
        
        #pause-btn { background: #ffeb3b; color: #f57f17; }
        #pause-btn:hover { background: #fdd835; }
        #pause-btn.paused { background: #ff9800; color: white; animation: pulse 1s infinite; }
        
        #daynight-btn { background: #90caf9; color: #fff; }
        #daynight-btn.night { background: #283593; color: #ffeb3b; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        .heal-cost { font-size: 0.6em; color: #666; margin-left: 2px; margin-right: 10px; }

        #bottom-controls {
            display: flex; justify-content: center; align-items: flex-end; gap: 10px;
            pointer-events: auto; margin-bottom: 20px; flex-wrap: wrap;
        }

        .control-group {
            display: flex; gap: 10px; background: rgba(255,255,255,0.5); 
            padding: 10px; border-radius: 20px; backdrop-filter: blur(5px);
        }

        .tower-card {
            background: var(--bg-ui); width: 85px; padding: 8px; border-radius: 12px;
            text-align: center; cursor: pointer; transition: all 0.2s; border: 3px solid #fff;
            position: relative; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .tower-card:hover { transform: translateY(-8px); border-color: var(--accent); }
        .tower-card.active { border-color: var(--accent); background: #fff3e0; transform: translateY(-8px); }
        .tower-card.farm { border-color: #aed581; }
        .tower-card.farm.active { border-color: #76ff03; background: #f1f8e9; }
        .tower-card.super { border-color: #212121; background: #cfd8dc; }
        .tower-card.super.active { border-color: #000; background: #90a4ae; color: white; }
        
        .tower-icon { 
            width: 40px; height: 40px; margin: 0 auto 5px; border-radius: 10px; 
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1); display: flex; 
            justify-content: center; align-items: center; font-size: 20px;
            border: 2px solid rgba(0,0,0,0.05);
        }
        .tower-cost { color: #e65100; font-weight: bold; font-size: 0.85em; }
        .tower-name { font-size: 0.75em; margin-bottom: 2px; color: #555; }

        .action-btn {
            background: linear-gradient(45deg, #ff6d00, #ff9100); color: white; border: none;
            padding: 15px 30px; border-radius: 50px; font-size: 1.1em; font-weight: bold;
            cursor: pointer; box-shadow: 0 5px 15px rgba(255, 109, 0, 0.4);
            transition: transform 0.1s; pointer-events: auto; height: 70px;
            align-self: center;
        }
        .action-btn:active { transform: scale(0.95); }
        .action-btn:disabled { background: #ccc; cursor: not-allowed; opacity: 0.7; box-shadow: none; }

        #upgrade-panel {
            position: absolute; right: 20px; top: 50%; transform: translateY(-50%);
            background: var(--bg-ui); padding: 20px; border-radius: 20px; width: 240px;
            pointer-events: auto; display: none; border: 2px solid #fff;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
        }
        .up-info { margin-bottom: 15px; line-height: 1.6; font-size: 0.95em; color: #555; }
        .up-val { color: #0277bd; font-weight: bold; float: right; }
        .up-btn { width: 100%; padding: 12px; margin-top: 8px; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; color: white; transition: 0.2s; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .btn-upgrade { background: #43a047; } .btn-upgrade:hover { background: #2e7d32; }
        .btn-sell { background: #e53935; } .btn-sell:hover { background: #c62828; }
        .btn-close { background: #78909c; }

        #game-over {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none;
            justify-content: center; align-items: center; flex-direction: column;
            color: white; z-index: 999; pointer-events: auto; backdrop-filter: blur(5px);
        }
        h1 { margin: 0; font-size: 5em; color: #ffeb3b; text-shadow: 0 0 20px #ff6d00; text-transform: uppercase; letter-spacing: 5px; }
        
        .diff-tag {
            position: absolute; top: 10px; left: 10px;
            background: rgba(255,255,255,0.9); color: #d50000;
            padding: 5px 15px; border-radius: 20px; font-size: 0.9em;
            pointer-events: auto; font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        #tower-destroyed-msg {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            color: red; font-weight: bold; font-size: 2em; text-shadow: 0 0 10px white;
            opacity: 0; pointer-events: none; transition: opacity 0.5s; z-index: 900;
        }
        
        .hp-bar-bg { width: 100%; height: 6px; background: #ddd; border-radius: 3px; margin-top: 5px; overflow: hidden; }
        .hp-bar-fill { height: 100%; background: #00e676; width: 100%; transition: width 0.2s; }
        
        .float-text {
            position: absolute; color: #ffd740; font-weight: bold; font-size: 1.5em; 
            text-shadow: 0 0 5px black; pointer-events: none; animation: floatUp 1s forwards;
        }
        .float-text.bad { color: #ff1744; font-size: 1.8em; }
        .float-text.wood { color: #795548; font-size: 1.8em; }
        .float-text.crit { color: #ffeb3b; font-size: 2em; text-shadow: 0 0 10px #ff6d00; }
        @keyframes floatUp { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-50px); opacity: 0; } }
        
        #pause-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.3); pointer-events: none; display: none;
            justify-content: center; align-items: center; color: white; font-size: 3em; font-weight: bold;
            text-shadow: 0 0 20px black; z-index: 800;
        }
        
        #level-up-overlay, #victory-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none; z-index: 950;
            justify-content: center; align-items: center; flex-direction: column; color: white;
        }
        
        #drag-hint {
            position: absolute; bottom: 20px; left: 20px; color: rgba(255,255,255,0.7); 
            font-size: 0.9em; pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="diff-tag">æ¥µé™å¡”é˜²: æŠ“èœèŸ² | é˜²å°å· | æ””æˆªç©ºæŠ•å¤§ç›œ</div>
    <div id="tower-destroyed-msg">âš ï¸ å¡”è¢«æ‘§æ¯€ï¼</div>
    <div id="pause-overlay">å·²æš«åœ</div>
    <div id="drag-hint">ğŸ’¡ æç¤º: æŒ‰ä½æ»‘é¼ å·¦éµå¯æ‹–æ›³åœ°åœ– | é»æ“Šç©ºæŠ•ç®±ç²å–çå‹µ</div>
    
    <div id="level-up-overlay">
        <h1 style="color:#76ff03">é—œå¡å®Œæˆ!</h1>
        <p style="font-size:1.5em">åœ°åœ–æ“´å¼µï¼Œæ•µäººè®Šå¤šï¼</p>
        <button class="action-btn" onclick="game.startNextLevel()">é€²å…¥ä¸‹ä¸€é—œ</button>
    </div>

    <div id="victory-overlay">
        <h1 style="color:#ffd740; font-size: 4em;">ğŸ† éŠæˆ²é€šé—œ! ğŸ†</h1>
        <p style="font-size:1.5em">ä½ æˆåŠŸå®ˆè­·äº†è¾²å ´ï¼Œæˆç‚ºäº†å‚³èªªï¼</p>
        <button class="action-btn" onclick="location.reload()">å†ä¾†ä¸€å±€</button>
    </div>

    <div id="ui-layer">
        <div id="top-bar">
            <div class="stat">é—œå¡: <span id="level-txt">1</span> / 20</div>
            <div class="stat">â¤ï¸ <span id="lives-txt">20</span></div>
            <div class="stat money">ğŸ’° <span id="money-txt">900</span></div>
            <div class="stat animals" style="margin-right:0;">ğŸ° <span id="animals-txt">3</span></div>
            <div style="display:flex; align-items:center;">
                <button id="heal-btn" class="icon-btn" onclick="game.healAnimals()" title="èŠ±è²» $500 æ²»ç™‚æ‰€æœ‰å°å‹•ç‰©">âœš</button>
                <span class="heal-cost">($500)</span>
            </div>
            
            <div class="stat" style="margin-left: 10px;">ğŸŒŠ <span id="wave-txt">1</span> / 2</div>
            <div class="stat">ğŸ‘¾ <span id="enemies-txt">0</span></div>
            <div style="flex:1;"></div>
            <button id="daynight-btn" class="icon-btn" onclick="game.toggleDayNight()" title="åˆ‡æ›æ—¥å¤œ">â˜€ï¸</button>
            <button id="pause-btn" class="icon-btn" onclick="game.togglePause()" title="æš«åœéŠæˆ²">â¸ï¸</button>
            <button id="bgm-toggle" class="icon-btn" onclick="AudioSys.toggleBGM()" title="é–‹é—œéŸ³æ¨‚">ğŸµ</button>
        </div>

        <!-- å‡ç´šé¢æ¿ -->
        <div id="upgrade-panel">
            <h2 style="margin:0 0 5px 0; color:#333; border-bottom:2px solid #ffcc80; padding-bottom:5px;" id="up-name">å¡”åç¨±</h2>
            <div style="font-size:0.8em; color:#666; margin-bottom:10px;">
                è€ä¹…åº¦: <span id="up-hp">500</span> / <span id="up-max-hp">500</span>
                <div class="hp-bar-bg"><div class="hp-bar-fill" id="up-hp-bar"></div></div>
            </div>
            <div class="up-info">
                ç­‰ç´š: <span id="up-level" class="up-val">1</span><br>
                å‚·å®³: <span id="up-dmg" class="up-val">10</span><br>
                å°„ç¨‹: <span id="up-range" class="up-val">10</span><br>
                æ”»é€Ÿ: <span id="up-speed" class="up-val">æ…¢</span>
            </div>
            <button class="up-btn btn-upgrade" id="btn-upgrade" onclick="game.upgradeTower()">å‡ç´š ($50)</button>
            <button class="up-btn btn-sell" onclick="game.sellTower()">è³£å‡º ($30)</button>
            <button class="up-btn btn-close" onclick="game.closePanel()">é—œé–‰</button>
        </div>

        <div id="bottom-controls">
            <!-- é˜²ç¦¦å¡”å€ -->
            <div class="control-group">
                <div class="tower-card" onclick="game.selectBuildType('ARCHER')" id="btn-archer">
                    <div class="tower-icon" style="background: #fff9c4; color:#fbc02d;">ğŸ¹</div>
                    <div class="tower-name">ç®­å¡”(çŸ­)</div>
                    <div class="tower-cost">$40</div>
                </div>
                <div class="tower-card" onclick="game.selectBuildType('ICE')" id="btn-ice">
                    <div class="tower-icon" style="background: #e1f5fe; color:#039be5;">â„ï¸</div>
                    <div class="tower-name">å†°å¡”(çŸ­)</div>
                    <div class="tower-cost">$70</div>
                </div>
                <div class="tower-card" onclick="game.selectBuildType('FIRE')" id="btn-fire">
                    <div class="tower-icon" style="background: #ffebee; color:#e53935;">ğŸ”¥</div>
                    <div class="tower-name">ç«å¡”(æ¥µçŸ­)</div>
                    <div class="tower-cost">$120</div>
                </div>
                <div class="tower-card" onclick="game.selectBuildType('LASER')" id="btn-laser">
                    <div class="tower-icon" style="background: #f3e5f5; color:#8e24aa;">âš¡</div>
                    <div class="tower-name">é›·å°„(å…¨)</div>
                    <div class="tower-cost">$540</div>
                </div>
                <div class="tower-card super" onclick="game.selectBuildType('CANNON')" id="btn-cannon">
                    <div class="tower-icon" style="background: #263238; color:#fff;">ğŸ’£</div>
                    <div class="tower-name">è¶…ç´šå¤§ç‚®</div>
                    <div class="tower-cost">$3000</div>
                </div>
            </div>

            <!-- è¾²è€•å€ -->
            <div class="control-group" style="background: rgba(220, 255, 220, 0.6);">
                <div class="tower-card farm" onclick="game.selectBuildType('FRUIT')" id="btn-fruit">
                    <div class="tower-icon" style="background: #ffcdd2; color:#d50000;">ğŸ</div>
                    <div class="tower-name">æ°´æœ(å¿«)</div>
                    <div class="tower-cost">$50</div>
                </div>
                <div class="tower-card farm" onclick="game.selectBuildType('VEGGIE')" id="btn-veggie">
                    <div class="tower-icon" style="background: #c8e6c9; color:#2e7d32;">ğŸƒ</div>
                    <div class="tower-name">è”¬èœ(æ…¢)</div>
                    <div class="tower-cost">$80</div>
                </div>
            </div>

            <button id="next-wave-btn" class="action-btn" onclick="game.nextWave()">ğŸ‘¹ è¿æˆ°</button>
        </div>
    </div>

    <script>
        const AudioSys = {
            ctx: new (window.AudioContext || window.webkitAudioContext)(),
            bgmInterval: null, isBgmMuted: true, bgmNoteIdx: 0,
            play(type, freq, dur, vol=0.1, type2='sine') {
                if(this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if(type2 === 'slide') osc.frequency.exponentialRampToValueAtTime(freq/2, this.ctx.currentTime + dur);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                osc.connect(gain); gain.connect(this.ctx.destination); osc.start(); osc.stop(this.ctx.currentTime + dur);
            },
            shoot() { this.play('square', 800, 0.1, 0.05, 'slide'); }, laser() { this.play('sawtooth', 1200, 0.15, 0.05, 'slide'); },
            build() { this.play('sine', 600, 0.1, 0.1); }, boom() { this.play('sawtooth', 100, 0.3, 0.15); },
            superBoom() { this.play('square', 50, 0.8, 0.5, 'slide'); }, 
            error() { this.play('triangle', 150, 0.2, 0.1); }, animalDie() { this.play('sawtooth', 50, 0.8, 0.2); },
            enemyShoot() { this.play('square', 400, 0.1, 0.05); }, towerDestroy() { this.play('sawtooth', 80, 0.5, 0.3); }, 
            heal() { this.play('sine', 400, 0.1, 0.1); setTimeout(()=>this.play('sine', 600, 0.2, 0.1), 100); },
            harvest() { this.play('sine', 1000, 0.1, 0.1); setTimeout(()=>this.play('sine', 1500, 0.2, 0.1), 100); }, 
            teleport() { this.play('sawtooth', 800, 0.3, 0.1, 'slide'); }, squish() { this.play('square', 200, 0.1, 0.1, 'slide'); }, 
            chop() { this.play('sawtooth', 100, 0.05, 0.1); }, steal() { this.play('triangle', 600, 0.1, 0.1, 'slide'); }, 
            crit() { this.play('square', 1200, 0.1, 0.1, 'slide'); }, 
            drop() { this.play('sine', 800, 0.5, 0.1); }, 

            toggleBGM() {
                this.isBgmMuted = !this.isBgmMuted; const btn = document.getElementById('bgm-toggle');
                if (!this.isBgmMuted) { if (this.ctx.state === 'suspended') this.ctx.resume(); this.startBGM(); btn.classList.add('active'); } else { this.stopBGM(); btn.classList.remove('active'); }
            },
            startBGM() {
                if (this.bgmInterval) return;
                const melody = [523,0,523,0,783,0,783,0,880,0,880,0,783,0,0,0,698,0,698,0,659,0,659,0,587,0,587,0,523,0,0,0];
                const bass = [261,261,392,392,440,440,392,392,349,349,329,329,293,293,261,261]; const tempo = 160; 
                this.bgmInterval = setInterval(() => { if (this.isBgmMuted) return; const note = melody[this.bgmNoteIdx % melody.length]; if (note > 0) this.play('triangle', note, 0.1, 0.05, 'sine'); if (this.bgmNoteIdx % 4 === 0) { const bassNote = bass[Math.floor((this.bgmNoteIdx % (bass.length*4)) / 4)]; this.play('sine', bassNote, 0.3, 0.08, 'sine'); } this.bgmNoteIdx++; }, tempo);
            },
            stopBGM() { if (this.bgmInterval) { clearInterval(this.bgmInterval); this.bgmInterval = null; } }
        };

        const TILE_SIZE = 5; 
        
        const TOWER_DATA = {
            ARCHER: { cost: 40, range: 3.5, damage: 8, rate: 40, color: 0xfdd835, name: "ç®­å¡”", type:'proj' },
            ICE:    { cost: 70, range: 3, damage: 4,  rate: 45, color: 0x4fc3f7, name: "å†°å¡”", type:'proj' },
            FIRE:   { cost: 120, range: 2.5, damage: 15, rate: 70, color: 0xff7043, name: "ç«å¡”", type:'aoe' },
            LASER:  { cost: 540, range: 16, damage: 2, rate: 0,   color: 0xe040fb, name: "é›·å°„å¡”", type:'laser' },
            CANNON: { cost: 3000, range: 15, damage: 5000, rate: 10800, color: 0x212121, name: "è¶…ç´šå¤§ç‚®", type: 'aoe_super' } 
        };

        const FARM_DATA = {
            FRUIT: { cost: 50, growTime: 300, sell: 120, name: "æ°´æœæ¨¹", color: 0xff5252, type: 'farm' }, 
            VEGGIE: { cost: 80, growTime: 900, sell: 300, name: "å¤§å—ç“œ", color: 0xff9800, type: 'farm' } 
        };

        class Game3D {
            constructor() {
                this.lives = 20; this.money = 3000; 
                this.level = 1; this.maxLevels = 20;
                this.wave = 1;
                
                this.gridW = 20; this.gridH = 15;

                this.enemies = []; this.worms = []; this.loggers = []; this.woodPiles = []; this.thieves = []; this.speedThieves = [];
                this.towers = []; this.plants = []; this.projectiles = []; this.particles = [];
                this.animals = []; this.decorations = []; this.streetLights = []; this.supplyDrops = []; 
                this.waveActive = false; this.spawnQueue = [];
                this.clock = new THREE.Clock(); this.isPaused = false; this.bossesRemainingInWave = 0; 
                this.isNight = false; 

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); 
                this.scene.fog = new THREE.Fog(0x87CEEB, 60, 250);

                const aspect = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
                this.updateCameraPos();

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                this.lights = {};
                this.lights.ambient = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(this.lights.ambient);
                
                this.lights.sun = new THREE.DirectionalLight(0xffffff, 0.9);
                this.lights.sun.position.set(50, 100, 50);
                this.lights.sun.castShadow = true;
                this.lights.sun.shadow.mapSize.width = 2048;
                this.lights.sun.shadow.mapSize.height = 2048;
                this.scene.add(this.lights.sun);

                this.isDragging = false;
                this.lastMouseX = 0; this.lastMouseY = 0; this.hasDragged = false; 

                this.grid = []; 
                this.createMap(); 
                this.createDecorations(); 
                this.initAnimals();       

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.buildType = null; 
                this.selectedTower = null;
                
                this.ghostMesh = new THREE.Group();
                const gBox = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE*0.8, TILE_SIZE, TILE_SIZE*0.8), new THREE.MeshBasicMaterial({ color: 0x76ff03, transparent: true, opacity: 0.5 }));
                this.ghostMesh.add(gBox);
                this.ghostMesh.visible = false;
                this.scene.add(this.ghostMesh);

                this.rangeCircle = new THREE.Mesh(new THREE.RingGeometry(0.1, 0.2, 64), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, side: THREE.DoubleSide }));
                this.rangeCircle.rotation.x = -Math.PI / 2;
                this.rangeCircle.visible = false;
                this.scene.add(this.rangeCircle);

                window.addEventListener('resize', () => this.onResize());
                document.addEventListener('mousedown', (e) => this.onMouseDown(e));
                document.addEventListener('mousemove', (e) => this.onMouseMove(e));
                document.addEventListener('mouseup', (e) => this.onMouseUp(e));
                window.addEventListener('click', () => { if (AudioSys.isBgmMuted) AudioSys.toggleBGM(); }, { once: true });

                this.updateUI();
                this.animate();
            }

            toggleDayNight() {
                this.isNight = !this.isNight;
                const btn = document.getElementById('daynight-btn');
                if (this.isNight) {
                    this.scene.background = new THREE.Color(0x0d1b2a); 
                    this.scene.fog.color = new THREE.Color(0x0d1b2a);
                    this.lights.ambient.intensity = 0.2;
                    this.lights.sun.intensity = 0.3; 
                    this.lights.sun.color = new THREE.Color(0xaaccff);
                    btn.classList.add('night'); btn.innerText = "ğŸŒ™";
                    this.streetLights.forEach(l => l.intensity = 1.5);
                } else {
                    this.scene.background = new THREE.Color(0x87CEEB);
                    this.scene.fog.color = new THREE.Color(0x87CEEB);
                    this.lights.ambient.intensity = 0.6;
                    this.lights.sun.intensity = 0.9;
                    this.lights.sun.color = new THREE.Color(0xffffff);
                    btn.classList.remove('night'); btn.innerText = "â˜€ï¸";
                    this.streetLights.forEach(l => l.intensity = 0);
                }
            }

            updateCameraPos() {
                const cx = this.gridW * TILE_SIZE / 2;
                const cz = this.gridH * TILE_SIZE / 2;
                const zoom = Math.max(this.gridW, this.gridH) * 3.5;
                this.camera.position.set(cx, zoom, cz + zoom * 0.5); 
                this.camera.lookAt(cx, 0, cz);
            }

            spawnSupplyDrop() {
                const x = (Math.random() * (this.gridW - 2) + 1) * TILE_SIZE;
                const z = (Math.random() * (this.gridH - 2) + 1) * TILE_SIZE;
                const drop = new SupplyDrop(x, z);
                this.supplyDrops.push(drop);
                this.scene.add(drop.mesh);
                AudioSys.drop();
            }

            spawnSpeedThief(targetDrop) {
                const startX = Math.random() > 0.5 ? 0 : (this.gridW-1)*TILE_SIZE;
                const startZ = Math.random() * (this.gridH-1)*TILE_SIZE;
                const thief = new SpeedThief(startX, startZ, targetDrop);
                this.speedThieves.push(thief);
                this.scene.add(thief.mesh);
                AudioSys.teleport();
            }

            collectSupplyDrop(drop) {
                if (drop.landed) {
                    this.scene.remove(drop.mesh);
                    this.supplyDrops = this.supplyDrops.filter(d => d !== drop);
                    const rand = Math.random();
                    if (rand > 0.3) {
                        this.money += 1000;
                        this.showFloatText(drop.mesh.position, "+$1000", "#ffd740");
                    } else {
                        this.lives += 5;
                        this.showFloatText(drop.mesh.position, "â¤ï¸ +5", "#ff5252");
                    }
                    AudioSys.harvest();
                    this.updateUI();
                    
                    this.speedThieves.forEach(t => {
                        if (t.target === drop) {
                            t.state = 'ESCAPED';
                            t.target = null;
                        }
                    });
                }
            }
            
            catchSpeedThief(thief) {
                this.scene.remove(thief.mesh);
                this.speedThieves = this.speedThieves.filter(t => t !== thief);
                this.money += 50;
                this.updateUI();
                AudioSys.squish();
                this.particles.push(new EffectParticle(thief.mesh.position.x, 1, thief.mesh.position.z, 0x00e5ff, 'burst', 0.8));
                this.showFloatText(thief.mesh.position, "+$50", "#00e5ff");
            }

            showFloatText(pos, msg, color) {
                const text = document.createElement('div');
                text.className = 'float-text';
                text.style.color = color;
                text.innerText = msg;
                const vec = pos.clone();
                vec.y += 3;
                vec.project(this.camera);
                const x = (vec.x * .5 + .5) * window.innerWidth;
                const y = (-(vec.y * .5) + .5) * window.innerHeight;
                text.style.left = `${x}px`;
                text.style.top = `${y}px`;
                document.body.appendChild(text);
                setTimeout(() => text.remove(), 1000);
            }

            getPaths() {
                const W = this.gridW;
                const H = this.gridH;
                const cX = Math.floor(W/2);
                const cZ = Math.floor(H/2);
                const end = { x: W-2, z: H-2 };

                const paths = [
                    [{x:0, z:2}, {x:5, z:2}, {x:5, z:H-5}, {x:W-5, z:H-5}, {x:W-5, z:end.z}, end],
                    [{x:8, z:0}, {x:8, z:5}, {x:W-5, z:5}, {x:W-5, z:end.z}, end],
                    [{x:5, z:H-1}, {x:5, z:H-5}, {x:cX, z:H-5}, {x:cX, z:end.z}, end],
                    [{x:W-1, z:4}, {x:W-4, z:4}, {x:W-4, z:H-5}, {x:W-2, z:H-5}, end]
                ];

                if (this.level >= 5) {
                    paths.push([{x:0, z:0}, {x:2, z:2}, {x:cX, z:2}, {x:cX, z:end.z}, end]); 
                    paths.push([{x:W-1, z:0}, {x:W-3, z:2}, {x:W-3, z:cZ}, {x:end.x, z:cZ}, end]); 
                    paths.push([{x:0, z:H-1}, {x:2, z:H-3}, {x:cX, z:H-3}, {x:cX, z:end.z}, end]); 
                    paths.push([{x:W-1, z:H-1}, {x:W-3, z:H-3}, {x:W-3, z:cZ}, {x:end.x, z:cZ}, end]); 
                }

                return paths;
            }

            onMouseDown(e) { if (e.target.closest('button') || e.target.closest('.tower-card')) return; this.isDragging = true; this.hasDragged = false; this.lastMouseX = e.clientX; this.lastMouseY = e.clientY; }
            onMouseMove(e) {
                if (this.isDragging) {
                    const dx = e.clientX - this.lastMouseX; const dy = e.clientY - this.lastMouseY;
                    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) this.hasDragged = true;
                    const moveSpeed = 0.1 + (this.level * 0.05);
                    this.camera.position.x -= dx * moveSpeed; this.camera.position.z -= dy * moveSpeed;
                    this.lastMouseX = e.clientX; this.lastMouseY = e.clientY; return;
                }
                const pos = this.getGridPos(e);
                if (pos && pos.x >= 0 && pos.x < this.gridW && pos.z >= 0 && pos.z < this.gridH) {
                    if (this.buildType) {
                        this.ghostMesh.position.set(pos.worldX, 1, pos.worldZ); this.ghostMesh.visible = true;
                        const cell = this.grid[pos.x][pos.z];
                        const canBuild = cell.type === 0 && cell.tower === null && cell.plant === null && !cell.hasDecoration;
                        this.ghostMesh.children[0].material.color.setHex(canBuild ? 0x76ff03 : 0xff1744);
                        if (TOWER_DATA[this.buildType]) this.rangeCircle.position.set(pos.worldX, 1, pos.worldZ);
                    }
                } else { this.ghostMesh.visible = false; }
            }
            onMouseUp(e) {
                this.isDragging = false; if (this.hasDragged) return;
                if (e.target.closest('button') || e.target.closest('.tower-card')) return;
                this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1; this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.camera);

                const checkIntersects = (arr, cb) => {
                    const intersects = this.raycaster.intersectObjects(arr.map(o => o.mesh), true);
                    if (intersects.length > 0) { const hit = intersects[0].object.parent; const obj = arr.find(o => o.mesh === hit || o.mesh.children.includes(hit)); if(obj) cb(obj); return true; } return false;
                };

                if (checkIntersects(this.worms, w => this.catchWorm(w))) return;
                if (checkIntersects(this.woodPiles, p => this.collectWood(p))) return;
                if (checkIntersects(this.supplyDrops, s => this.collectSupplyDrop(s))) return;
                if (checkIntersects(this.speedThieves, s => this.catchSpeedThief(s))) return;

                const pos = this.getGridPos(e);
                if (!pos || pos.x < 0 || pos.x >= this.gridW || pos.z < 0 || pos.z >= this.gridH) return;
                const cell = this.grid[pos.x][pos.z];

                if (this.buildType) {
                    if (cell.type === 0 && cell.tower === null && cell.plant === null && !cell.hasDecoration) {
                        if (FARM_DATA[this.buildType]) { if (this.money >= FARM_DATA[this.buildType].cost) this.buildPlant(pos.x, pos.z, this.buildType); else AudioSys.error(); }
                        else { if (this.money >= TOWER_DATA[this.buildType].cost) this.buildTower(pos.x, pos.z, this.buildType); else AudioSys.error(); }
                    }
                } else {
                    if (cell.plant) cell.plant.tryHarvest(); else if (cell.tower) this.selectTower(cell.tower); else this.closePanel();
                }
            }
            onClick(e) {}
            getGridPos(event) { this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1; this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; this.raycaster.setFromCamera(this.mouse, this.camera); const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); const target = new THREE.Vector3(); this.raycaster.ray.intersectPlane(plane, target); if (target) { const gx = Math.round(target.x / TILE_SIZE); const gz = Math.round(target.z / TILE_SIZE); return { x: gx, z: gz, worldX: gx * TILE_SIZE, worldZ: gz * TILE_SIZE }; } return null; }

            buildTower(gx, gz, type) {
                this.money -= TOWER_DATA[type].cost; const t = new Tower(gx, gz, type); this.scene.add(t.mesh); this.towers.push(t); this.grid[gx][gz].tower = t; AudioSys.build(); this.particles.push(new EffectParticle(t.mesh.position.x, 2, t.mesh.position.z, 0xffffff, 'burst')); this.selectBuildType(null); this.updateUI();
            }
            buildPlant(gx, gz, type) {
                this.money -= FARM_DATA[type].cost; const p = new Plant(gx, gz, type); this.scene.add(p.mesh); this.plants.push(p); this.grid[gx][gz].plant = p; AudioSys.build(); this.particles.push(new EffectParticle(p.mesh.position.x, 1, p.mesh.position.z, 0x8d6e63, 'burst')); this.selectBuildType(null); this.updateUI();
            }
            selectTower(tower) { this.selectedTower = tower; this.rangeCircle.visible = true; this.rangeCircle.position.set(tower.mesh.position.x, 1, tower.mesh.position.z); const r = tower.getRange() * TILE_SIZE; this.rangeCircle.geometry = new THREE.RingGeometry(r-0.5, r, 64); document.getElementById('upgrade-panel').style.display = 'block'; document.getElementById('up-name').innerText = TOWER_DATA[tower.type].name; this.updatePanelInfo(); }
            updatePanelInfo() { if (!this.selectedTower) return; const t = this.selectedTower; const cost = Math.floor(TOWER_DATA[t.type].cost * 1.5 * t.level); document.getElementById('up-level').innerText = t.level; document.getElementById('up-dmg').innerText = (t.getDamage()).toFixed(1); document.getElementById('up-range').innerText = t.getRange(); document.getElementById('btn-upgrade').innerText = `å‡ç´š ($${cost})`; document.getElementById('btn-upgrade').disabled = this.money < cost; document.getElementById('up-hp').innerText = Math.floor(t.hp); document.getElementById('up-max-hp').innerText = t.maxHp; document.getElementById('up-hp-bar').style.width = (t.hp / t.maxHp * 100) + '%'; }
            upgradeTower() { if(!this.selectedTower) return; const t = this.selectedTower; const cost = Math.floor(TOWER_DATA[t.type].cost * 1.5 * t.level); if (this.money >= cost) { this.money -= cost; t.upgrade(); AudioSys.build(); this.particles.push(new EffectParticle(t.mesh.position.x, 4, t.mesh.position.z, 0xffff00, 'burst')); this.updatePanelInfo(); this.updateUI(); } }
            sellTower() { if(!this.selectedTower) return; const t = this.selectedTower; const val = Math.floor(TOWER_DATA[t.type].cost * 0.4 * t.level); this.money += val; this.removeTower(t); AudioSys.build(); this.closePanel(); this.updateUI(); }
            closePanel() { this.selectedTower = null; document.getElementById('upgrade-panel').style.display = 'none'; if (!this.buildType) this.rangeCircle.visible = false; }
            togglePause() { this.isPaused = !this.isPaused; const btn = document.getElementById('pause-btn'); const overlay = document.getElementById('pause-overlay'); if (this.isPaused) { btn.classList.add('paused'); btn.innerText = "â–¶"; overlay.style.display = "flex"; } else { btn.classList.remove('paused'); btn.innerText = "â¸ï¸"; overlay.style.display = "none"; } }

            createMap() {
                if(this.floorMesh) this.scene.remove(this.floorMesh);
                if (this.streetLightsMesh) this.streetLightsMesh.forEach(m => this.scene.remove(m));
                this.streetLightsMesh = []; this.streetLights = [];

                if(this.grid.length > 0) {
                   for(let x=0; x<this.grid.length; x++) {
                       for(let z=0; z<this.grid[x].length; z++) {
                           if(this.grid[x][z] && this.grid[x][z].mesh) this.scene.remove(this.grid[x][z].mesh);
                       }
                   }
                }

                const floorGeo = new THREE.PlaneGeometry(this.gridW * TILE_SIZE * 2, this.gridH * TILE_SIZE * 2);
                const floorMat = new THREE.MeshLambertMaterial({ color: 0x1b5e20 }); 
                this.floorMesh = new THREE.Mesh(floorGeo, floorMat);
                this.floorMesh.rotation.x = -Math.PI / 2;
                this.floorMesh.position.set(this.gridW*TILE_SIZE/2 - TILE_SIZE/2, -0.2, this.gridH*TILE_SIZE/2 - TILE_SIZE/2);
                this.floorMesh.receiveShadow = true;
                this.scene.add(this.floorMesh);

                const matEmpty = new THREE.MeshLambertMaterial({ color: 0x2e7d32 }); 
                const matPath = new THREE.MeshLambertMaterial({ color: 0xffe0b2 }); 
                
                const paths = this.getPaths();

                this.grid = [];
                for(let x=0; x<this.gridW; x++) {
                    this.grid[x] = [];
                    for(let z=0; z<this.gridH; z++) {
                        let type = 0; 
                        for(let p of paths) { if (this.isPointOnPath(x, z, p)) type = 1; }
                        const h = type === 1 ? 0.2 : 0.5;
                        const geo = new THREE.BoxGeometry(TILE_SIZE * 0.95, h, TILE_SIZE * 0.95);
                        const mat = type === 1 ? matPath : matEmpty;
                        const tile = new THREE.Mesh(geo, mat);
                        tile.position.set(x * TILE_SIZE, h/2, z * TILE_SIZE);
                        tile.receiveShadow = true; tile.castShadow = true;
                        this.scene.add(tile);
                        this.grid[x][z] = { type: type, mesh: tile, tower: null, plant: null, x:x, z:z };
                    }
                }

                const endP = paths[0][paths[0].length-1];
                if(this.endBase) this.scene.remove(this.endBase);
                this.endBase = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 4, 8), new THREE.MeshPhongMaterial({color: 0xd32f2f}));
                this.endBase.position.set(endP.x * TILE_SIZE, 2, endP.z * TILE_SIZE);
                this.endBase.castShadow = true;
                this.scene.add(this.endBase);
                
                if(this.startPoints) this.startPoints.forEach(s => this.scene.remove(s));
                this.startPoints = [];
                paths.forEach(p => {
                    const start = p[0];
                    const startM = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 4), new THREE.MeshLambertMaterial({color: 0x76ff03}));
                    startM.position.set(start.x * TILE_SIZE, 0.5, start.z * TILE_SIZE);
                    this.scene.add(startM);
                    this.startPoints.push(startM);
                    for(let i=0; i<p.length; i+=2) { const pt = p[i]; this.createStreetLight(pt.x * TILE_SIZE + 2.5, pt.z * TILE_SIZE + 2.5); }
                });
            }

            createStreetLight(x, z) {
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 3), new THREE.MeshLambertMaterial({color: 0x424242}));
                pole.position.set(x, 1.5, z);
                const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color: 0xffeb3b}));
                bulb.position.set(0, 1.5, 0);
                pole.add(bulb);
                const light = new THREE.PointLight(0xffa000, 0, 15); light.position.set(0, 1.5, 0); pole.add(light);
                this.scene.add(pole);
                this.streetLightsMesh.push(pole); this.streetLights.push(light);
            }

            createDecorations() {
                this.decorations.forEach(d => this.scene.remove(d.mesh)); this.decorations = [];
                const trunkMat = new THREE.MeshLambertMaterial({color: 0x795548});
                const leavesMat = new THREE.MeshLambertMaterial({color: 0x43a047});
                const flowerColors = [0xffeb3b, 0xe91e63, 0x9c27b0, 0xffffff];

                for(let x=0; x<this.gridW; x++) {
                    for(let z=0; z<this.gridH; z++) {
                        if (this.grid[x][z].type === 0 && Math.random() > 0.7) {
                            const posX = x * TILE_SIZE; const posZ = z * TILE_SIZE; const rand = Math.random();
                            if (rand > 0.6) {
                                const tree = new THREE.Group();
                                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 2), trunkMat); trunk.position.y = 1; trunk.castShadow = true;
                                const leaves = new THREE.Mesh(new THREE.ConeGeometry(2, 4, 8), leavesMat); leaves.position.y = 3.5; leaves.castShadow = true;
                                tree.add(trunk, leaves); const s = 0.8 + Math.random() * 0.4; tree.scale.set(s, s, s); tree.rotation.y = Math.random() * Math.PI; tree.position.set(posX, 0.5, posZ);
                                this.scene.add(tree); this.decorations.push({ mesh: tree, type: 'tree', x: x, z: z }); this.grid[x][z].hasDecoration = true;
                            } else {
                                const flower = new THREE.Group();
                                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1), leavesMat); stem.position.y = 0.5;
                                const petalColor = flowerColors[Math.floor(Math.random()*flowerColors.length)];
                                const petal = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4), new THREE.MeshBasicMaterial({color: petalColor})); petal.position.y = 1;
                                flower.add(stem, petal); flower.position.set(posX + (Math.random()-0.5)*2, 0.5, posZ + (Math.random()-0.5)*2);
                                this.scene.add(flower); this.decorations.push({ mesh: flower, type: 'flower' });
                            }
                        }
                    }
                }
            }

            initAnimals() {
                this.animals.forEach(a => this.scene.remove(a.mesh)); this.animals = [];
                const paths = this.getPaths();
                const animalLocs = [paths[0][2], paths[1][2], paths[2][2]];
                animalLocs.forEach(loc => {
                    const animal = new Animal(loc.x, loc.z);
                    this.scene.add(animal.mesh);
                    this.animals.push(animal);
                });
                document.getElementById('animals-txt').innerText = this.animals.length;
            }

            // ... (å…¶é¤˜è¼”åŠ©æ–¹æ³•ä¿æŒä¸è®Š) ...
            isPointOnPath(x, z, path) { for(let i=0; i<path.length-1; i++) { let p1 = path[i]; let p2 = path[i+1]; if(p1.z === p2.z && z === p1.z) { if(x >= Math.min(p1.x, p2.x) && x <= Math.max(p1.x, p2.x)) return true; } if(p1.x === p2.x && x === p1.x) { if(z >= Math.min(p1.z, p2.z) && z <= Math.max(p1.z, p2.z)) return true; } } return false; }
            getRandomFreeTile() { const freeTiles = []; for(let x=0; x<this.gridW; x++) { for(let z=0; z<this.gridH; z++) { const cell = this.grid[x][z]; if (cell.type === 0 && cell.tower === null && cell.plant === null && !cell.hasDecoration) { freeTiles.push({x, z}); } } } if (freeTiles.length > 0) { const t = freeTiles[Math.floor(Math.random() * freeTiles.length)]; return { x: t.x * TILE_SIZE, z: t.z * TILE_SIZE }; } return { x: Math.random() * this.gridW * TILE_SIZE, z: Math.random() * this.gridH * TILE_SIZE }; }

            // --- éŠæˆ²é‚è¼¯å¾ªç’° ---
            startNextLevel() {
                if (this.level >= this.maxLevels) {
                    this.gameWin();
                    return;
                }

                document.getElementById('level-up-overlay').style.display = 'none';
                
                // åœ°åœ–ç·šæ€§å¢åŠ  (+4 å¯¬, +3 é«˜)
                this.gridW += 4;
                this.gridH += 3;
                this.level++;
                this.wave = 1;
                
                // æ¸…ç†æ‰€æœ‰å‹•æ…‹ç‰©ä»¶
                const removeAll = (arr) => { arr.forEach(o => this.scene.remove(o.mesh)); return []; };
                this.enemies = removeAll(this.enemies);
                // å¡”å…¨éƒ¨ç§»é™¤ (åœ°åœ–é‡ç½®)
                this.towers.forEach(t => { this.scene.remove(t.mesh); this.money += t.hp > 0 ? TOWER_DATA[t.type].cost * 0.5 : 0; }); // é€€é‚„ä¸€åŠé€ åƒ¹
                this.towers = [];
                
                this.plants = removeAll(this.plants);
                this.worms = removeAll(this.worms);
                this.loggers = removeAll(this.loggers);
                this.projectiles = removeAll(this.projectiles);
                this.particles = removeAll(this.particles);
                this.woodPiles = removeAll(this.woodPiles);
                this.thieves = removeAll(this.thieves);
                this.supplyDrops = removeAll(this.supplyDrops);
                this.speedThieves = removeAll(this.speedThieves);
                
                this.createMap();
                this.createDecorations();
                this.initAnimals();
                this.updateCameraPos();
                
                document.getElementById('level-txt').innerText = this.level;
                this.updateUI();
            }
            
            gameWin() {
                document.getElementById('victory-overlay').style.display = 'flex';
                this.waveActive = false;
                AudioSys.harvest(); 
            }

            nextWave() {
                if(this.waveActive) return;
                this.waveActive = true;
                document.getElementById('next-wave-btn').disabled = true;

                const activePaths = this.getPaths();
                const groups = 8 + Math.floor(this.wave * 2); 
                const hpMult = Math.pow(1.4, (this.level-1)*2 + this.wave - 1); 
                let spawnDelayBase = Math.max(10, 35 - (this.wave * 2));

                for(let i=0; i<groups; i++) {
                    const baseDelay = i * spawnDelayBase;
                    for (let j = 0; j < 6; j++) {
                        let type = 'NORMAL';
                        const rand = Math.random();
                        if (this.wave >= 1 && rand > 0.5) type = 'FAST';
                        if (this.wave >= 1 && rand > 0.7) type = 'SHOOTER'; 
                        if (this.wave >= 2 && rand > 0.8) type = 'TANK';
                        if (this.wave >= 2 && Math.random() > 0.85) type = 'FLYING';

                        let path = activePaths[j % activePaths.length]; 
                        if (type === 'FLYING') path = activePaths[Math.floor(Math.random() * activePaths.length)];
                        this.spawnQueue.push({ type, hpMult, path, delay: baseDelay + (j * 3) });
                    }
                    if (this.wave >= 1 && Math.random() > 0.85) {
                        for(let b=0; b<4; b++) {
                             this.spawnQueue.push({ type: 'BOMBER', hpMult, path: activePaths[b % activePaths.length], delay: baseDelay + 15 + (b * 2) });
                        }
                    }
                }

                // é­”ç‹åœ¨æ¯é—œçš„æœ€å¾Œä¸€æ³¢å‡ºç¾ï¼Œæˆ–è€…æ¯ 5 æ³¢
                if (this.wave % 2 === 0) {
                    this.bossesRemainingInWave = 1 + Math.floor(Math.random() * 4); 
                    this.spawnBossSequence(groups * spawnDelayBase); 
                } else {
                    this.bossesRemainingInWave = 0;
                }
            }
            
            spawnBossSequence(baseDelay = 0) {
                if (this.bossesRemainingInWave <= 0) return;
                this.bossesRemainingInWave--; 
                
                const activePaths = this.getPaths();
                const bossPath = activePaths[Math.floor(Math.random() * activePaths.length)]; 
                const hpMult = Math.pow(1.5, (this.level-1)*2 + this.wave - 1);

                this.spawnQueue.push({ type: 'BOSS', hpMult, path: bossPath, delay: baseDelay });
                
                const isAmbush = this.enemies.length < 5;
                const guards = ['BOMBER', 'BOMBER', 'SHOOTER', 'SHOOTER'];
                guards.forEach((gType, idx) => {
                    let opts = { type: gType, hpMult, delay: baseDelay + 5 + (idx * 3) };
                    if (isAmbush) opts.spawnLoc = this.getRandomFreeTile(); else opts.path = bossPath;
                    this.spawnQueue.push(opts);
                });
            }

            spawnEnemy() {
                if(this.spawnQueue.length === 0) return;
                const next = this.spawnQueue[0];
                if(next.delay > 0) {
                    next.delay--;
                    return;
                }
                this.spawnQueue.shift();
                const enemy = new Enemy(next);
                this.enemies.push(enemy);
                this.scene.add(enemy.mesh);
                if (enemy.isStationary) {
                    AudioSys.teleport();
                    this.particles.push(new EffectParticle(enemy.mesh.position.x, 2, enemy.mesh.position.z, 0x9c27b0, 'burst', 2));
                }
            }

            update() {
                if (this.isPaused) { this.renderer.render(this.scene, this.camera); return; }
                if (this.lives <= 0) return;

                if (this.waveActive) {
                    this.spawnEnemy();
                    if (this.spawnQueue.length === 0 && this.enemies.length === 0 && this.bossesRemainingInWave === 0) {
                        if (this.wave >= 2) { // ç°¡åŒ–ï¼šæ¯é—œåªæœ‰2æ³¢ï¼Œæ–¹ä¾¿æ¼”ç¤º
                            if (this.level < this.maxLevels) {
                                document.getElementById('level-up-overlay').style.display = 'flex';
                            } else {
                                this.gameWin();
                            }
                            this.waveActive = false; 
                        } else {
                            this.endWave();
                        }
                    }
                }

                if (Math.random() < 0.005 + (this.plants.length * 0.002)) { if (this.worms.length < 5 + this.plants.length) this.spawnWorm(); }
                if (Math.random() < 0.003 && this.loggers.length < 3) { this.spawnLogger(); }
                // éš¨æ©Ÿç©ºæŠ• (ä½æ©Ÿç‡)
                if (Math.random() < 0.001) this.spawnSupplyDrop();

                this.animals.forEach(a => a.update());
                for (let i = this.worms.length - 1; i >= 0; i--) this.worms[i].update(this.plants);
                for (let i = this.loggers.length - 1; i >= 0; i--) this.loggers[i].update(this.decorations);
                for (let i = this.plants.length - 1; i >= 0; i--) this.plants[i].update();
                for (let i = this.thieves.length - 1; i >= 0; i--) this.thieves[i].update();
                for (let i = this.supplyDrops.length - 1; i >= 0; i--) this.supplyDrops[i].update();
                for (let i = this.speedThieves.length - 1; i >= 0; i--) this.speedThieves[i].update(); // å…‰é€Ÿå°å·

                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const e = this.enemies[i];
                    const status = e.update(this.animals, this.towers); 
                    if (status === 'REACHED') {
                        this.lives--; AudioSys.error(); this.removeEnemy(e);
                        this.camera.position.x += (Math.random()-0.5); setTimeout(()=>this.camera.position.x = this.gridW * TILE_SIZE / 2, 50);
                        if(this.lives <= 0) this.gameOver("åŸºåœ°è¢«æ‘§æ¯€");
                    }
                }
                this.towers.forEach(t => t.update(this.enemies));
                for (let i = this.projectiles.length - 1; i >= 0; i--) { const p = this.projectiles[i]; if (!p.active) { this.scene.remove(p.mesh); this.projectiles.splice(i, 1); } else { p.update(); } }
                for (let i = this.particles.length - 1; i >= 0; i--) { if(!this.particles[i].update()) { this.scene.remove(this.particles[i].mesh); this.particles.splice(i, 1); } }
                this.updateUI();
            }

            endWave() {
                this.waveActive = false; this.wave++; this.money += 200 + (this.wave * 30); 
                document.getElementById('next-wave-btn').disabled = false; AudioSys.build();
            }

            // ... (å…¶ä»– Helper æ–¹æ³•èˆ‡ä¹‹å‰ç›¸åŒ: removeEnemy, removeTower, selectBuildType, spawnWorm, catchWorm, spawnLogger, spawnWoodPile, spawnThief, collectWood) ...
            // ç‚ºäº†ç¯€çœé•·åº¦ï¼Œé€™è£¡çœç•¥éƒ¨åˆ†é‡è¤‡å‡½æ•¸çš„å…§å®¹ï¼Œè«‹ç¢ºä¿åŒ…å«ä¹‹å‰çš„æ‰€æœ‰è¼”åŠ©æ–¹æ³•ã€‚
            removeEnemy(e) { if (e.type === 'BOSS' && this.bossesRemainingInWave > 0) this.spawnBossSequence(100); this.scene.remove(e.mesh); e.dispose(); const idx = this.enemies.indexOf(e); if (idx > -1) this.enemies.splice(idx, 1); }
            removeAnimal(a) { this.scene.remove(a.mesh); const idx = this.animals.indexOf(a); if (idx > -1) this.animals.splice(idx, 1); document.getElementById('animals-txt').innerText = this.animals.length; AudioSys.animalDie(); this.gameOver("å°å‹•ç‰©è¢«æ®ºæ­»äº†ï¼"); }
            removeTower(t) { this.scene.remove(t.mesh); this.grid[t.gx][t.gz].tower = null; const idx = this.towers.indexOf(t); if (idx > -1) this.towers.splice(idx, 1); game.particles.push(new EffectParticle(t.mesh.position.x, 2, t.mesh.position.z, 0xff0000, 'explode', 2)); AudioSys.towerDestroy(); const msg = document.getElementById('tower-destroyed-msg'); msg.style.opacity = 1; setTimeout(() => msg.style.opacity = 0, 1500); if(this.selectedTower === t) this.closePanel(); }
            spawnWorm() { const startPos = this.getRandomFreeTile(); const worm = new Worm(startPos.x, startPos.z); this.worms.push(worm); this.scene.add(worm.mesh); }
            catchWorm(worm) { this.scene.remove(worm.mesh); const idx = this.worms.indexOf(worm); if (idx > -1) this.worms.splice(idx, 1); this.money += 20; this.updateUI(); AudioSys.squish(); this.particles.push(new EffectParticle(worm.mesh.position.x, 1, worm.mesh.position.z, 0x76ff03, 'burst', 0.5)); this.showFloatText(worm.mesh.position, "+$20", "#76ff03"); }
            spawnLogger() { const startPos = this.getRandomFreeTile(); const logger = new Lumberjack(startPos.x, startPos.z); this.loggers.push(logger); this.scene.add(logger.mesh); }
            spawnWoodPile(x, z) { const pile = new WoodPile(x, z); this.woodPiles.push(pile); this.scene.add(pile.mesh); this.spawnThief(pile); }
            spawnThief(targetPile) { const startX = Math.random() > 0.5 ? 0 : (this.gridW-1)*TILE_SIZE; const startZ = Math.random() * (this.gridH-1)*TILE_SIZE; const thief = new Thief(startX, startZ, targetPile); this.thieves.push(thief); this.scene.add(thief.mesh); }
            collectWood(pile) { this.scene.remove(pile.mesh); this.woodPiles = this.woodPiles.filter(p => p !== pile); game.money += 800; game.updateUI(); AudioSys.harvest(); this.showFloatText(pile.mesh.position, "+$800", "#795548"); this.thieves.forEach(t => { if (t.target === pile) { t.state = 'ESCAPED'; t.target = null; } }); }
            collectSupplyDrop(drop) { if (drop.landed) { this.scene.remove(drop.mesh); this.supplyDrops = this.supplyDrops.filter(d => d !== drop); const rand = Math.random(); if (rand > 0.3) { this.money += 1000; this.showFloatText(drop.mesh.position, "+$1000", "#ffd740"); } else { this.lives += 5; this.showFloatText(drop.mesh.position, "â¤ï¸ +5", "#ff5252"); } AudioSys.harvest(); this.updateUI(); } }
            
            // è£œå……éºæ¼çš„ updateUI
            updateUI() {
                document.getElementById('level-txt').innerText = this.level;
                document.getElementById('lives-txt').innerText = this.lives;
                document.getElementById('money-txt').innerText = this.money;
                document.getElementById('wave-txt').innerText = this.wave;
                document.getElementById('enemies-txt').innerText = this.spawnQueue.length + this.enemies.length;
                if(this.selectedTower) this.updatePanelInfo();
            }

            onResize() {
                const aspect = window.innerWidth / window.innerHeight;
                this.camera.aspect = aspect;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                this.renderer.setAnimationLoop(() => {
                    this.update();
                    this.renderer.render(this.scene, this.camera);
                });
            }
        }

        // ==========================================
        // è£œçµ¦ç®±ç©ºæŠ• (New)
        // ==========================================
        class SupplyDrop {
            constructor(x, z) {
                this.mesh = new THREE.Group();
                // ç®±å­
                const box = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshLambertMaterial({color: 0x8d6e63}));
                // é™è½å‚˜
                const chute = new THREE.Mesh(new THREE.ConeGeometry(3, 2, 8, 1, true), new THREE.MeshLambertMaterial({color: 0xffffff, side: THREE.DoubleSide}));
                chute.position.y = 4;
                // ç¹©å­
                const rope1 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 3), new THREE.MeshBasicMaterial({color: 0x333}));
                rope1.position.set(-1, 2.5, -1); rope1.rotation.z = 0.3; rope1.rotation.x = 0.3;
                const rope2 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 3), new THREE.MeshBasicMaterial({color: 0x333}));
                rope2.position.set(1, 2.5, 1); rope2.rotation.z = -0.3; rope2.rotation.x = -0.3;
                
                this.mesh.add(box, chute, rope1, rope2);
                this.mesh.position.set(x, 50, z); // å¾å¤©è€Œé™
                this.landed = false;
                this.spawnedThief = false; // Add flag to prevent multiple spawns
            }
            update() {
                if (!this.landed) {
                    this.mesh.position.y -= 0.2; // é™è½é€Ÿåº¦
                    if (this.mesh.position.y <= 1) {
                        this.mesh.position.y = 1;
                        this.landed = true;
                        // ç§»é™¤é™è½å‚˜
                        this.mesh.remove(this.mesh.children[1], this.mesh.children[2], this.mesh.children[3]);
                        // ç™¼å…‰ç‰¹æ•ˆ
                        const light = new THREE.PointLight(0xffd700, 1, 10);
                        this.mesh.add(light);
                        game.particles.push(new EffectParticle(this.mesh.position.x, 1, this.mesh.position.z, 0xffd700, 'burst', 3));
                        
                        // Spawn Speed Thief here, once
                        if (!this.spawnedThief) {
                            game.spawnSpeedThief(this);
                            this.spawnedThief = true;
                        }
                    }
                    // æ–æ™ƒ
                    this.mesh.rotation.z = Math.sin(Date.now() * 0.005) * 0.1;
                } else {
                    // è½åœ°å¾Œä¸Šä¸‹æµ®å‹•æç¤º
                    this.mesh.position.y = 1 + Math.sin(Date.now() * 0.005) * 0.2;
                    this.mesh.rotation.y += 0.02;
                }
            }
        }
        
        // ==========================================
        // å…‰é€Ÿå°å· (New)
        // ==========================================
        class SpeedThief {
            constructor(x, z, target) {
                this.target = target;
                this.mesh = new THREE.Group();
                // Appearance: Slim, Cyan
                const body = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1.5, 8), new THREE.MeshLambertMaterial({color: 0x00bcd4}));
                body.position.y = 0.75;
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshLambertMaterial({color: 0x00bcd4}));
                head.position.y = 1.6;
                // Lightning symbol (simple yellow box)
                const symbol = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), new THREE.MeshBasicMaterial({color: 0xffeb3b}));
                symbol.position.y = 2.2;

                this.mesh.add(body, head, symbol);
                this.mesh.position.set(x, 0, z);
                
                this.speed = 0.3; // Very fast
                this.state = 'RUNNING';
                this.timer = 0;
            }

            update() {
                if (this.state === 'ESCAPED') {
                    this.mesh.translateZ(this.speed);
                    if (this.mesh.position.length() > 200) { 
                        game.scene.remove(this.mesh); 
                        game.speedThieves = game.speedThieves.filter(t => t !== this); 
                    }
                    return;
                }
                
                // If target drop collected by player or gone
                if (!this.target || !game.supplyDrops.includes(this.target)) {
                    this.state = 'ESCAPED';
                    return;
                }

                const dist = this.mesh.position.distanceTo(this.target.mesh.position);
                
                if (this.state === 'RUNNING') {
                    if (dist > 1.5) {
                        this.mesh.lookAt(this.target.mesh.position);
                        this.mesh.translateZ(this.speed);
                    } else {
                        this.state = 'STEALING';
                        // Alert visual: Red countdown bar
                        const bar = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.3), new THREE.MeshBasicMaterial({color: 0xff1744}));
                        bar.position.y = 3;
                        this.mesh.add(bar);
                        this.timerBar = bar;
                    }
                } else if (this.state === 'STEALING') {
                    this.timer++;
                    
                    // Update bar scale (shrink)
                    const progress = 1 - (this.timer / 60);
                    if (this.timerBar) this.timerBar.scale.x = Math.max(0, progress);
                    this.timerBar.lookAt(game.camera.position);

                    if (this.timer > 60) { // 1 second (60fps)
                        // Steal!
                        game.scene.remove(this.target.mesh);
                        game.supplyDrops = game.supplyDrops.filter(d => d !== this.target);
                        AudioSys.steal();
                        
                        game.showFloatText(this.mesh.position, "è£œçµ¦è¢«å·äº†!", "#ff1744");
                        
                        this.state = 'ESCAPED';
                    }
                }
            }
        }
        
        // ... (å…¶ä»–é¡åˆ¥ Plant, Lumberjack, WoodPile, Thief, Worm, Animal, Enemy, Tower, Projectile, EffectParticle ä¿æŒä¸è®Š) ...
        // ç‚ºäº†ä¿æŒç¨‹å¼ç¢¼å®Œæ•´æ€§ï¼Œä»¥ä¸‹é‡è¤‡å‰ä¸€ç‰ˆæœ¬çš„é¡åˆ¥å®šç¾© (å¿…é ˆåŒ…å«åœ¨æœ€çµ‚æª”æ¡ˆä¸­)
        class Plant { constructor(gx, gz, type) { this.gx = gx; this.gz = gz; this.type = type; this.data = FARM_DATA[type]; this.growth = 0; this.maxGrowth = this.data.growTime; this.mesh = new THREE.Group(); this.mesh.position.set(gx * TILE_SIZE, 0, gz * TILE_SIZE); const sprout = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1, 8), new THREE.MeshLambertMaterial({color: 0x8bc34a})); sprout.position.y = 0.5; this.mesh.add(sprout); this.visual = sprout; if (type === 'FRUIT') { this.matureMesh = new THREE.Group(); const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 1.5), new THREE.MeshLambertMaterial({color: 0x795548})); trunk.position.y = 0.75; const leaves = new THREE.Mesh(new THREE.IcosahedronGeometry(1.5), new THREE.MeshLambertMaterial({color: 0x4caf50})); leaves.position.y = 2.5; const f1 = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:0xff1744})); f1.position.set(0.8, 2.5, 0.5); const f2 = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:0xff1744})); f2.position.set(-0.7, 3.0, -0.4); const f3 = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:0xff1744})); f3.position.set(0.2, 2.2, -0.9); this.matureMesh.add(trunk, leaves, f1); } else { this.matureMesh = new THREE.Group(); const pumpkin = new THREE.Mesh(new THREE.SphereGeometry(1.5, 12, 8), new THREE.MeshLambertMaterial({color: 0xff9800})); pumpkin.scale.y = 0.7; pumpkin.position.y = 1; this.matureMesh.add(pumpkin); } this.matureMesh.visible = false; this.matureMesh.scale.set(0.1, 0.1, 0.1); this.mesh.add(this.matureMesh); } update() { if (this.growth < this.maxGrowth) { this.growth++; const progress = this.growth / this.maxGrowth; if (progress < 0.5) this.visual.scale.setScalar(1 + progress * 2); else if (!this.matureMesh.visible) { this.visual.visible = false; this.matureMesh.visible = true; } if (this.matureMesh.visible && progress < 1) this.matureMesh.scale.setScalar(0.1 + (progress - 0.5) * 1.8); } else { const s = 1 + Math.sin(Date.now() * 0.005) * 0.1; this.matureMesh.scale.set(s, s, s); } } tryHarvest() { if (this.growth >= this.maxGrowth) { game.money += this.data.sell; AudioSys.harvest(); game.showFloatText(this.mesh.position, `+$${this.data.sell}`, "#ffd740"); game.scene.remove(this.mesh); game.grid[this.gx][this.gz].plant = null; game.plants = game.plants.filter(p => p !== this); game.particles.push(new EffectParticle(this.mesh.position.x, 2, this.mesh.position.z, 0xffd700, 'burst', 1.5)); game.updateUI(); } else { AudioSys.error(); } } }
        class Lumberjack { constructor(x, z) { this.mesh = new THREE.Group(); const body = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1.5), new THREE.MeshLambertMaterial({color: 0xd32f2f})); body.position.y = 0.75; const head = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshLambertMaterial({color: 0xffccbc})); head.position.y = 1.8; this.mesh.add(body, head); this.mesh.position.set(x, 0, z); this.mesh.castShadow = true; this.targetTree = null; this.state = 'MOVING'; this.timer = 0; this.chopDuration = (60 + Math.random() * 30) * 60; this.speed = 0.05; } update(decorations) { if (!this.targetTree) { let minDist = Infinity; let nearest = null; for (let d of decorations) { if (d.type === 'tree') { const dist = this.mesh.position.distanceTo(d.mesh.position); if (dist < minDist) { minDist = dist; nearest = d; } } } this.targetTree = nearest; if(!nearest) { game.scene.remove(this.mesh); game.loggers = game.loggers.filter(l => l !== this); return; } } if (this.state === 'MOVING') { const targetPos = this.targetTree.mesh.position; if (this.mesh.position.distanceTo(targetPos) > 1.5) { this.mesh.lookAt(targetPos); this.mesh.translateZ(this.speed); } else { this.state = 'CHOPPING'; } } else if (this.state === 'CHOPPING') { this.timer++; if (this.timer >= this.chopDuration) this.finishJob(); } } finishJob() { game.scene.remove(this.targetTree.mesh); game.grid[this.targetTree.x][this.targetTree.z].hasDecoration = false; game.decorations = game.decorations.filter(d => d !== this.targetTree); game.spawnWoodPile(this.mesh.position.x, this.mesh.position.z); AudioSys.chop(); game.scene.remove(this.mesh); game.loggers = game.loggers.filter(l => l !== this); } }
        class WoodPile { constructor(x, z) { this.mesh = new THREE.Group(); const log = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 2), new THREE.MeshLambertMaterial({color: 0x5d4037})); log.rotation.z = Math.PI/2; log.position.y = 0.3; this.mesh.add(log); this.mesh.position.set(x, 0, z); } }
        class Thief { constructor(x, z, target) { this.target = target; this.mesh = new THREE.Group(); const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.5), new THREE.MeshLambertMaterial({color: 0x212121})); body.position.y = 0.75; this.mesh.add(body); this.mesh.position.set(x, 0, z); this.speed = 0.15; this.state = 'RUNNING'; this.timer = 0; } update() { if (this.state === 'ESCAPED') { this.mesh.translateZ(this.speed); if (this.mesh.position.length() > 200) { game.scene.remove(this.mesh); game.thieves = game.thieves.filter(t => t !== this); } return; } if (!this.target || !game.woodPiles.includes(this.target)) { this.state = 'ESCAPED'; return; } if (this.state === 'RUNNING') { if (this.mesh.position.distanceTo(this.target.mesh.position) > 1.5) { this.mesh.lookAt(this.target.mesh.position); this.mesh.translateZ(this.speed); } else { this.state = 'STEALING'; } } else if (this.state === 'STEALING') { this.timer++; if (this.timer > 120) { game.scene.remove(this.target.mesh); game.woodPiles = game.woodPiles.filter(p => p !== this.target); AudioSys.steal(); game.showFloatText(this.mesh.position, "è¢«å·äº†!", "#ff1744"); this.state = 'ESCAPED'; } } } }
        class Worm { constructor(x, z) { this.mesh = new THREE.Group(); const body = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshLambertMaterial({color: 0x76ff03})); body.position.y = 0.3; this.mesh.add(body); this.mesh.position.set(x, 0, z); this.targetPlant = null; this.speed = 0.03; this.eatingTimer = 0; } update(plants) { if (!this.targetPlant || !plants.includes(this.targetPlant)) { let minDist = Infinity; let nearest = null; for (let p of plants) { const d = this.mesh.position.distanceTo(p.mesh.position); if (d < minDist) { minDist = d; nearest = p; } } this.targetPlant = nearest; } if (this.targetPlant) { if (this.mesh.position.distanceTo(this.targetPlant.mesh.position) > 1.0) { this.mesh.lookAt(this.targetPlant.mesh.position); this.mesh.translateZ(this.speed); } else { if (this.targetPlant.growth >= this.targetPlant.maxGrowth) { this.eatingTimer++; if (this.eatingTimer > 60) { game.scene.remove(this.targetPlant.mesh); game.grid[this.targetPlant.gx][this.targetPlant.gz].plant = null; game.plants = game.plants.filter(p => p !== this.targetPlant); game.showFloatText(this.mesh.position, "è¢«åƒäº†!", "#ff1744"); game.scene.remove(this.mesh); game.worms = game.worms.filter(w => w !== this); } } else { this.eatingTimer = 0; } } } } }
        class Animal { constructor(gx, gz) { this.hpMax = 200; this.hp = this.hpMax; this.mesh = new THREE.Group(); this.mesh.position.set(gx * TILE_SIZE, 0, gz * TILE_SIZE); const body = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 2), new THREE.MeshLambertMaterial({color: 0xffccbc})); body.position.y = 0.75; this.mesh.add(body); const bar = new THREE.Mesh(new THREE.PlaneGeometry(3, 0.4), new THREE.MeshBasicMaterial({color:0x29b6f6})); bar.position.y = 3.5; this.hpBar = bar; this.mesh.add(bar); this.onBeforeRender = () => bar.lookAt(game.camera.position); } update() { this.mesh.children[0].position.y = 0.75 + Math.sin(Date.now()*0.005)*0.1; } updateBar() { this.hpBar.scale.x = this.hp/this.hpMax; } takeDamage(amt) { this.hp -= amt; this.updateBar(); if (this.hp <= 0) game.removeAnimal(this); } }
        class Enemy { constructor(opts) { this.type = opts.type; this.path = opts.path || []; this.pathIdx = 0; const hpMult = opts.hpMult || 1; this.hpMax = 50 * hpMult; this.speed = 0.08; this.color = 0xffffff; this.reward = 15; this.damage = 4; this.defense = Math.floor(game.wave * 0.8) + 1; this.attackRange = 3; this.isStationary = !!opts.spawnLoc; if(this.isStationary) this.spawnPos = opts.spawnLoc; let geo = new THREE.DodecahedronGeometry(1.5); if (this.type === 'BOSS') { geo = new THREE.TorusKnotGeometry(1.5, 0.5, 64, 8); this.hpMax *= 30; this.damage = 50; } this.hp = this.hpMax; this.mesh = new THREE.Mesh(geo, new THREE.MeshPhongMaterial({ color: this.color })); if(this.isStationary) this.mesh.position.set(this.spawnPos.x+2.5, 1.5, this.spawnPos.z+2.5); else { const s = this.path[0]; this.mesh.position.set(s.x*5, 1.5, s.z*5); } const bar = new THREE.Mesh(new THREE.PlaneGeometry(3, 0.4), new THREE.MeshBasicMaterial({color:0x76ff03})); bar.position.y = 3; this.hpBar = bar; this.mesh.add(bar); this.onBeforeRender = () => bar.lookAt(game.camera.position); } update(animals, towers) { if (this.isStationary) return 'STATIONARY'; const target = this.path[this.pathIdx+1]; if(!target) return 'REACHED'; const tx=target.x*5; const tz=target.z*5; if(this.mesh.position.distanceTo(new THREE.Vector3(tx, 1.5, tz)) < 0.5) { this.pathIdx++; if(this.pathIdx < this.path.length-1) this.mesh.lookAt(this.path[this.pathIdx+1].x*5, 1.5, this.path[this.pathIdx+1].z*5); } else { this.mesh.translateZ(this.speed); } return 'MOVING'; } takeDamage(amt) { const dmg = Math.max(1, amt - this.defense); this.hp -= dmg; this.hpBar.scale.x = this.hp/this.hpMax; if (this.hp <= 0) { game.money += this.reward; game.removeEnemy(this); } } dispose() { this.mesh.geometry.dispose(); this.mesh.material.dispose(); } }
        class Tower { constructor(gx, gz, type) { this.gx = gx; this.gz = gz; this.type = type; this.level = 1; this.cooldown = 0; this.maxHp = 500; this.hp = this.maxHp; const d = TOWER_DATA[type]; this.mesh = new THREE.Group(); this.mesh.position.set(gx*5, 0, gz*5); const b = new THREE.Mesh(new THREE.CylinderGeometry(2, 2.2, 1, 8), new THREE.MeshPhongMaterial({color:0x546e7a})); b.position.y=0.5; this.mesh.add(b); this.head = new THREE.Group(); this.head.position.y = 1; const h = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), new THREE.MeshPhongMaterial({color:d.color})); this.head.add(h); this.mesh.add(this.head); } getRange() { return TOWER_DATA[this.type].range; } getDamage() { return TOWER_DATA[this.type].damage; } getRate() { return TOWER_DATA[this.type].rate; } takeDamage(amt) { this.hp -= amt; if (this.hp <= 0) game.removeTower(this); } update(enemies) { if(this.cooldown > 0) { this.cooldown--; return; } const target = enemies.find(e => this.mesh.position.distanceTo(e.mesh.position) < this.getRange()*5); if(target) { this.head.lookAt(target.mesh.position); game.projectiles.push(new Projectile(this.mesh.position.clone().add(new THREE.Vector3(0,2,0)), target, this.type, this.getDamage())); this.cooldown = this.getRate(); if(Math.random()<0.15) { target.takeDamage(this.getDamage()); game.showFloatText(target.mesh.position, "CRIT!", "#ffeb3b"); AudioSys.crit(); } } } upgrade() { this.level++; this.maxHp += 500; this.hp = this.maxHp; } }
        class Projectile { constructor(start, target, type, dmg) { this.pos = start; this.target = target; this.damage = dmg; this.mesh = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:0xffff00})); this.mesh.position.copy(start); game.scene.add(this.mesh); this.active = true; } update() { if(!this.active) return; const targetPos = this.target.mesh ? this.target.mesh.position : this.targetPos || new THREE.Vector3(); if(this.target.mesh) this.targetPos = targetPos.clone(); const dir = new THREE.Vector3().subVectors(targetPos, this.mesh.position).normalize(); this.mesh.position.add(dir.multiplyScalar(0.8)); if(this.mesh.position.distanceTo(targetPos) < 1) { this.active = false; if(this.target.takeDamage) this.target.takeDamage(this.damage); game.scene.remove(this.mesh); } } }
        class EffectParticle { constructor(x, y, z, color) { this.mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({color:color})); this.mesh.position.set(x, y, z); game.scene.add(this.mesh); this.life = 1.0; } update() { this.life -= 0.05; this.mesh.rotation.x += 0.1; if(this.life <= 0) return false; return true; } }

        const game = new Game3D();

    </script>
</body>
</html>

